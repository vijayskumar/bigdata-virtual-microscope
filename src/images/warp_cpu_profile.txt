/* 
 * Command line: opannotate --source libocvmfilters.so 
 * 
 * Interpretation of command line:
 * Output annotated source file with samples
 * Output all files
 * 
 * CPU: P4 / Xeon with 2 hyper-threads, speed 3192.49 MHz (estimated)
 * Counted GLOBAL_POWER_EVENTS events (time during which processor is not stopped) with a unit mask of 0x01 (mandatory) count 100000
 */
/* 
 * Total samples for file : "/nfs/1/home/rutt/dev/ocvm/ocvm-cvs/src/f-warper.cpp"
 * 
 * 232552 51.6971
 */


               :#include "f-headers.h"
               :#include <pthread.h>
               :#include "math.h"
               :
               :#define MAX2(a, b) (a > b) ? a : b
               :#define MAXBUF 10000
               :
               :using namespace std;
               :
               :typedef struct Package
               :{
               :    ocvm_warper * clss;
               :    int id;
               :} Package;
               :
               :void * thread_calc(void *data);
               :
               :int ocvm_warper::process(void)
               :{ /* ocvm_warper::process() total:     19  0.0042 */
               :    std::cout << "ocvm_warper: starting on "
               :              << dcmpi_get_hostname() << endl;
               :
               :    myhostname = get_bind_host();
               :    std::string image_descriptor_string = get_param("image_descriptor_string");
               :    std::string dim_timestamp = get_param("dim_timestamp");
               :    int4 width, height;
               :    DCBuffer * response;
               :    
               :    image_descriptor.init_from_string(image_descriptor_string);
               :    xmax = image_descriptor.chunks_x;
               :    ymax = image_descriptor.chunks_y;
               :    zmax = image_descriptor.chunks_z;
               :    width = image_descriptor.pixels_x;
               :    height = image_descriptor.pixels_y;
               :    std::vector<std::string> hosts = image_descriptor.get_hosts();
               :    for (uint i = 0; i < hosts.size(); i++) {
               :        host_buffer[hosts[i]] = new DCBuffer(sizeof(int) + MAXBUF * (3 * sizeof(off_t) + 3 * sizeof(unsigned char)));
               :        host_buffer[hosts[i]]->pack("i", 0);
               :        host_pixels[hosts[i]] = 0;
               :    }
               :
               :    warp_filters_per_host = get_param_as_int("warp_filters_per_host");
               :    delta = get_param_as_int("delta");
               :    n = get_param_as_int("num_control_points");
               :
               :    float *x = (float *)malloc(n * sizeof(float));
               :    float *y = (float *)malloc(n * sizeof(float));
               :    float *u = (float *)malloc(n * sizeof(float));
               :    float *v = (float *)malloc(n * sizeof(float));
               :    int *w = (int *)malloc(n * sizeof(int));
               :
               :    for (uint i = 0; i < n; i++) {
               :        response = read("from_console");
               :        response->unpack("ffffi", &x[i], &y[i], &u[i], &v[i], &w[i]);
               ://        cout << myhostname << " " << x[i] << " " << y[i] << " " << u[i] << " " << v[i] << " " << w[i] << endl;
               :        delete response;
               :    }
               :    terms = maxterms((float)delta, x, y, u, v, n, MAX2(width, height));
               :    cout << "terms = " << terms << endl;
               :    initialize_basis_function( n, terms, x, y );
               :    allocate_indexed_polynomial( n, terms );
               :
               :/*
               :    int t;
               :    pthread_t *thread;
               :    void *thread_status;
               :    for ( t = 0; t < warp_filters_per_host; t++ ) {
               :        Package * p = new Package;
               :        p->clss = this;
               :        p->id = t;
               :        pthread_create(&thread[t], NULL, thread_calc, p);
               :    }
               :    for ( t = 0; t < warp_filters_per_host; t++ )
               :        pthread_join( thread[t], &thread_status );
               :
               :    free( pt );
               :*/
               :   // calculate(0);
               :
               :    int4 xloop, yloop, zloop;
               :
               :    if (myhostname == hosts[0]) {
               :        cout << "    Host    \t\t\t" << "    Chunk\t\t" << "Computation\t\t" << "Read extra\t" << "Mapping\t\t" << endl;
               :        cout << "----------------------------------------------------------------------------------------------------" << endl;
               :    }
               :    for (zloop = 0; zloop < zmax; zloop++) {
     1 2.2e-04 :        for (yloop = 0; yloop < ymax; yloop++) {
               :            for (xloop = 0; xloop < xmax; xloop++) {
               :                ImageCoordinate ic(xloop,yloop,zloop);
               :                ImagePart part = image_descriptor.get_part(ic);
               :                if (part.hostname != myhostname) {
               :                    continue;
               :                }
               :
               :                mediator_read_start(image_descriptor_string, ic.x, ic.y, ic.z);
               :
               :                off_t x_low, x_high, y_low, y_high;
               :                image_descriptor.get_coordinate_pixel_range(ic, x_low, x_high, y_low, y_high);
               :                off_t pixels_chunk_x = image_descriptor.chunk_dimensions_x[ic.x];
               :                off_t pixels_chunk_y = image_descriptor.chunk_dimensions_y[ic.y];
               :                float *u_scanlines = (float *)malloc(pixels_chunk_x * pixels_chunk_y * sizeof(float));
     2 4.4e-04 :                float *v_scanlines = (float *)malloc(pixels_chunk_x * pixels_chunk_y * sizeof(float));
               :                        double start = dcmpi_doubletime();
     2 4.4e-04 :                for (int chunk_loop = 0; chunk_loop < pixels_chunk_y; chunk_loop++) {
     3 6.7e-04 :                    float *u_ptr = u_scanlines + (chunk_loop*pixels_chunk_x);
     5  0.0011 :                    float *v_ptr = v_scanlines + (chunk_loop*pixels_chunk_x);
               :
     6  0.0013 :                    compute_coeff(width, height, x_low, y_low+(off_t)chunk_loop, pixels_chunk_x, x, y, u, v, 0, u_ptr, v_ptr);
               :                }
               :                cout << myhostname << "\t\t" << ic << "\t\t" << dcmpi_doubletime()-start << "\t\t";
               :
               :                        start = dcmpi_doubletime();
               :                MediatorImageResult * ic_reply =
               :                    mediator_read_finish();
               :                        cout << dcmpi_doubletime()-start << "\t\t"; 
               :                float m = 2.0 / (MAX2(width, height) - 1.0);
               :                float bx = -m * (width - 1.0) / 2.0;
               :                float by = -m * (height - 1.0) / 2.0;
               :                
               :                        start = dcmpi_doubletime();
               :                mapper(m, bx, by, u_scanlines, v_scanlines, ic_reply, xloop, yloop, zloop);
               :                        cout << dcmpi_doubletime()-start << endl; 
               ://                mapper(m, bx, by, u_scanlines, v_scanlines, mediator_read_finish(), xloop, yloop, zloop);
               :                
               :                delete ic_reply;
               :                free(u_scanlines);
               :                free(v_scanlines);
               :            }
               :        }
               :    }
               :    for (uint i = 0; i < hosts.size(); i++) {
               :           //host_buffer[hosts[i]]->pack("i", host_pixels[hosts[i]]);
               :           int xx = host_pixels[hosts[i]];
               :           memcpy(host_buffer[hosts[i]]->getPtr(), &xx, 4);
               :           write(host_buffer[hosts[i]], "to_" + hosts[i]);
               :           delete host_buffer[hosts[i]];
               :    }
               :
               :    mediator_say_goodbye();
               :
               :    std::cout << "ocvm_warper: exiting on "
               :              << dcmpi_get_hostname() << endl;
               :    return 0;
               :}
               :
               :// pthread_mutex_t mutex;
               :
               :void * thread_calc(void *data)
               :{
               :    Package * p = (Package*)data;
               :    ocvm_warper * clss = p->clss;
               :    int id = p->id;
               :    // ...
               :}
               :
               :void * ocvm_warper::calculate(void *data)
               :{
               :    int4 xloop, yloop, zloop;
               :    int start = *((int *)data);
               :
               :    for (zloop = 0; zloop < zmax; zloop++) {
               :        for (yloop = 0; yloop < ymax; yloop++) {
               :            for (xloop = 0; xloop < xmax; xloop++) {
               :                ImageCoordinate ic(xloop,yloop,zloop);
               :                ImagePart part = image_descriptor.get_part(ic);
               :                if (part.hostname != myhostname) {
               :                    continue;
               :                }
               :
               :                for (int chunk_loop = 0; chunk_loop < 480; chunk_loop++) {
               :                    //compute_coeff(width, height, 512, x, y, u, v, start, yloop*480+chunk_loop, *u_ptr, *v_ptr);
               :                }
               :            }
               :        }
               :    }
               ://    pthread_exit(NULL);
               :}
               :
               :int ocvm_warper::mapper(float m, float bx, float by, float *u, float *v, MediatorImageResult *in, int xloop, int yloop, int zloop)
     2 4.4e-04 :{ /* ocvm_warper::mapper(float, float, float, float*, float*, MediatorImageResult*, int, int, int) total:  18862  4.1931 */
               :    uint i, j;
     2 4.4e-04 :    off_t channel_offset = in->height * in->width;
               :    unsigned char *ir = in->data;
               :
   195  0.0433 :    for (j = 0; j < in->height; j++) {
   117  0.0260 :        register float VI = (m * j) + by;
   199  0.0442 :        register int vi = (VI - by) / m;
               :
  3257  0.7240 :        for (i = 0; i < in->width; i++) {
   124  0.0276 :            register float UI = (m * i) + bx;
   164  0.0365 :            register int ui = (UI - bx) / m;
   629  0.1398 :            register float U = u[vi * in->width + ui];
  2511  0.5582 :            register float V = v[vi * in->width + ui];
   539  0.1198 :            register off_t x = (U - bx) / m;
    85  0.0189 :            register off_t y = (V - by) / m; 
               :
   966  0.2147 :            if (x < 0 || y < 0 || x > image_descriptor.pixels_x || y > image_descriptor.pixels_y) continue;
               :            int cx, cy;
   411  0.0914 :            image_descriptor.pixel_to_chunk(x, y, cx, cy);
   226  0.0502 :            ImageCoordinate ic(cx, cy, zloop);
               ://            ImageCoordinate ic(xloop, yloop, zloop);
   282  0.0627 :            ImagePart part = image_descriptor.get_part(ic);
               :
   695  0.1545 :            host_pixels[part.hostname] = host_pixels[part.hostname] + 1;
               :
   537  0.1194 :            host_buffer[part.hostname]->Append(x);
   411  0.0914 :            host_buffer[part.hostname]->Append(y);
               ://            host_buffer[part.hostname]->Append(i + xloop*482);
               ://            host_buffer[part.hostname]->Append(j + yloop*450);
   778  0.1730 :            host_buffer[part.hostname]->Append((off_t)zloop);
   969  0.2154 :            off_t offset = j * in->width + i;
   385  0.0856 :            *(host_buffer[part.hostname]->getPtrFree()) = *(ir + offset);
   572  0.1272 :            host_buffer[part.hostname]->incrementUsedSize(sizeof(unsigned char));
   434  0.0965 :            *(host_buffer[part.hostname]->getPtrFree()) = *(ir + channel_offset + offset);
   539  0.1198 :            host_buffer[part.hostname]->incrementUsedSize(sizeof(unsigned char));
   460  0.1023 :            *(host_buffer[part.hostname]->getPtrFree()) = *(ir + 2*channel_offset + offset);
  1817  0.4039 :            host_buffer[part.hostname]->incrementUsedSize(sizeof(unsigned char));
               :                
               :
               :            if (host_pixels[part.hostname] % MAXBUF == 0) {
               :                int xx = host_pixels[part.hostname];
     1 2.2e-04 :                memcpy(host_buffer[part.hostname]->getPtr(), &xx, 4);
               :                host_pixels[part.hostname] = 0;
     2 4.4e-04 :                write(host_buffer[part.hostname], "to_" + part.hostname);
     1 2.2e-04 :                host_buffer[part.hostname]->Empty();
  1377  0.3061 :                host_buffer[part.hostname]->pack("i", 0);
               :            }
               :
               :        }
               :    }
               :
    74  0.0165 :    return 0;
   101  0.0225 :}
               :
               :float ocvm_warper::basis( int f, float x, float y )
   326  0.0725 :{ /* ocvm_warper::basis(int, float, float) total:   2573  0.5720 */
               :    float h;
               :
               :    switch ( f ) {
               :
               :    case 0: {
               :        h = 1.0;
               :        break;
               :    }
               :    case 1: {
               :        h = x;
               :        break;
               :    }
               :    case 2: {
               :        h = y;
               :        break;
               :    }
               :    case 3: {
               :        h = x * x;
               :        break;
               :    }
               :    case 4: {
               :        h = x * y;
               :        break;
               :    }
               :    case 5: {
               :        h = y * y;
               :        break;
               :    }
               :    case 6: {
               :        h = x * x * x;
               :        break;
               :    }
               :    case 7: {
               :        h = x * x * y;
               :        break;
               :    }
               :    case 8: {
               :        h = x * y * y;
               :        break;
               :    }
               :    case 9: {
               :        h = y * y * y;
               :        break;
               :    }
               :
               :    }
               :    return h;
               :}
               :
               :int ocvm_warper::initialize_basis_function_terms( int t, int i, int terms, float x, float y )
   258  0.0574 :{ /* ocvm_warper::initialize_basis_function_terms(int, int, int, float, float) total:  23036  5.1210 */
               :    int f;
               :
  2365  0.5257 :    for ( f = 0; f < terms; f++ )
 15512  3.4484 :        basis_function[t][i][f] = basis( f, x, y );
               :
   544  0.1209 :    return 0;
  4357  0.9686 :}
               :
               :float ocvm_warper::indexed_poly( int t, int k, int index, float A[MAXTERMS][MAXTERMS] )
  3881  0.8628 :{ /* ocvm_warper::indexed_poly(int, int, int, float (*) [10]) total:  71490 15.8925 */
   835  0.1856 :    float p = 0.0;
               :
  7008  1.5579 :    if ( !scoreboard[t][index][k] ) {
               :        int i;
 15489  3.4433 :        for ( i = 0; i < k; i++ )
  5915  1.3149 :            p += A[k][i] * indexed_poly( t, i, index, A );
 10068  2.2381 :        p += A[k][k] * basis_function[t][index][k];
               :
  4776  1.0617 :        scoreboard[t][index][k] = true;
 12567  2.7937 :        indexed_polynomial[t][index][k] = p;
               :    } else
  6373  1.4167 :        p = indexed_polynomial[t][index][k];
               :
   809  0.1798 :    return p;
  3769  0.8379 :}
               :
               :float ocvm_warper::p_coef( int k, int N, float *Z, float *Wp, float denum )
  2993  0.6654 :{ /* ocvm_warper::p_coef(int, int, float*, float*, float) total:  19609  4.3591 */
               :    int i;
  4461  0.9917 :    float num = 0.0;
               :
  9502  2.1123 :    for ( i = 0; i < N; i++ )
  1223  0.2719 :        num += Wp[i] * Z[i];
               :
   722  0.1605 :    return num / denum;
   708  0.1574 :}
               :
               :float ocvm_warper::indexed_pre_coef( int t, int k, int N, float A[MAXTERMS][MAXTERMS], float *W, float *Wp )
  1360  0.3023 :{ /* ocvm_warper::indexed_pre_coef(int, int, int, float (*) [10], float*, float*) total:  25302  5.6247 */
               :    int i;
   514  0.1143 :    float denum = 0.0;
               :
  6748  1.5001 :    for ( i = 0; i < N; i++ ) {
 11958  2.6583 :        register float p = indexed_poly( t, k, i, A );
               :
  3927  0.8730 :        Wp[i] = W[i] * p;
   666  0.1481 :        denum += Wp[i] * p;
               :    }
    24  0.0053 :    return denum;
   105  0.0233 :}
               :
               :float ocvm_warper::indexed_init_alpha( int t, int j, int k, int N, float *W, float A[MAXTERMS][MAXTERMS] )
   724  0.1609 :{ /* ocvm_warper::indexed_init_alpha(int, int, int, int, float*, float (*) [10]) total:  40594  9.0242 */
               :    float a;
               :    register int i;
               :
    26  0.0058 :    if ( k == 0 )
   485  0.1078 :        a = 1.0;
   487  0.1083 :    else if ( j == k ) {
   290  0.0645 :        float num = 0.0;
   207  0.0460 :        float denum = 0.0;
               :
  2442  0.5429 :        for ( i = 0; i < N; i++ ) {
  6832  1.5188 :            float h = basis_function[t][i][j];
               :
  3078  0.6842 :            num += W[i];
   819  0.1821 :            denum += W[i] * h;
               :        }
   882  0.1961 :        a = -num / denum;
               :    } else {
     5  0.0011 :        float num = 0.0;
   529  0.1176 :        float denum = 0.0;
               :
  2235  0.4968 :        for ( i = 0; i < N; i++ ) {
               :            float h;
               :            float p;
               :
 12477  2.7737 :            h = basis_function[t][i][j];
  1821  0.4048 :            p = indexed_poly( t, k, i, A );
               :
  1072  0.2383 :            num += W[i] * p * h;
  6183  1.3745 :            denum += W[i] * p * p;
               :        }
               :        a = -A[j][j] * num / denum;
               :    }
               :    return a;
               :}
               :
               :int ocvm_warper::initialize_basis_function(int n, int terms, float *x, float *y)
               :{
               :
               :    int i;
               :    int count = n + 1;
               :    int t;
               :
               :    basis_function =
               :        ( float ***) malloc( warp_filters_per_host * sizeof( float **) );
               :    basis_function[0] =
               :        ( float **) malloc( warp_filters_per_host * count * sizeof( float *) );
               :    basis_function[0][0] =
               :        ( float *) malloc( warp_filters_per_host * count * terms * sizeof( float ) );
               :
               :    for ( i = 1; i < warp_filters_per_host; i++ )
               :        basis_function[i] = basis_function[i - 1] + count;
               :    for ( i = 1; i < count * warp_filters_per_host; i++ )
               :        basis_function[0][i] = basis_function[0][i - 1] + terms;
               :
               :    for ( t = 0; t < warp_filters_per_host; t++ )
               :        for ( i = 0; i < n; i++ )
               :            initialize_basis_function_terms( t, i, terms, x[i], y[i] );
               :
               :    return 0;
               :}
               :
               :int ocvm_warper::allocate_indexed_polynomial(int n, int terms)
               :{
               :    int i;
               :    int count = n + 1;
               :
               :    indexed_polynomial =
               :        ( float ***) malloc( warp_filters_per_host * sizeof( float *) );
               :    indexed_polynomial[0] =
               :        ( float **) malloc( warp_filters_per_host * count * sizeof( float **) );
               :    indexed_polynomial[0][0] =
               :        ( float *) malloc( warp_filters_per_host * count * terms * sizeof( float ) );
               :
               :    for ( i = 1; i < warp_filters_per_host; i++ )
               :        indexed_polynomial[i] = indexed_polynomial[i - 1] + count;
               :    for ( i = 1; i < warp_filters_per_host * count; i++ )
               :        indexed_polynomial[0][i] = indexed_polynomial[0][i - 1] + terms;
               :
               :    scoreboard = ( bool ***) malloc( warp_filters_per_host * sizeof( bool **) );
               :    scoreboard[0] =
               :        ( bool **) malloc( warp_filters_per_host * count * sizeof( bool *) );
               :    scoreboard[0][0] =
               :        ( bool *) malloc( warp_filters_per_host * count * terms * sizeof( bool ) );
               :
               :    for ( i = 1; i < warp_filters_per_host; i++ )
               :        scoreboard[i] = scoreboard[i - 1] + count;
               :    for ( i = 1; i < warp_filters_per_host * count; i++ )
               :        scoreboard[0][i] = scoreboard[0][i - 1] + terms;
               :
               :    return 0;
               :}
               :
               :float ocvm_warper::poly( int k, float x, float y, float A[MAXTERMS][MAXTERMS] )
               :{
               :    int i;
               :    float p = 0.0;
               :
               :    for ( i = 0; i < k; i++ )
               :        p += A[k][i] * poly( i, x, y, A );
               :    p += A[k][k] * basis( k, x, y );
               :
               :    return p;
               :}
               :
               :float ocvm_warper::init_alpha( int j, int k, int N, float *W, float *X, float *Y, float A[MAXTERMS][MAXTERMS] )
               :{
               :    float a;
               :    register int i;
               :
               :    if ( k == 0 )
               :        a = 1.0;
               :    else if ( j == k ) {
               :        float num = 0.0;
               :        float denum = 0.0;
               :
               :        for ( i = 0; i < N; i++ ) {
               :            float h = basis( j, X[i], Y[i] );
               :
               :            num += W[i];
               :            denum += W[i] * h;
               :        }
               :        a = -num / denum;
               :    } else {
               :        float num = 0.0;
               :        float denum = 0.0;
               :
               :        for ( i = 0; i < N; i++ ) {
               :            float h;
               :            float p;
               :
               :            h = basis( j, X[i], Y[i] );
               :            p = poly( k, X[i], Y[i], A );
               :
               :            num += W[i] * p * h;
               :            denum += W[i] * p * p;
               :        }
               :        a = -A[j][j] * num / denum;
               :    }
               :    return a;
               :}
               :
               :float ocvm_warper::coef( int k, int N, float A[MAXTERMS][MAXTERMS], float *W, float *X, float *Y, float *Z )
               :{
               :    int i;
               :    float num = 0.0;
               :    float denum = 0.0;
               :
               :    for ( i = 0; i < N; i++ ) {
               :        register float p = poly( k, X[i], Y[i], A );
               :        register float Wp = W[i] * p;
               :
               :        num += Wp * Z[i];
               :        denum += Wp * p;
               :    }
               :    return num / denum;
               :}
               :
               :int ocvm_warper::maxterms( float delta, float *X, float *Y, float *Z1, float *Z2, int N, int dimension )
               :{ /* ocvm_warper::maxterms(float, float*, float*, float*, float*, int, int) total:      2 4.4e-04 */
               :    int terms;
               :    float *W = ( float * ) alloca( sizeof( float ) * N );
               :    float A[MAXTERMS][MAXTERMS];
               :    float error1;
               :    float error2;
               :    float min_error = 0.5 / dimension;
               :
               :    /*
               :     * Determine the number of terms necessary for error < 0.5
               :     */
               :
               :    for ( terms = 3; terms < MAXTERMS; terms++ ) {
               :        int i;
               :
               :        for ( i = 0; i < N; i++ ) {
               :            register int j;
               :            register int t;
               :            register float f;
               :
               :            /*
               :             * Initialize W -- the weights of the control points on x,y
               :             */
               :
               :            for ( j = 0; j < N; j++ ) {
               :                register float dx = X[i] - X[j];
               :                register float dy = Y[i] - Y[j];
               :
               :                W[j] = 1.0 / sqrt( ( dx * dx ) + ( dy * dy ) + delta );
               :            }
               :
               :            /*
               :             * Initialize A == alpha_jk coefficients of ortho polynomials
               :             */
               :
               :            for ( j = 0; j < terms; j++ ) {
               :                register int k;
               :
               :                A[j][j] = init_alpha( j, j, N, W, X, Y, A );
               :
               :                for ( k = 0; k < j; k++ )
               :                    A[j][k] = init_alpha( j, k, N, W, X, Y, A );
               :            }
               :
               :            /*
               :             * Compute the error at each control point.
               :             */
               :
               :            error1 = Z1[i];
               :            error2 = Z2[i];
               :
               :            for ( t = 0; t < terms; t++ ) {
               :                register float p = poly( t, X[i], Y[i], A );
               :
               :                error1 -= coef( t, N, A, W, X, Y, Z1 ) * p;
               :                error2 -= coef( t, N, A, W, X, Y, Z2 ) * p;
               :            }
     2 4.4e-04 :            if ( ( fabs( error1 ) > min_error ) || ( fabs( error2 ) > min_error ) )
               :                break;
               :        }
               :        if ( i == N )
               :            break;
               :
               :    }
               :    return terms;
               :}
               :
               :int ocvm_warper::compute_coeff(int width, int height, 
               :                                off_t seedx, off_t seedy,
               :                                off_t chunk_width,
               :                                float *X, float *Y, 
               :                                float *Z1, float *Z2, 
               :                                int start,
               :                                float *u_ptr, float *v_ptr)
               :{ /* ocvm_warper::compute_coeff(int, int, long long, long long, long long, float*, float*, float*, float*, int, float*, float*) total:  33312  7.4054 */
               :
               :    float *W = ( float *) alloca( sizeof( float ) * n );
               :    float A[MAXTERMS][MAXTERMS];
     3 6.7e-04 :    float *Wp = ( float *) alloca( sizeof( float ) * n );
               :    int t;
     4 8.9e-04 :    float m = 2.0 / ( MAX2( width, height ) - 1.0 );
     1 2.2e-04 :    float bx = -m * ( width - 1.0 ) / 2.0;
     1 2.2e-04 :    float by = -m * ( height - 1.0 ) / 2.0;
               :    register int x;
               :    register int y;
               ://    register float yp = ( m * row ) + by;
    42  0.0093 :    register float yp = ( m * seedy ) + by;
               :
  1472  0.3272 :    for ( x = seedx + start, u_ptr += start, v_ptr += start;
               :          x < seedx + chunk_width;
               :          x += warp_filters_per_host, u_ptr += warp_filters_per_host, v_ptr += warp_filters_per_host ) {
               :
   952  0.2116 :        register float xp = ( m * x ) + bx;
               :        register float f1;
               :        register float f2;
               :        register int i;
               :        register int j;
               :        register int k;
               :        register int u;
               :        register int v;
               :
   361  0.0803 :        for ( i = 0; i < n; i++ ) {
               :
   314  0.0698 :            float dx = xp - X[i];
  5800  1.2894 :            float dy = yp - Y[i];
               :
  8537  1.8978 :            W[i] = 1.0 / sqrt( delta + ( dx * dx ) + ( dy * dy ) );
               :
               :        }
               :
  1200  0.2668 :        memset( &scoreboard[start][0][0],
               :                0,
               :                ( n + 1 ) * terms * sizeof( bool ) );
               :
   702  0.1561 :        for ( j = 0; j < terms; j++ )
  2203  0.4897 :            A[j][j] = indexed_init_alpha( start, j, j, n, W, A );
   470  0.1045 :        for ( j = 0; j < terms; j++ )
  1105  0.2456 :            for ( k = 0; k < j; k++ )
  1505  0.3346 :                A[j][k] = indexed_init_alpha( start, j, k, n, W, A );
               :
   460  0.1023 :        initialize_basis_function_terms( start, n, terms, xp, yp );
               :
   628  0.1396 :        f1 = f2 = 0.0;
   854  0.1898 :        for ( i = 0; i < terms; i++ ) {
               :
               :            register float p;
               :            register float denum;
               :
  1863  0.4142 :            p = indexed_poly( start, i, n, A );
  1996  0.4437 :            denum = indexed_pre_coef( start, i, n, A, W, Wp );
               :
  2032  0.4517 :            f1 += p_coef( i, n, Z1, Wp, denum ) * p;
   757  0.1683 :            f2 += p_coef( i, n, Z2, Wp, denum ) * p;
               :
               :        }
               :
    48  0.0107 :        *u_ptr = f1;
     2 4.4e-04 :        *v_ptr = f2;
               :    }
               :
               :    return 0;
               :}
/* 
 * Total samples for file : "/usr/include/c++/3.2/bits/stl_vector.h"
 * 
 *  48286 10.7341
 */


               :// Vector implementation -*- C++ -*-
               :
               :// Copyright (C) 2001, 2002 Free Software Foundation, Inc.
               ://
               :// This file is part of the GNU ISO C++ Library.  This library is free
               :// software; you can redistribute it and/or modify it under the
               :// terms of the GNU General Public License as published by the
               :// Free Software Foundation; either version 2, or (at your option)
               :// any later version.
               :
               :// This library is distributed in the hope that it will be useful,
               :// but WITHOUT ANY WARRANTY; without even the implied warranty of
               :// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
               :// GNU General Public License for more details.
               :
               :// You should have received a copy of the GNU General Public License along
               :// with this library; see the file COPYING.  If not, write to the Free
               :// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,
               :// USA.
               :
               :// As a special exception, you may use this file as part of a free software
               :// library without restriction.  Specifically, if other files instantiate
               :// templates or use macros or inline functions from this file, or you compile
               :// this file and link it with other files to produce an executable, this
               :// file does not by itself cause the resulting executable to be covered by
               :// the GNU General Public License.  This exception does not however
               :// invalidate any other reasons why the executable file might be covered by
               :// the GNU General Public License.
               :
               :/*
               : *
               : * Copyright (c) 1994
               : * Hewlett-Packard Company
               : *
               : * Permission to use, copy, modify, distribute and sell this software
               : * and its documentation for any purpose is hereby granted without fee,
               : * provided that the above copyright notice appear in all copies and
               : * that both that copyright notice and this permission notice appear
               : * in supporting documentation.  Hewlett-Packard Company makes no
               : * representations about the suitability of this software for any
               : * purpose.  It is provided "as is" without express or implied warranty.
               : *
               : *
               : * Copyright (c) 1996
               : * Silicon Graphics Computer Systems, Inc.
               : *
               : * Permission to use, copy, modify, distribute and sell this software
               : * and its documentation for any purpose is hereby granted without fee,
               : * provided that the above copyright notice appear in all copies and
               : * that both that copyright notice and this permission notice appear
               : * in supporting documentation.  Silicon Graphics makes no
               : * representations about the suitability of this  software for any
               : * purpose.  It is provided "as is" without express or implied warranty.
               : */
               :
               :/** @file stl_vector.h
               : *  This is an internal header file, included by other library headers.
               : *  You should not attempt to use it directly.
               : */
               :
               :#ifndef __GLIBCPP_INTERNAL_VECTOR_H
               :#define __GLIBCPP_INTERNAL_VECTOR_H
               :
               :#include <bits/stl_iterator_base_funcs.h>
               :#include <bits/functexcept.h>
               :#include <bits/concept_check.h>
               :
               :namespace std
               :{
               :
               :// The vector base class serves two purposes.  First, its constructor
               :// and destructor allocate (but don't initialize) storage.  This makes
               :// exception safety easier.  Second, the base class encapsulates all of
               :// the differences between SGI-style allocators and standard-conforming
               :// allocators.
               :
               :// Base class for ordinary allocators.
               :template <class _Tp, class _Allocator, bool _IsStatic>
               :class _Vector_alloc_base {
               :public:
               :  typedef typename _Alloc_traits<_Tp, _Allocator>::allocator_type
               :          allocator_type;
               :  allocator_type get_allocator() const { return _M_data_allocator; }
               :
               :  _Vector_alloc_base(const allocator_type& __a)
               :    : _M_data_allocator(__a), _M_start(0), _M_finish(0), _M_end_of_storage(0)
               :  {}
               :
               :protected:
               :  allocator_type _M_data_allocator;
               :  _Tp* _M_start;
               :  _Tp* _M_finish;
               :  _Tp* _M_end_of_storage;
               :
               :  _Tp* _M_allocate(size_t __n)
               :    { return _M_data_allocator.allocate(__n); }
               :  void _M_deallocate(_Tp* __p, size_t __n)
               :    { if (__p) _M_data_allocator.deallocate(__p, __n); }
               :};
               :
               :// Specialization for allocators that have the property that we don't
               :// actually have to store an allocator object.
               :template <class _Tp, class _Allocator>
               :class _Vector_alloc_base<_Tp, _Allocator, true> {
               :public:
               :  typedef typename _Alloc_traits<_Tp, _Allocator>::allocator_type
               :          allocator_type;
               :  allocator_type get_allocator() const { return allocator_type(); }
               :
               :  _Vector_alloc_base(const allocator_type&)
               :    : _M_start(0), _M_finish(0), _M_end_of_storage(0)
               :  {}
               :
               :protected:
               :  _Tp* _M_start;
               :  _Tp* _M_finish;
               :  _Tp* _M_end_of_storage;
               :
               :  typedef typename _Alloc_traits<_Tp, _Allocator>::_Alloc_type _Alloc_type;
               :  _Tp* _M_allocate(size_t __n)
               :    { return _Alloc_type::allocate(__n); }
               :  void _M_deallocate(_Tp* __p, size_t __n)
               :    { _Alloc_type::deallocate(__p, __n);}
               :};
               :
               :template <class _Tp, class _Alloc>
               :struct _Vector_base
               :  : public _Vector_alloc_base<_Tp, _Alloc,
               :                              _Alloc_traits<_Tp, _Alloc>::_S_instanceless>
               :{
               :  typedef _Vector_alloc_base<_Tp, _Alloc,
               :                             _Alloc_traits<_Tp, _Alloc>::_S_instanceless>
               :          _Base;
               :  typedef typename _Base::allocator_type allocator_type;
               :
               :  _Vector_base(const allocator_type& __a) : _Base(__a) {}
               :  _Vector_base(size_t __n, const allocator_type& __a) : _Base(__a) {
               :    _M_start = _M_allocate(__n);
               :    _M_finish = _M_start;
               :    _M_end_of_storage = _M_start + __n;
               :  }
               :
               :  ~_Vector_base() { _M_deallocate(_M_start, _M_end_of_storage - _M_start); }
               :};
               :
               :
               :/**
               : *  @brief  A standard container which offers fixed time access to individual
               : *  elements in any order.
               : *
               : *  @ingroup Containers
               : *  @ingroup Sequences
               : *
               : *  Meets the requirements of a <a href="tables.html#65">container</a>, a
               : *  <a href="tables.html#66">reversible container</a>, and a
               : *  <a href="tables.html#67">sequence</a>, including the
               : *  <a href="tables.html#68">optional sequence requirements</a> with the
               : *  %exception of @c push_front and @c pop_front.
               : *
               : *  In some terminology a vector can be described as a dynamic C-style array,
               : *  it offers fast and efficient access to individual elements in any order
               : *  and saves the user from worrying about memory and size allocation.
               : *  Subscripting ( [] ) access is also provided as with C-style arrays.
               :*/
               :template <class _Tp, class _Alloc = allocator<_Tp> >
               :class vector : protected _Vector_base<_Tp, _Alloc>
               :{
               :  // concept requirements
               :  __glibcpp_class_requires(_Tp, _SGIAssignableConcept)
               :
               :private:
               :  typedef _Vector_base<_Tp, _Alloc> _Base;
               :  typedef vector<_Tp, _Alloc> vector_type;
               :public:
               :  typedef _Tp 						value_type;
               :  typedef value_type* 					pointer;
               :  typedef const value_type* 				const_pointer;
               :  typedef __gnu_cxx::__normal_iterator<pointer, vector_type> 	iterator;
               :  typedef __gnu_cxx::__normal_iterator<const_pointer, vector_type>
               :                                                        const_iterator;
               :  typedef value_type& 					reference;
               :  typedef const value_type& 				const_reference;
               :  typedef size_t 					size_type;
               :  typedef ptrdiff_t 					difference_type;
               :
               :  typedef typename _Base::allocator_type allocator_type;
               :  allocator_type get_allocator() const { return _Base::get_allocator(); }
               :
               :  typedef reverse_iterator<const_iterator> const_reverse_iterator;
               :  typedef reverse_iterator<iterator> reverse_iterator;
               :
               :protected:
               :  using _Base::_M_allocate;
               :  using _Base::_M_deallocate;
               :  using _Base::_M_start;
               :  using _Base::_M_finish;
               :  using _Base::_M_end_of_storage;
               :
               :protected:
               :  void _M_insert_aux(iterator __position, const _Tp& __x);
               :  void _M_insert_aux(iterator __position);
               :
               :public:
               :  /**
               :   *  Returns a read/write iterator that points to the first element in the
               :   *  vector.  Iteration is done in ordinary element order.
               :  */
 19523  4.3400 :  iterator begin() { return iterator (_M_start); } /* std::vector<ImagePart, std::allocator<ImagePart> >::begin() total:  10206  2.2688 */
               :
               :  /**
               :   *  Returns a read-only (constant) iterator that points to the first element
               :   *  in the vector.  Iteration is done in ordinary element order.
               :  */
               :  const_iterator begin() const
               :    { return const_iterator (_M_start); }
               :
               :  /**
               :   *  Returns a read/write iterator that points one past the last element in
               :   *  the vector.  Iteration is done in ordinary element order.
               :  */
               :  iterator end() { return iterator (_M_finish); }
               :
               :  /**
               :   *  Returns a read-only (constant) iterator that points one past the last
               :   *  element in the vector.  Iteration is done in ordinary element order.
               :  */
               :  const_iterator end() const { return const_iterator (_M_finish); }
               :
               :  /**
               :   *  Returns a read/write reverse iterator that points to the last element in
               :   *  the vector.  Iteration is done in reverse element order.
               :  */
               :  reverse_iterator rbegin()
               :    { return reverse_iterator(end()); }
               :
               :  /**
               :   *  Returns a read-only (constant) reverse iterator that points to the last
               :   *  element in the vector.  Iteration is done in reverse element order.
               :  */
               :  const_reverse_iterator rbegin() const
               :    { return const_reverse_iterator(end()); }
               :
               :  /**
               :   *  Returns a read/write reverse iterator that points to one before the
               :   *  first element in the vector.  Iteration is done in reverse element
               :   *  order.
               :  */
               :  reverse_iterator rend()
               :    { return reverse_iterator(begin()); }
               :
               :  /**
               :   *  Returns a read-only (constant) reverse iterator that points to one
               :   *  before the first element in the vector.  Iteration is done in reverse
               :   *  element order.
               :  */
               :  const_reverse_iterator rend() const
               :    { return const_reverse_iterator(begin()); }
               :
               :  /**  Returns the number of elements in the vector.  */
               :  size_type size() const
 13774  3.0620 :    { return size_type(end() - begin()); } /* std::vector<long long, std::allocator<long long> >::operator[](unsigned int) total:  18886  4.1984 */
               :
               :  /**  Returns the size of the largest possible vector.  */
               :  size_type max_size() const
               :    { return size_type(-1) / sizeof(_Tp); }
               :
               :  /**
               :   *  Returns the amount of memory that has been alocated for the current
               :   *  elements (?).
               :  */
               :  size_type capacity() const
               :    { return size_type(const_iterator(_M_end_of_storage) - begin()); }
               :
               :  /**
               :   *  Returns true if the vector is empty.  (Thus begin() would equal end().)
               :  */
               :  bool empty() const
               :    { return begin() == end(); }
               :
               :  /**
               :   *  @brief  Subscript access to the data contained in the vector.
               :   *  @param  n  The element for which data should be accessed.
               :   *  @return  Read/write reference to data.
               :   *
               :   *  This operator allows for easy, array-style, data access.
               :   *  Note that data access with this operator is unchecked and out_of_range
               :   *  lookups are not defined. (For checked lookups see at().)
               :  */
 13253  2.9462 :  reference operator[](size_type __n) { return *(begin() + __n); } /* std::vector<ImagePart, std::allocator<ImagePart> >::operator[](unsigned int) total:    438  0.0974 */
               :
               :  /**
               :   *  @brief  Subscript access to the data contained in the vector.
               :   *  @param  n  The element for which data should be accessed.
               :   *  @return  Read-only (constant) reference to data.
               :   *
               :   *  This operator allows for easy, array-style, data access.
               :   *  Note that data access with this operator is unchecked and out_of_range
               :   *  lookups are not defined. (For checked lookups see at().)
               :  */
               :  const_reference operator[](size_type __n) const { return *(begin() + __n); }
               :
               :  void _M_range_check(size_type __n) const {
               :    if (__n >= this->size())
               :      __throw_out_of_range("vector");
               :  }
               :
               :  /**
               :   *  @brief  Provides access to the data contained in the vector.
               :   *  @param  n  The element for which data should be accessed.
               :   *  @return  Read/write reference to data.
               :   *
               :   *  This function provides for safer data access.  The parameter is first
               :   *  checked that it is in the range of the vector.  The function throws
               :   *  out_of_range if the check fails.
               :  */
               :  reference at(size_type __n)
               :    { _M_range_check(__n); return (*this)[__n]; }
               :
               :  /**
               :   *  @brief  Provides access to the data contained in the vector.
               :   *  @param  n  The element for which data should be accessed.
               :   *  @return  Read-only (constant) reference to data.
               :   *
               :   *  This function provides for safer data access.  The parameter is first
               :   *  checked that it is in the range of the vector.  The function throws
               :   *  out_of_range if the check fails.
               :  */
               :  const_reference at(size_type __n) const
               :    { _M_range_check(__n); return (*this)[__n]; }
               :
               :
               :  explicit vector(const allocator_type& __a = allocator_type())
               :    : _Base(__a) {}
               :
               :  vector(size_type __n, const _Tp& __value,
               :         const allocator_type& __a = allocator_type())
               :    : _Base(__n, __a)
               :    { _M_finish = uninitialized_fill_n(_M_start, __n, __value); }
               :
               :  explicit vector(size_type __n)
               :    : _Base(__n, allocator_type())
               :    { _M_finish = uninitialized_fill_n(_M_start, __n, _Tp()); }
               :
               :  vector(const vector<_Tp, _Alloc>& __x)
               :    : _Base(__x.size(), __x.get_allocator())
               :    { _M_finish = uninitialized_copy(__x.begin(), __x.end(), _M_start); }
               :
               :  // Check whether it's an integral type.  If so, it's not an iterator.
               :  template <class _InputIterator>
               :    vector(_InputIterator __first, _InputIterator __last,
               :           const allocator_type& __a = allocator_type())
               :	: _Base(__a)
               :	{
               :      typedef typename _Is_integer<_InputIterator>::_Integral _Integral;
               :      _M_initialize_aux(__first, __last, _Integral());
               :    }
               :
               :  template <class _Integer>
               :    void _M_initialize_aux(_Integer __n, _Integer __value, __true_type)
               :	{
               :      _M_start = _M_allocate(__n);
               :      _M_end_of_storage = _M_start + __n;
               :      _M_finish = uninitialized_fill_n(_M_start, __n, __value);
               :    }
               :
               :  template<class _InputIterator>
               :    void
               :	_M_initialize_aux(_InputIterator __first, _InputIterator __last, __false_type)
               :	{
               :	  typedef typename iterator_traits<_InputIterator>::iterator_category _IterCategory;
               :	  _M_range_initialize(__first, __last, _IterCategory());
               :	}
               :
               :  ~vector()
               :  { _Destroy(_M_start, _M_finish); } /* std::vector<ImagePart, std::allocator<ImagePart> >::size() const total:   7598  1.6891 */
               :
               :  vector<_Tp, _Alloc>& operator=(const vector<_Tp, _Alloc>& __x);
               :
               :  /**
               :   *  @brief  Attempt to preallocate enough memory for specified number of
               :   *          elements.
               :   *  @param  n  Number of elements required
               :   *
               :   *  This function attempts to reserve enough memory for the vector to hold
               :   *  the specified number of elements.  If the number requested is more than
               :   *  max_size() length_error is thrown.
               :   *
               :   *  The advantage of this function is that if optimal code is a necessity
               :   *  and the user can determine the number of elements that will be required
               :   *  the user can reserve the memory and thus prevent a possible
               :   *  reallocation of memory and copy of vector data.
               :  */
               :  void reserve(size_type __n) {
               :    if (__n > this->max_size())
               :      __throw_length_error("vector::reserve");
               :    if (this->capacity() < __n) {
               :      const size_type __old_size = size();
               :      pointer __tmp = _M_allocate_and_copy(__n, _M_start, _M_finish);
               :      _Destroy(_M_start, _M_finish);
               :      _M_deallocate(_M_start, _M_end_of_storage - _M_start);
               :      _M_start = __tmp;
               :      _M_finish = __tmp + __old_size;
               :      _M_end_of_storage = _M_start + __n;
               :    }
               :  }
               :
               :  // assign(), a generalized assignment member function.  Two
               :  // versions: one that takes a count, and one that takes a range.
               :  // The range version is a member template, so we dispatch on whether
               :  // or not the type is an integer.
               :
               :  /**
               :   *  @brief  Assigns a given value or range to a vector.
               :   *  @param  n  Number of elements to be assigned.
               :   *  @param  val  Value to be assigned.
               :   *
               :   *  This function can be used to assign a range to a vector or fill it
               :   *  with a specified number of copies of the given value.
               :   *  Note that the assignment completely changes the vector and that the
               :   *  resulting vector's size is the same as the number of elements assigned.
               :   *  Old data may be lost.
               :  */
               :  void assign(size_type __n, const _Tp& __val) { _M_fill_assign(__n, __val); }
               :  void _M_fill_assign(size_type __n, const _Tp& __val);
               :
               :  template<class _InputIterator>
               :    void
               :    assign(_InputIterator __first, _InputIterator __last)
               :    {
               :      typedef typename _Is_integer<_InputIterator>::_Integral _Integral;
               :      _M_assign_dispatch(__first, __last, _Integral());
               :    }
               :
               :  template<class _Integer>
               :    void
               :     _M_assign_dispatch(_Integer __n, _Integer __val, __true_type)
               :     { _M_fill_assign((size_type) __n, (_Tp) __val); }
               :
               :  template<class _InputIter>
               :    void
               :    _M_assign_dispatch(_InputIter __first, _InputIter __last, __false_type)
               :    {
               :      typedef typename iterator_traits<_InputIter>::iterator_category _IterCategory;
               :      _M_assign_aux(__first, __last, _IterCategory());
               :    }
               :
               :  template <class _InputIterator>
               :    void 
               :    _M_assign_aux(_InputIterator __first, _InputIterator __last,
               :		  input_iterator_tag);
               :
               :  template <class _ForwardIterator>
               :    void 
               :    _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,
               :		  forward_iterator_tag);
               :
               :  /**
               :   *  Returns a read/write reference to the data at the first element of the
               :   *  vector.
               :  */
               :  reference front() { return *begin(); }
               :
               :  /**
               :   *  Returns a read-only (constant) reference to the data at the first
               :   *  element of the vector.
               :  */
               :  const_reference front() const { return *begin(); }
               :
               :  /**
               :   *  Returns a read/write reference to the data at the last element of the
               :   *  vector.
               :  */
               :  reference back() { return *(end() - 1); }
               :
               :  /**
               :   *  Returns a read-only (constant) reference to the data at the first
               :   *  element of the vector.
               :  */
               :  const_reference back() const { return *(end() - 1); }
               :
               :  /**
               :   *  @brief  Add data to the end of the vector.
               :   *  @param  x  Data to be added.
               :   *
               :   *  This is a typical stack operation.  The function creates an element at
               :   *  the end of the vector and assigns the given data to it.
               :   *  Due to the nature of a vector this operation can be done in constant
               :   *  time if the vector has preallocated space available.
               :  */
               :  void
               :  push_back(const _Tp& __x)
               :  {
               :    if (_M_finish != _M_end_of_storage) {
               :      _Construct(_M_finish, __x);
               :      ++_M_finish;
               :    }
               :    else
               :      _M_insert_aux(end(), __x);
               :  }
               :
               :#ifdef _GLIBCPP_DEPRECATED
               :  /**
               :   *  Add an element to the end of the vector.  The element is
               :   *  default-constructed.
               :   *
               :   *  @note You must define _GLIBCPP_DEPRECATED to make this visible; see
               :   *        c++config.h.
               :  */
               :  void
               :  push_back()
               :  {
               :    if (_M_finish != _M_end_of_storage) {
               :      _Construct(_M_finish);
               :      ++_M_finish;
               :    }
               :    else
               :      _M_insert_aux(end());
               :  }
               :#endif
               :
               :  void
               :  swap(vector<_Tp, _Alloc>& __x)
               :  {
               :    std::swap(_M_start, __x._M_start);
               :    std::swap(_M_finish, __x._M_finish);
               :    std::swap(_M_end_of_storage, __x._M_end_of_storage);
               :  }
               :
               :  /**
               :   *  @brief  Inserts given value into vector at specified element.
               :   *  @param  position  An iterator that points to the element where data
               :   *                    should be inserted.
               :   *  @param  x  Data to be inserted.
               :   *  @return  An iterator that points to the inserted data.
               :   *
               :   *  This function will insert the given value into the specified location.
               :   *  Note that this kind of operation could be expensive for a vector and if
               :   *  it is frequently used the user should consider using std::list.
               :  */
               :  iterator
               :  insert(iterator __position, const _Tp& __x)
               :  {
               :    size_type __n = __position - begin();
               :    if (_M_finish != _M_end_of_storage && __position == end()) {
               :      _Construct(_M_finish, __x);
               :      ++_M_finish;
               :    }
               :    else
               :      _M_insert_aux(iterator(__position), __x);
               :    return begin() + __n;
               :  }
               :
               :  /**
               :   *  @brief  Inserts an empty element into the vector.
               :   *  @param  position  An iterator that points to the element where empty
               :   *                    element should be inserted.
               :   *  @param  x  Data to be inserted.
               :   *  @return  An iterator that points to the inserted element.
               :   *
               :   *  This function will insert an empty element into the specified location.
               :   *  Note that this kind of operation could be expensive for a vector and if
               :   *  it is frequently used the user should consider using std::list.
               :  */
               :  iterator
               :  insert(iterator __position)
               :  {
               :    size_type __n = __position - begin();
               :    if (_M_finish != _M_end_of_storage && __position == end()) {
               :      _Construct(_M_finish);
               :      ++_M_finish;
               :    }
               :    else
               :      _M_insert_aux(iterator(__position));
               :    return begin() + __n;
               :  }
               :
               :  // Check whether it's an integral type.  If so, it's not an iterator.
               :  template<class _InputIterator>
               :    void
               :	insert(iterator __pos, _InputIterator __first, _InputIterator __last)
               :	{
               :      typedef typename _Is_integer<_InputIterator>::_Integral _Integral;
               :      _M_insert_dispatch(__pos, __first, __last, _Integral());
               :    }
               :
               :  template <class _Integer>
               :    void
               :	_M_insert_dispatch(iterator __pos, _Integer __n, _Integer __val, __true_type)
               :    { _M_fill_insert(__pos, static_cast<size_type>(__n), static_cast<_Tp>(__val)); }
               :
               :  template<class _InputIterator>
               :    void
               :	_M_insert_dispatch(iterator __pos,
               :                       _InputIterator __first, _InputIterator __last,
               :                       __false_type)
               :	{
               :	  typedef typename iterator_traits<_InputIterator>::iterator_category _IterCategory;
               :      _M_range_insert(__pos, __first, __last, _IterCategory());
               :    }
               :
               :  /**
               :   *  @brief  Inserts a number of copies of given data into the vector.
               :   *  @param  position  An iterator that points to the element where data
               :   *                    should be inserted.
               :   *  @param  n  Amount of elements to be inserted.
               :   *  @param  x  Data to be inserted.
               :   *
               :   *  This function will insert a specified number of copies of the given data
               :   *  into the specified location.
               :   *
               :   *  Note that this kind of operation could be expensive for a vector and if
               :   *  it is frequently used the user should consider using std::list.
               :  */
               :  void insert (iterator __pos, size_type __n, const _Tp& __x)
               :    { _M_fill_insert(__pos, __n, __x); }
               :
               :  void _M_fill_insert (iterator __pos, size_type __n, const _Tp& __x);
               :
               :  /**
               :   *  @brief  Removes last element from vector.
               :   *
               :   *  This is a typical stack operation. It allows us to shrink the vector by
               :   *  one.
               :   *
               :   *  Note that no data is returned and if last element's data is needed it
               :   *  should be retrieved before pop_back() is called.
               :  */
               :  void pop_back() {
               :    --_M_finish;
               :    _Destroy(_M_finish);
               :  }
               :
               :  /**
               :   *  @brief  Remove element at given position
               :   *  @param  position  Iterator pointing to element to be erased.
               :   *  @return  Doc Me! (Iterator pointing to new element at old location?)
               :   *
               :   *  This function will erase the element at the given position and thus
               :   *  shorten the vector by one.
               :   *
               :   *  Note This operation could be expensive and if it is frequently used the
               :   *  user should consider using std::list.  The user is also cautioned that
               :   *  this function only erases the element, and that if the element is itself
               :   *  a pointer, the pointed-to memory is not touched in any way.  Managing
               :   *  the pointer is the user's responsibilty.
               :  */
               :  iterator erase(iterator __position) {
               :    if (__position + 1 != end())
               :      copy(__position + 1, end(), __position);
               :    --_M_finish;
               :    _Destroy(_M_finish);
               :    return __position;
               :  }
               :
               :  /**
               :   *  @brief  Remove a range of elements from a vector.
               :   *  @param  first  Iterator pointing to the first element to be erased.
               :   *  @param  last  Iterator pointing to the last element to be erased.
               :   *  @return  Doc Me! (Iterator pointing to new element at old location?)
               :   *
               :   *  This function will erase the elements in the given range and shorten the
               :   *  vector accordingly.
               :   *
               :   *  Note This operation could be expensive and if it is frequently used the
               :   *  user should consider using std::list.  The user is also cautioned that
               :   *  this function only erases the elements, and that if the elements
               :   *  themselves are pointers, the pointed-to memory is not touched in any
               :   *  way.  Managing the pointer is the user's responsibilty.
               :  */
               :  iterator erase(iterator __first, iterator __last) {
               :    iterator __i(copy(__last, end(), __first));
               :    _Destroy(__i, end());
               :    _M_finish = _M_finish - (__last - __first);
               :    return __first;
               :  }
               :
               :  /**
               :   *  @brief  Resizes the vector to the specified number of elements.
               :   *  @param  new_size  Number of elements the vector should contain.
               :   *  @param  x  Data with which new elements should be populated.
               :   *
               :   *  This function will resize the vector to the specified number of
               :   *  elements.  If the number is smaller than the vector's current size the
               :   *  vector is truncated, otherwise the vector is extended and new elements
               :   *  are populated with given data.
               :  */
               :  void resize(size_type __new_size, const _Tp& __x) {
               :    if (__new_size < size())
               :      erase(begin() + __new_size, end());
               :    else
               :      insert(end(), __new_size - size(), __x);
               :  }
               :
               :  /**
               :   *  @brief  Resizes the vector to the specified number of elements.
               :   *  @param  new_size  Number of elements the vector should contain.
               :   *
               :   *  This function will resize the vector to the specified number of
               :   *  elements.  If the number is smaller than the vector's current size the
               :   *  vector is truncated, otherwise the vector is extended and new elements
               :   *  are left uninitialized.
               :  */
               :  void resize(size_type __new_size) { resize(__new_size, _Tp()); }
               :
               :  /**
               :   *  Erases all elements in vector.  Note that this function only erases the
               :   *  elements, and that if the elements themselves are pointers, the
               :   *  pointed-to memory is not touched in any way.  Managing the pointer is
               :   *  the user's responsibilty.
               :  */
               :  void clear() { erase(begin(), end()); }
               :
               :protected:
               :
               :  template <class _ForwardIterator>
               :  pointer _M_allocate_and_copy(size_type __n, _ForwardIterator __first,
               :                                               _ForwardIterator __last)
               :  {
               :    pointer __result = _M_allocate(__n);
               :    try {
               :      uninitialized_copy(__first, __last, __result);
               :      return __result;
               :    }
               :    catch(...)
               :      {
               :	_M_deallocate(__result, __n);
               :	__throw_exception_again;
               :      }
               :  }
               :
               :  template <class _InputIterator>
               :  void _M_range_initialize(_InputIterator __first,
               :                           _InputIterator __last, input_iterator_tag)
               :  {
               :    for ( ; __first != __last; ++__first)
               :      push_back(*__first);
               :  }
               :
               :  // This function is only called by the constructor.
               :  template <class _ForwardIterator>
               :  void _M_range_initialize(_ForwardIterator __first,
               :                           _ForwardIterator __last, forward_iterator_tag)
               :  {
               :    size_type __n = distance(__first, __last);
               :    _M_start = _M_allocate(__n);
               :    _M_end_of_storage = _M_start + __n;
               :    _M_finish = uninitialized_copy(__first, __last, _M_start);
               :  }
               :
               :  template <class _InputIterator>
               :  void _M_range_insert(iterator __pos,
               :                       _InputIterator __first, _InputIterator __last,
               :                       input_iterator_tag);
               :
               :  template <class _ForwardIterator>
               :  void _M_range_insert(iterator __pos,
               :                       _ForwardIterator __first, _ForwardIterator __last,
               :                       forward_iterator_tag);
               :};
               :
               :template <class _Tp, class _Alloc>
               :inline bool
               :operator==(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
               :{
               :  return __x.size() == __y.size() &&
               :         equal(__x.begin(), __x.end(), __y.begin());
               :}
               :
               :template <class _Tp, class _Alloc>
               :inline bool
               :operator<(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
               :{
               :  return lexicographical_compare(__x.begin(), __x.end(),
               :                                 __y.begin(), __y.end());
               :}
               :
               :template <class _Tp, class _Alloc>
               :inline void swap(vector<_Tp, _Alloc>& __x, vector<_Tp, _Alloc>& __y)
               :{
               :  __x.swap(__y);
               :}
               :
               :template <class _Tp, class _Alloc>
               :inline bool
               :operator!=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y) {
               :  return !(__x == __y);
               :}
               :
               :template <class _Tp, class _Alloc>
               :inline bool
               :operator>(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y) {
               :  return __y < __x;
               :}
               :
               :template <class _Tp, class _Alloc>
               :inline bool
               :operator<=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y) {
               :  return !(__y < __x);
               :}
               :
               :template <class _Tp, class _Alloc>
               :inline bool
               :operator>=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y) {
               :  return !(__x < __y);
               :}
               :
               :template <class _Tp, class _Alloc>
               :vector<_Tp,_Alloc>&
               :vector<_Tp,_Alloc>::operator=(const vector<_Tp, _Alloc>& __x)
               :{
               :  if (&__x != this) {
               :    const size_type __xlen = __x.size();
               :    if (__xlen > capacity()) {
               :      pointer __tmp = _M_allocate_and_copy(__xlen, __x.begin(), __x.end());
               :      _Destroy(_M_start, _M_finish);
               :      _M_deallocate(_M_start, _M_end_of_storage - _M_start);
               :      _M_start = __tmp;
               :      _M_end_of_storage = _M_start + __xlen;
               :    }
               :    else if (size() >= __xlen) {
               :      iterator __i(copy(__x.begin(), __x.end(), begin()));
               :      _Destroy(__i, end());
               :    }
               :    else {
               :      copy(__x.begin(), __x.begin() + size(), _M_start);
               :      uninitialized_copy(__x.begin() + size(), __x.end(), _M_finish);
               :    }
               :    _M_finish = _M_start + __xlen;
               :  }
               :  return *this;
               :}
               :
               :template <class _Tp, class _Alloc>
               :void vector<_Tp, _Alloc>::_M_fill_assign(size_t __n, const value_type& __val)
               :{
               :  if (__n > capacity()) {
               :    vector<_Tp, _Alloc> __tmp(__n, __val, get_allocator());
               :    __tmp.swap(*this);
               :  }
               :  else if (__n > size()) {
               :    fill(begin(), end(), __val);
               :    _M_finish = uninitialized_fill_n(_M_finish, __n - size(), __val);
               :  }
               :  else
               :    erase(fill_n(begin(), __n, __val), end());
               :}
               :
               :template <class _Tp, class _Alloc> template <class _InputIter>
               :void vector<_Tp, _Alloc>::_M_assign_aux(_InputIter __first, _InputIter __last,
               :                                        input_iterator_tag) {
               :  iterator __cur(begin());
               :  for ( ; __first != __last && __cur != end(); ++__cur, ++__first)
               :    *__cur = *__first;
               :  if (__first == __last)
               :    erase(__cur, end());
               :  else
               :    insert(end(), __first, __last);
               :}
               :
               :template <class _Tp, class _Alloc> template <class _ForwardIter>
               :void
               :vector<_Tp, _Alloc>::_M_assign_aux(_ForwardIter __first, _ForwardIter __last,
               :                                   forward_iterator_tag) {
               :  size_type __len = distance(__first, __last);
               :
               :  if (__len > capacity()) {
               :    pointer __tmp(_M_allocate_and_copy(__len, __first, __last));
               :    _Destroy(_M_start, _M_finish);
               :    _M_deallocate(_M_start, _M_end_of_storage - _M_start);
               :    _M_start = __tmp;
               :    _M_end_of_storage = _M_finish = _M_start + __len;
               :  }
               :  else if (size() >= __len) {
               :    iterator __new_finish(copy(__first, __last, _M_start));
               :    _Destroy(__new_finish, end());
               :    _M_finish = __new_finish.base();
               :  }
               :  else {
               :    _ForwardIter __mid = __first;
               :    advance(__mid, size());
               :    copy(__first, __mid, _M_start);
               :    _M_finish = uninitialized_copy(__mid, __last, _M_finish);
               :  }
               :}
               :
               :template <class _Tp, class _Alloc>
               :void
               :vector<_Tp, _Alloc>::_M_insert_aux(iterator __position, const _Tp& __x)
               :{
               :  if (_M_finish != _M_end_of_storage) {
               :    _Construct(_M_finish, *(_M_finish - 1));
               :    ++_M_finish;
               :    _Tp __x_copy = __x;
               :    copy_backward(__position, iterator(_M_finish - 2), iterator(_M_finish- 1));
  1736  0.3859 :    *__position = __x_copy; /* ImagePart::operator=(ImagePart const&) total:   1238  0.2752 */
               :  }
               :  else {
               :    const size_type __old_size = size();
               :    const size_type __len = __old_size != 0 ? 2 * __old_size : 1;
               :    iterator __new_start(_M_allocate(__len));
               :    iterator __new_finish(__new_start);
               :    try {
               :      __new_finish = uninitialized_copy(iterator(_M_start), __position,
               :                                        __new_start);
               :      _Construct(__new_finish.base(), __x);
               :      ++__new_finish;
               :      __new_finish = uninitialized_copy(__position, iterator(_M_finish),
               :                                        __new_finish);
               :    }
               :    catch(...)
               :      {
               :	_Destroy(__new_start,__new_finish);
               :	_M_deallocate(__new_start.base(),__len);
               :	__throw_exception_again;
               :      }
               :    _Destroy(begin(), end());
               :    _M_deallocate(_M_start, _M_end_of_storage - _M_start);
               :    _M_start = __new_start.base();
               :    _M_finish = __new_finish.base();
               :    _M_end_of_storage = __new_start.base() + __len;
               :  }
               :}
               :
               :template <class _Tp, class _Alloc>
               :void
               :vector<_Tp, _Alloc>::_M_insert_aux(iterator __position)
               :{
               :  if (_M_finish != _M_end_of_storage) {
               :    _Construct(_M_finish, *(_M_finish - 1));
               :    ++_M_finish;
               :    copy_backward(__position, iterator(_M_finish - 2),
               :		  iterator(_M_finish - 1));
               :    *__position = _Tp();
               :  }
               :  else {
               :    const size_type __old_size = size();
               :    const size_type __len = __old_size != 0 ? 2 * __old_size : 1;
               :    pointer __new_start = _M_allocate(__len);
               :    pointer __new_finish = __new_start;
               :    try {
               :      __new_finish = uninitialized_copy(iterator(_M_start), __position,
               :					__new_start);
               :      _Construct(__new_finish);
               :      ++__new_finish;
               :      __new_finish = uninitialized_copy(__position, iterator(_M_finish),
               :					__new_finish);
               :    }
               :    catch(...)
               :      {
               :	_Destroy(__new_start,__new_finish);
               :	_M_deallocate(__new_start,__len);
               :	__throw_exception_again;
               :      }
               :    _Destroy(begin(), end());
               :    _M_deallocate(_M_start, _M_end_of_storage - _M_start);
               :    _M_start = __new_start;
               :    _M_finish = __new_finish;
               :    _M_end_of_storage = __new_start + __len;
               :  }
               :}
               :
               :template <class _Tp, class _Alloc>
               :void vector<_Tp, _Alloc>::_M_fill_insert(iterator __position, size_type __n,
               :                                         const _Tp& __x)
               :{
               :  if (__n != 0) {
               :    if (size_type(_M_end_of_storage - _M_finish) >= __n) {
               :      _Tp __x_copy = __x;
               :      const size_type __elems_after = end() - __position;
               :      iterator __old_finish(_M_finish);
               :      if (__elems_after > __n) {
               :        uninitialized_copy(_M_finish - __n, _M_finish, _M_finish);
               :        _M_finish += __n;
               :        copy_backward(__position, __old_finish - __n, __old_finish);
               :        fill(__position, __position + __n, __x_copy);
               :      }
               :      else {
               :        uninitialized_fill_n(_M_finish, __n - __elems_after, __x_copy);
               :        _M_finish += __n - __elems_after;
               :        uninitialized_copy(__position, __old_finish, _M_finish);
               :        _M_finish += __elems_after;
               :        fill(__position, __old_finish, __x_copy);
               :      }
               :    }
               :    else {
               :      const size_type __old_size = size();
               :      const size_type __len = __old_size + max(__old_size, __n);
               :      iterator __new_start(_M_allocate(__len));
               :      iterator __new_finish(__new_start);
               :      try {
               :        __new_finish = uninitialized_copy(begin(), __position, __new_start);
               :        __new_finish = uninitialized_fill_n(__new_finish, __n, __x);
               :        __new_finish
               :          = uninitialized_copy(__position, end(), __new_finish);
               :      }
               :      catch(...)
               :	{
               :	  _Destroy(__new_start,__new_finish);
               :	  _M_deallocate(__new_start.base(),__len);
               :	  __throw_exception_again;
               :	}
               :      _Destroy(_M_start, _M_finish);
               :      _M_deallocate(_M_start, _M_end_of_storage - _M_start);
               :      _M_start = __new_start.base();
               :      _M_finish = __new_finish.base();
               :      _M_end_of_storage = __new_start.base() + __len;
               :    }
               :  }
               :}
               :
               :template <class _Tp, class _Alloc> template <class _InputIterator>
               :void
               :vector<_Tp, _Alloc>::_M_range_insert(iterator __pos,
               :                                     _InputIterator __first,
               :                                     _InputIterator __last,
               :                                     input_iterator_tag)
               :{
               :  for ( ; __first != __last; ++__first) {
               :    __pos = insert(__pos, *__first);
               :    ++__pos;
               :  }
               :}
               :
               :template <class _Tp, class _Alloc> template <class _ForwardIterator>
               :void
               :vector<_Tp, _Alloc>::_M_range_insert(iterator __position,
               :                                     _ForwardIterator __first,
               :                                     _ForwardIterator __last,
               :                                     forward_iterator_tag)
               :{
               :  if (__first != __last) {
               :    size_type __n = distance(__first, __last);
               :    if (size_type(_M_end_of_storage - _M_finish) >= __n) {
               :      const size_type __elems_after = end() - __position;
               :      iterator __old_finish(_M_finish);
               :      if (__elems_after > __n) {
               :        uninitialized_copy(_M_finish - __n, _M_finish, _M_finish);
               :        _M_finish += __n;
               :        copy_backward(__position, __old_finish - __n, __old_finish);
               :        copy(__first, __last, __position);
               :      }
               :      else {
               :        _ForwardIterator __mid = __first;
               :        advance(__mid, __elems_after);
               :        uninitialized_copy(__mid, __last, _M_finish);
               :        _M_finish += __n - __elems_after;
               :        uninitialized_copy(__position, __old_finish, _M_finish);
               :        _M_finish += __elems_after;
               :        copy(__first, __mid, __position);
               :      }
               :    }
               :    else {
               :      const size_type __old_size = size();
               :      const size_type __len = __old_size + max(__old_size, __n);
               :      iterator __new_start(_M_allocate(__len));
               :      iterator __new_finish(__new_start);
               :      try {
               :        __new_finish = uninitialized_copy(iterator(_M_start),
               :					  __position, __new_start);
               :        __new_finish = uninitialized_copy(__first, __last, __new_finish);
               :        __new_finish
               :          = uninitialized_copy(__position, iterator(_M_finish), __new_finish);
               :      }
               :      catch(...)
               :	{
               :	  _Destroy(__new_start,__new_finish);
               :	  _M_deallocate(__new_start.base(), __len);
               :	  __throw_exception_again;
               :	}
               :      _Destroy(_M_start, _M_finish);
               :      _M_deallocate(_M_start, _M_end_of_storage - _M_start);
               :      _M_start = __new_start.base();
               :      _M_finish = __new_finish.base();
               :      _M_end_of_storage = __new_start.base() + __len;
               :    }
               :  }
               :}
               :
               :} // namespace std
               :
               :#endif /* __GLIBCPP_INTERNAL_VECTOR_H */
               :
               :// Local Variables:
               :// mode:C++
               :// End:
/* 
 * Total samples for file : "/usr/include/c++/3.2/bits/stl_map.h"
 * 
 *  45731 10.1661
 */


               :// Map implementation -*- C++ -*-
               :
               :// Copyright (C) 2001, 2002 Free Software Foundation, Inc.
               ://
               :// This file is part of the GNU ISO C++ Library.  This library is free
               :// software; you can redistribute it and/or modify it under the
               :// terms of the GNU General Public License as published by the
               :// Free Software Foundation; either version 2, or (at your option)
               :// any later version.
               :
               :// This library is distributed in the hope that it will be useful,
               :// but WITHOUT ANY WARRANTY; without even the implied warranty of
               :// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
               :// GNU General Public License for more details.
               :
               :// You should have received a copy of the GNU General Public License along
               :// with this library; see the file COPYING.  If not, write to the Free
               :// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,
               :// USA.
               :
               :// As a special exception, you may use this file as part of a free software
               :// library without restriction.  Specifically, if other files instantiate
               :// templates or use macros or inline functions from this file, or you compile
               :// this file and link it with other files to produce an executable, this
               :// file does not by itself cause the resulting executable to be covered by
               :// the GNU General Public License.  This exception does not however
               :// invalidate any other reasons why the executable file might be covered by
               :// the GNU General Public License.
               :
               :/*
               : *
               : * Copyright (c) 1994
               : * Hewlett-Packard Company
               : *
               : * Permission to use, copy, modify, distribute and sell this software
               : * and its documentation for any purpose is hereby granted without fee,
               : * provided that the above copyright notice appear in all copies and
               : * that both that copyright notice and this permission notice appear
               : * in supporting documentation.  Hewlett-Packard Company makes no
               : * representations about the suitability of this software for any
               : * purpose.  It is provided "as is" without express or implied warranty.
               : *
               : *
               : * Copyright (c) 1996,1997
               : * Silicon Graphics Computer Systems, Inc.
               : *
               : * Permission to use, copy, modify, distribute and sell this software
               : * and its documentation for any purpose is hereby granted without fee,
               : * provided that the above copyright notice appear in all copies and
               : * that both that copyright notice and this permission notice appear
               : * in supporting documentation.  Silicon Graphics makes no
               : * representations about the suitability of this software for any
               : * purpose.  It is provided "as is" without express or implied warranty.
               : */
               :
               :/** @file stl_map.h
               : *  This is an internal header file, included by other library headers.
               : *  You should not attempt to use it directly.
               : */
               :
               :#ifndef _CPP_BITS_STL_MAP_H
               :#define _CPP_BITS_STL_MAP_H 1
               :
               :#include <bits/concept_check.h>
               :
               :namespace std
               :{
               :
               :/**
               : *  @brief A standard container made up of pairs (see std::pair in <utility>)
               : *         which can be retrieved based on a key.
               : *
               : *  This is an associative container.  Values contained within it can be
               : *  quickly retrieved through a key element.  Example:  MyMap["First"] would
               : *  return the data associated with the key "First".
               :*/
               :template <class _Key, class _Tp, class _Compare = less<_Key>,
               :          class _Alloc = allocator<pair<const _Key, _Tp> > >
               :class map
               :{
               :  // concept requirements
               :  __glibcpp_class_requires(_Tp, _SGIAssignableConcept)
               :  __glibcpp_class_requires4(_Compare, bool, _Key, _Key, _BinaryFunctionConcept);
               :
               :public:
               :  // typedefs:
               :  typedef _Key                 key_type;
               :  typedef _Tp                   data_type;
               :  typedef _Tp                   mapped_type;
               :  typedef pair<const _Key, _Tp> value_type;
               :  typedef _Compare             key_compare;
               :
               :  class value_compare
               :    : public binary_function<value_type, value_type, bool> {
               :  friend class map<_Key,_Tp,_Compare,_Alloc>;
               :  protected :
               :    _Compare comp;
               :    value_compare(_Compare __c) : comp(__c) {}
               :  public:
               :    bool operator()(const value_type& __x, const value_type& __y) const {
               :      return comp(__x.first, __y.first);
               :    }
               :  };
               :
               :private:
               :  typedef _Rb_tree<key_type, value_type,
               :                   _Select1st<value_type>, key_compare, _Alloc> _Rep_type;
               :  _Rep_type _M_t;  // red-black tree representing map
               :public:
  5571  1.2385 :  typedef typename _Rep_type::pointer pointer; /* global constructors keyed to _ZN11ocvm_warper7processEv total:   4180  0.9292 */
               :  typedef typename _Rep_type::const_pointer const_pointer;
               :  typedef typename _Rep_type::reference reference;
               :  typedef typename _Rep_type::const_reference const_reference;
               :  typedef typename _Rep_type::iterator iterator;
               :  typedef typename _Rep_type::const_iterator const_iterator;
               :  typedef typename _Rep_type::reverse_iterator reverse_iterator;
               :  typedef typename _Rep_type::const_reverse_iterator const_reverse_iterator;
               :  typedef typename _Rep_type::size_type size_type;
               :  typedef typename _Rep_type::difference_type difference_type;
               :  typedef typename _Rep_type::allocator_type allocator_type;
               :
               :  // allocation/deallocation
               :
               :  map() : _M_t(_Compare(), allocator_type()) {}
               :  explicit map(const _Compare& __comp,
               :               const allocator_type& __a = allocator_type())
               :    : _M_t(__comp, __a) {}
               :
               :  template <class _InputIterator>
               :  map(_InputIterator __first, _InputIterator __last)
               :    : _M_t(_Compare(), allocator_type())
               :    { _M_t.insert_unique(__first, __last); }
               :
               :  template <class _InputIterator>
               :  map(_InputIterator __first, _InputIterator __last, const _Compare& __comp,
               :      const allocator_type& __a = allocator_type())
               :    : _M_t(__comp, __a) { _M_t.insert_unique(__first, __last); }
               :  map(const map<_Key,_Tp,_Compare,_Alloc>& __x) : _M_t(__x._M_t) {}
               :
               :  map<_Key,_Tp,_Compare,_Alloc>&
               :  operator=(const map<_Key, _Tp, _Compare, _Alloc>& __x)
               :  {
               :    _M_t = __x._M_t;
               :    return *this;
               :  }
               :
               :  // accessors:
               :
  7446  1.6553 :  key_compare key_comp() const { return _M_t.key_comp(); } /* std::map<std::string, DCBuffer*, std::less<std::string>, std::allocator<std::pair<std::string const, DCBuffer*> > >::key_comp() const total:   6916  1.5374 */
               :  value_compare value_comp() const { return value_compare(_M_t.key_comp()); }
               :  allocator_type get_allocator() const { return _M_t.get_allocator(); }
               :
               :  /**
               :   *  Returns a read/write iterator that points to the first pair in the map.
               :   *  Iteration is done in ascending order according to the keys.
               :  */
               :  iterator begin() { return _M_t.begin(); }
               :
               :  /**
               :   *  Returns a read-only (constant) iterator that points to the first pair
               :   *  in the map.  Iteration is done in ascending order according to the keys.
               :  */
               :  const_iterator begin() const { return _M_t.begin(); }
               :
               :  /**
               :   *  Returns a read/write iterator that points one past the last pair in the
               :   *  map.  Iteration is done in ascending order according to the keys.
               :  */
               :  iterator end() { return _M_t.end(); }
               :
               :  /**
               :   *  Returns a read-only (constant) iterator that points one past the last
               :   *  pair in the map.  Iteration is done in ascending order according to the
               :   *  keys.
               :  */
               :  const_iterator end() const { return _M_t.end(); }
               :
               :  /**
               :   *  Returns a read/write reverse iterator that points to the last pair in
               :   *  the map.  Iteration is done in descending order according to the keys.
               :  */
               :  reverse_iterator rbegin() { return _M_t.rbegin(); }
               :
               :  /**
               :   *  Returns a read-only (constant) reverse iterator that points to the last
               :   *  pair in the map.  Iteration is done in descending order according to
               :   *  the keys.
               :  */
               :  const_reverse_iterator rbegin() const { return _M_t.rbegin(); }
               :
               :  /**
               :   *  Returns a read/write reverse iterator that points to one before the
               :   *  first pair in the map.  Iteration is done in descending order according
               :   *  to the keys.
               :  */
               :  reverse_iterator rend() { return _M_t.rend(); }
               :
               :  /**
               :   *  Returns a read-only (constant) reverse iterator that points to one
               :   *  before the first pair in the map.  Iteration is done in descending order
               :   *  according to the keys.
               :  */
               :  const_reverse_iterator rend() const { return _M_t.rend(); }
               :
               :  /** Returns true if the map is empty.  (Thus begin() would equal end().)  */
               :  bool empty() const { return _M_t.empty(); }
               :  /** Returns the size of the map.  */
               :  size_type size() const { return _M_t.size(); }
               :  /** Returns the maximum size of the map.  */
               :  size_type max_size() const { return _M_t.max_size(); }
               :
               :  /**
               :   *  @brief Subscript ( [] ) access to map data.
               :   *  @param  k  The key for which data should be retrieved.
               :   * 
               :   *  Allows for easy lookup with the subscript ( [] ) operator.  Returns the
               :   *  data associated with the key specified in subscript.  If the key does
               :   *  not exist a pair with that key is created with a default value, which
               :   *  is then returned.
               :  */
               :  _Tp& operator[](const key_type& __k) {
   779  0.1732 :    iterator __i = lower_bound(__k);
               :    // __i->first is greater than or equivalent to __k.
  4241  0.9428 :    if (__i == end() || key_comp()(__k, (*__i).first))
  7896  1.7553 :      __i = insert(__i, value_type(__k, _Tp()));
  9426  2.0954 :    return (*__i).second; /* std::map<std::string, DCBuffer*, std::less<std::string>, std::allocator<std::pair<std::string const, DCBuffer*> > >::lower_bound(std::string const&) total:   9996  2.2221 */
               :  }
               :
               :  void swap(map<_Key,_Tp,_Compare,_Alloc>& __x) { _M_t.swap(__x._M_t); }
               :
               :  // insert/erase
               :  /**
               :   *  @brief Attempts to insert a std::pair into the map.
               :   *  @param  x  Pair to be inserted (see std::make_pair for easy creation of
               :   *             pairs).
               :   *  @return  A pair of which the first element is an iterator that points
               :   *           to the possibly inserted pair, a second element of type bool
               :   *           to show if the pair was actually inserted.
               :   *
               :   *  This function attempts to insert a (key, value) pair into the map.  A
               :   *  map relies on unique keys and thus a pair is only inserted if its first
               :   *  element (the key) is not already present in the map.
               :  */
               :  pair<iterator,bool> insert(const value_type& __x)
               :    { return _M_t.insert_unique(__x); }
               :
               :  /**
               :   *  @brief Attempts to insert a std::pair into the map.
               :   *  @param  position  An iterator that serves as a hint as to where the
               :   *                    pair should be inserted.
               :   *  @param  x  Pair to be inserted (see std::make_pair for easy creation of
               :   *             pairs).
               :   *  @return  An iterator that points to the inserted (key,value) pair.
               :   *
               :   *  This function is not concerned about whether the insertion took place
               :   *  or not and thus does not return a boolean like the single-argument
               :   *  insert() does.  Note that the first parameter is only a hint and can
               :   *  potentially improve the performance of the insertion process.  A bad
               :   *  hint would cause no gains in efficiency.
               :  */
               :  iterator insert(iterator position, const value_type& __x)
  7688  1.7091 :    { return _M_t.insert_unique(position, __x); } /* std::_Rb_tree<std::string, std::pair<std::string const, DCBuffer*>, std::_Select1st<std::pair<std::string const, DCBuffer*> >, std::less<std::string>, std::allocator<std::pair<std::string const, DCBuffer*> > >::lower_bound(std::string const&) total:  16394  3.6444 */
               :
               :  /**
               :   *  @brief A template function that attemps to insert elements from
               :   *         another range (possibly another map).
               :   *  @param  first  Iterator pointing to the start of the range to be inserted.
               :   *  @param  last  Iterator pointing to the end of the range.
               :  */
               :  template <class _InputIterator>
               :  void insert(_InputIterator __first, _InputIterator __last) {
               :    _M_t.insert_unique(__first, __last);
               :  }
               :
               :  /**
               :   *  @brief Erases an element from a map.
               :   *  @param  position  An iterator pointing to the element to be erased.
               :   *
               :   *  This function erases an element, pointed to by the given iterator, from
               :   *  a map.  Note that this function only erases the element, and that if
               :   *  the element is itself a pointer, the pointed-to memory is not touched
               :   *  in any way.  Managing the pointer is the user's responsibilty.
               :  */
               :  void erase(iterator __position) { _M_t.erase(__position); }
               :
               :  /**
               :   *  @brief Erases an element according to the provided key.
               :   *  @param  x  Key of element to be erased.
               :   *  @return  Doc me! (Number of elements that match key? Only makes sense
               :   *           with multimap)
               :   *
               :   *  This function erases an element, located by the given key, from a map.
               :   *  Note that this function only erases the element, and that if
               :   *  the element is itself a pointer, the pointed-to memory is not touched
               :   *  in any way.  Managing the pointer is the user's responsibilty.
               :  */
               :  size_type erase(const key_type& __x) { return _M_t.erase(__x); }
               :
               :  /**
               :   *  @brief Erases a [first,last) range of elements from a map.
               :   *  @param  first  Iterator pointing to the start of the range to be erased.
               :   *  @param  last  Iterator pointing to the end of the range to be erased.
               :   *
               :   *  This function erases a sequence of elements from a map.
               :   *  Note that this function only erases the element, and that if
               :   *  the element is itself a pointer, the pointed-to memory is not touched
               :   *  in any way.  Managing the pointer is the user's responsibilty.
               :  */
               :  void erase(iterator __first, iterator __last)
               :    { _M_t.erase(__first, __last); }
               :
               :  /** Erases all elements in a map.  Note that this function only erases
               :   *  the elements, and that if the elements themselves are pointers, the
               :   *  pointed-to memory is not touched in any way.  Managing the pointer is
               :   *  the user's responsibilty.
               :  */
               :  void clear() { _M_t.clear(); }
               :
               :  // map operations:
               :
               :  /**
               :   *  @brief Tries to locate an element in a map.
               :   *  @param  x  Key of (key, value) pair to be located.
               :   *  @return  Iterator pointing to sought-after element, or end() if not
               :   *           found.
               :   *
               :   *  This function takes a key and tries to locate the element with which
               :   *  the key matches.  If successful the function returns an iterator
               :   *  pointing to the sought after pair. If unsuccessful it returns the
               :   *  one past the end ( end() ) iterator.
               :  */
               :  iterator find(const key_type& __x) { return _M_t.find(__x); }
               :
               :  /**
               :   *  @brief Tries to locate an element in a map.
               :   *  @param  x  Key of (key, value) pair to be located.
               :   *  @return  Read-only (constant) iterator pointing to sought-after
               :   *           element, or end() if not found.
               :   *
               :   *  This function takes a key and tries to locate the element with which
               :   *  the key matches.  If successful the function returns a constant iterator
               :   *  pointing to the sought after pair. If unsuccessful it returns the
               :   *  one past the end ( end() ) iterator.
               :  */
               :  const_iterator find(const key_type& __x) const { return _M_t.find(__x); }
               :
               :  /**
               :   *  @brief Finds the number of elements with given key.
               :   *  @param  x  Key of (key, value) pairs to be located.
               :   *  @return Number of elements with specified key.
               :   *
               :   *  This function only makes sense for multimaps.
               :  */
               :  size_type count(const key_type& __x) const {
               :    return _M_t.find(__x) == _M_t.end() ? 0 : 1;
               :  }
               :
               :  /**
               :   *  @brief Finds the beginning of a subsequence matching given key.
               :   *  @param  x  Key of (key, value) pair to be located.
               :   *  @return  Iterator pointing to first element matching given key, or
               :   *           end() if not found.
               :   *
               :   *  This function is useful only with std::multimap.  It returns the first
               :   *  element of a subsequence of elements that matches the given key.  If
               :   *  unsuccessful it returns an iterator pointing to the first element that
               :   *  has a greater value than given key or end() if no such element exists.
               :  */
  2684  0.5967 :  iterator lower_bound(const key_type& __x) {return _M_t.lower_bound(__x); }
               :
               :  /**
               :   *  @brief Finds the beginning of a subsequence matching given key.
               :   *  @param  x  Key of (key, value) pair to be located.
               :   *  @return  Read-only (constant) iterator pointing to first element
               :   *           matching given key, or end() if not found.
               :   *
               :   *  This function is useful only with std::multimap.  It returns the first
               :   *  element of a subsequence of elements that matches the given key.  If
               :   *  unsuccessful the iterator will point to the next greatest element or,
               :   *  if no such greater element exists, to end().
               :  */
               :  const_iterator lower_bound(const key_type& __x) const {
               :    return _M_t.lower_bound(__x);
               :  }
               :
               :  /**
               :   *  @brief Finds the end of a subsequence matching given key.
               :   *  @param  x  Key of (key, value) pair to be located.
               :   *  @return Iterator pointing to last element matching given key.
               :   *
               :   *  This function only makes sense with multimaps.
               :  */
               :  iterator upper_bound(const key_type& __x) {return _M_t.upper_bound(__x); }
               :
               :  /**
               :   *  @brief Finds the end of a subsequence matching given key.
               :   *  @param  x  Key of (key, value) pair to be located.
               :   *  @return  Read-only (constant) iterator pointing to last element matching
               :   *           given key.
               :   *
               :   *  This function only makes sense with multimaps.
               :  */
               :  const_iterator upper_bound(const key_type& __x) const {
               :    return _M_t.upper_bound(__x);
               :  }
               :
               :  /**
               :   *  @brief Finds a subsequence matching given key.
               :   *  @param  x  Key of (key, value) pairs to be located.
               :   *  @return  Pair of iterators that possibly points to the subsequence
               :   *           matching given key.
               :   *
               :   *  This function improves on lower_bound() and upper_bound() by giving a more
               :   *  elegant and efficient solution.  It returns a pair of which the first
               :   *  element possibly points to the first element matching the given key
               :   *  and the second element possibly points to the last element matching the
               :   *  given key.  If unsuccessful the first element of the returned pair will
               :   *  contain an iterator pointing to the next greatest element or, if no such
               :   *  greater element exists, to end().
               :   *
               :   *  This function only makes sense for multimaps.
               :  */
               :  pair<iterator,iterator> equal_range(const key_type& __x) {
               :    return _M_t.equal_range(__x);
               :  }
               :
               :  /**
               :   *  @brief Finds a subsequence matching given key.
               :   *  @param  x  Key of (key, value) pairs to be located.
               :   *  @return  Pair of read-only (constant) iterators that possibly points to
               :   *           the subsequence matching given key.
               :   *
               :   *  This function improves on lower_bound() and upper_bound() by giving a more
               :   *  elegant and efficient solution.  It returns a pair of which the first
               :   *  element possibly points to the first element matching the given key
               :   *  and the second element possibly points to the last element matching the
               :   *  given key.  If unsuccessful the first element of the returned pair will
               :   *  contain an iterator pointing to the next greatest element or, if no such
               :   *  a greater element exists, to end().
               :   *
               :   *  This function only makes sense for multimaps.
               :  */
               :  pair<const_iterator,const_iterator> equal_range(const key_type& __x) const {
               :    return _M_t.equal_range(__x);
               :  }
               :
               :  template <class _K1, class _T1, class _C1, class _A1>
               :  friend bool operator== (const map<_K1, _T1, _C1, _A1>&,
               :                          const map<_K1, _T1, _C1, _A1>&);
               :  template <class _K1, class _T1, class _C1, class _A1>
               :  friend bool operator< (const map<_K1, _T1, _C1, _A1>&,
               :                         const map<_K1, _T1, _C1, _A1>&);
               :};
               :
               :template <class _Key, class _Tp, class _Compare, class _Alloc>
               :inline bool operator==(const map<_Key,_Tp,_Compare,_Alloc>& __x,
               :                       const map<_Key,_Tp,_Compare,_Alloc>& __y) {
               :  return __x._M_t == __y._M_t;
               :}
               :
               :template <class _Key, class _Tp, class _Compare, class _Alloc>
               :inline bool operator<(const map<_Key,_Tp,_Compare,_Alloc>& __x,
               :                      const map<_Key,_Tp,_Compare,_Alloc>& __y) {
               :  return __x._M_t < __y._M_t;
               :}
               :
               :template <class _Key, class _Tp, class _Compare, class _Alloc>
               :inline bool operator!=(const map<_Key,_Tp,_Compare,_Alloc>& __x,
               :                       const map<_Key,_Tp,_Compare,_Alloc>& __y) {
               :  return !(__x == __y);
               :}
               :
               :template <class _Key, class _Tp, class _Compare, class _Alloc>
               :inline bool operator>(const map<_Key,_Tp,_Compare,_Alloc>& __x,
               :                      const map<_Key,_Tp,_Compare,_Alloc>& __y) {
               :  return __y < __x;
               :}
               :
               :template <class _Key, class _Tp, class _Compare, class _Alloc>
               :inline bool operator<=(const map<_Key,_Tp,_Compare,_Alloc>& __x,
               :                       const map<_Key,_Tp,_Compare,_Alloc>& __y) {
               :  return !(__y < __x);
               :}
               :
               :template <class _Key, class _Tp, class _Compare, class _Alloc>
               :inline bool operator>=(const map<_Key,_Tp,_Compare,_Alloc>& __x,
               :                       const map<_Key,_Tp,_Compare,_Alloc>& __y) {
               :  return !(__x < __y);
               :}
               :
               :template <class _Key, class _Tp, class _Compare, class _Alloc>
               :inline void swap(map<_Key,_Tp,_Compare,_Alloc>& __x,
               :                 map<_Key,_Tp,_Compare,_Alloc>& __y) {
               :  __x.swap(__y);
               :}
               :
               :} // namespace std
               :
               :#endif /* _CPP_BITS_STL_MAP_H */
               :
               :// Local Variables:
               :// mode:C++
               :// End:
/* 
 * Total samples for file : "/nfs/1/home/rutt/dev/ocvm/ocvm-cvs/src/ocvm.h"
 * 
 *  35882  7.9767
 */


               :#ifndef OCVM_H
               :#define OCVM_H
               :
               :#include <assert.h>
               :#include <ctype.h>
               :#include <errno.h>
               :#include <limits.h>
               :#include <signal.h>
               :#include <string.h>
               :#include <stdarg.h>
               :#include <stdlib.h>
               :#include <stdio.h>
               :
               :#include <algorithm>
               :#include <fstream>
               :#include <iomanip>
               :#include <iostream>
               :#include <iterator>
               :#include <list>
               :#include <map>
               :#include <set>
               :#include <string>
               :#include <queue>
               :#include <vector>
               :
               :#include <arpa/inet.h>
               :#include <fcntl.h>
               :#include <netdb.h>
               :#include <netinet/in.h>
               :#include <pthread.h>
               :#include <pwd.h>
               :#include <semaphore.h>
               :#include <sys/select.h>
               :#include <sys/socket.h>
               :#include <sys/stat.h>
               :#include <sys/time.h>
               :#include <sys/types.h>
               :#include <sys/wait.h>
               :#include <time.h>
               :#include <unistd.h>
               :
               :#include <dcmpi.h>
               :
               :#include "ocvm_macros.h"
               :
               :#include "serializablecontainers.h"
               :
               :// #include "Box.h"
               :// #include "Boxes.h"
               :
               :#define checkrc(rc) if ((rc) != 0) { std::cerr << "ERROR: bad return code at " << __FILE__ << ":" << __LINE__ << std::endl << std::flush; }
               :#define checkrc1(rc) if ((rc) != 1) { std::cerr << "ERROR: bad return code at " << __FILE__ << ":" << __LINE__ << std::endl << std::flush; }
               :
               :typedef int4 ocvm_sum_integer_type;
               :
               :#define OCVM_SPLIT_MODE_WIDE 0
               :#define OCVM_SPLIT_MODE_TALL 1
               :#define OCVM_SPLIT_MODE_BOTH 2
               :#define OCVM_SPLIT_MODE_RR   3
               :
               :#define OCVM_SORT_TYPE_DIAGONAL 0
               :#define OCVM_SORT_TYPE_ROWFIRST 1
               :#define OCVM_SORT_TYPE_COLFIRST 2
               :
               :#define BORROWED_FROM_RIGHT       0
               :#define BORROWED_FROM_BELOW       1
               :#define BORROWED_FROM_LOWER_RIGHT 2
               :#define BORROWED_SENTINEL         3
               :
               :#define tostr(a) (dcmpi_to_string(a))
               :inline int Atoi(const std::string & s)
               :{
               :    return atoi(s.c_str());
               :}
               :
               :inline int8 Atoi8(std::string str)
               :{
               :    return strtoll(str.c_str(), NULL, 10);
               :}
               :
               :inline double Atof(const std::string & s)
               :{
               :    return atof(s.c_str());
               :}
               :
               :inline std::vector<std::string> str_tokenize(
               :    const std::string & str, const std::string & delimiters=" \t\n")
               :{ /* str_tokenize(std::string const&, std::string const&) total:    489  0.1087 */
               :    std::vector<std::string> tokens;
               :    // Skip delimiters at beginning.
               :    std::string::size_type lastPos = str.find_first_not_of(delimiters, 0);
               :    // Find first "non-delimiter".
               :    std::string::size_type pos     = str.find_first_of(delimiters, lastPos);
               :
               :    while (std::string::npos != pos || std::string::npos != lastPos) {
               :        // Found a token, add it to the vector.
               :        tokens.push_back(str.substr(lastPos, pos - lastPos));
               :        // Skip delimiters.  Note the "not_of"
               :        lastPos = str.find_first_not_of(delimiters, pos);
               :        // Find next "non-delimiter"
               :        pos = str.find_first_of(delimiters, lastPos);
               :    }
   332  0.0738 :    return tokens;
    80  0.0178 :}
               :
               :inline void trim_string_front(std::string & s)
               :{
               :    s.erase(0,s.find_first_not_of(" \t\n"));
               :}
               :
               :inline void trim_string_rear(std::string & s)
               :{
               :    s.erase(s.find_last_not_of(" \t\n")+1);
               :}
               :
               :inline void trim_string(std::string & s)
               :{
               :    trim_string_front(s);
               :    trim_string_rear(s);
               :}
               :
               :template <typename T>
               :T ** make2DArray(int nrows, int ncols)
               :{
               :	T ** array2D = (T **)malloc(nrows * sizeof(T *));
               :	array2D[0] = (T *)malloc(nrows * ncols * sizeof(T));
               :	for(int i = 1; i < nrows; i++)
               :		array2D[i] = array2D[0] + i * ncols;
               :    return array2D;
               :}
               :template <typename T>
               :void free2DArray(T ** array)
               :{
               :    free(array[0]);
               :    free(array);
               :}
               :
               :template< class T >
               :class Array3D {
               :    T* array;
               :    int nx;
               :    int ny;
               :    int nz;
               :    int nxy;
               :public:
               :    Array3D(int x_dim, int y_dim, int z_dim) :
               :        nx(x_dim),
               :        ny(y_dim),
               :        nz(z_dim),
               :        nxy(x_dim * y_dim )
               :    {
   458  0.1018 :        array = new T[x_dim * y_dim * z_dim];
               :    }
               :    ~Array3D()
               :    {
               :        delete[] array;
               :    }
               :    T& operator()(int x, int y, int z)
               :    {
   110  0.0245 :        return array[x + y*nx + z*nxy ];
               :    }
               :private:
               :    const Array3D& operator=( const Array3D& A );
               :    Array3D( const Array3D& A );
               :};
               :
               :class timing
               :{
               :    double      timings_min;
               :    double      timings_max;
               :    int         timings_min_idx;
               :    int         timings_max_idx;
               :    double      timings_total;
               :    double      timings_before;
               :    std::string timings_description;
               :    bool        report_each_iter;
               :    int         reps;
               :public:
               :    timing(std::string name, bool report_each_iteration=true) :
               :        timings_description(name), report_each_iter(report_each_iteration)
               :    {
               :        timings_min = 99999999.0;
               :        timings_max = -1;
               :        timings_min_idx = -1;
               :        timings_max_idx = -1;
               :        timings_total = 0.0;
               :        timings_description = name;
               :        if (name.size() > 25) {
               :            std::cout << "name " << name << " is too long" << std::endl;
               :            //assert(0);
               :        }
               :        timings_total = 0.0;
               :        reps = 0;
               :    }
               :    ~timing()
               :    {
               :        printf("%25s max=%2.4f(%3d) min=%2.4f(%3d) avg=%2.4f sum=%2.4f\n",
               :               timings_description.c_str(),
               :               timings_max, timings_max_idx,
               :               timings_min, timings_min_idx,
               :               timings_total / reps,
               :               timings_total);
               :    }
               :    void start()
               :    {
               :        timings_before = dcmpi_doubletime();
               :    }
               :    void stop()
               :    {
               :        double elapsed = dcmpi_doubletime() - timings_before;
               :        if (report_each_iter) {
               :            std::cout << std::setw(25) << timings_description
               :                      << " iter "
               :                      << std::setw(4) << reps << std::setw(0)
               :                      << ": " << elapsed << std::endl;
               :        }
               :        if (elapsed < timings_min) {
               :            timings_min = elapsed;
               :            timings_min_idx = reps;
               :        }
               :        if (elapsed > timings_max) {
               :            timings_max = elapsed;
               :            timings_max_idx = reps;
               :        }
               :        timings_total += elapsed;
               :        reps++;
               :    }
               :};
               :
               :class ImageCoordinate : public DCSerializable
               :{
               :public:
               :    ImageCoordinate(int _x, int _y, int _z)
               :        : x(_x),
               :          y(_y),
               :          z(_z)
   448  0.0996 :    {
               :        ;
               :    }
               :    ImageCoordinate(std::string s) {
               :        init_from_string(s);
               :    }
               :    void init_from_string(const std::string & s)
               :    {
               :        std::vector<std::string> tokens = str_tokenize(s);
               :        assert(tokens.size() == 3);
               :        x = Atoi(tokens[0]);
               :        y = Atoi(tokens[1]);
               :        z = Atoi(tokens[2]);
               :    }
               :    int x;
               :    int y;
               :    int z;
               :    friend std::ostream& operator<<(std::ostream &o, const ImageCoordinate & i);
               :    bool operator==(const ImageCoordinate & i) const
               :    {
               :        return (x==i.x)&&(y==i.y)&&(z==i.z);
               :    }
               :    bool operator<(const ImageCoordinate & i) const
               :    {
               :        CXX_LT_KEYS3(x, y, z);
               :    }
               :    bool operator>(const ImageCoordinate & i) const
               :    {
               :        return !((*this==i)&&(*this<i));
               :    }
               :    bool operator!=(const ImageCoordinate & i) const
               :    {
               :        return !((x==i.x)&&(y==i.y)&&(z==i.z));
               :    }
               :    ImageCoordinate() {}
               :
               :    void serialize(DCBuffer * buf) const
               :    {
               :        buf->Append(tostr(*this));
               :    }
               :    void deSerialize(DCBuffer * buf)
               :    {
               :        std::string s;
               :        buf->Extract(&s);
               :        init_from_string(s);
               :    }
               :};
               :
               :class ImagePart
               :{
               :public:
               :    ImagePart(ImageCoordinate & _coordinate,
               :              std::string _hostname,
               :              std::string _filename,
               :              off_t _byte_offset) :
               :        coordinate(_coordinate), hostname(_hostname), filename(_filename),
   637  0.1416 :        byte_offset(_byte_offset) {} /* ImageCoordinate::ImageCoordinate(int, int, int) total:    542  0.1205 */
               :    ImageCoordinate coordinate;
               :    std::string hostname;
               :    std::string filename;
               :    off_t byte_offset; // where the chunk starts in the file, defaults to 0 if
               :                       // not given
               :    friend std::ostream& operator<<(std::ostream &o, const ImagePart & i);
               :    bool operator<(const ImagePart & i) const
               :    {
               :        return coordinate < i.coordinate;
               :    }
               :    ImagePart(){}
               :};
               :
               :class ImageDescriptor
               :{
               :public:
               :    ImageDescriptor(std::string filename) { init_from_string(filename); }
               :    ImageDescriptor() : coordinate_parts_inited(false),
               :                        coordinate_parts(NULL) {}
               :    ~ImageDescriptor() { delete coordinate_parts; }
               :    void init_from_file(std::string filename);
               :    void init_from_string(std::string s);
               :
               :    std::string type;
               :    std::string extra; // interpreted arbitrarily per image type
               :    off_t pixels_x;
               :    off_t pixels_y;
               :    off_t pixels_z;
               :    int chunks_x;
               :    int chunks_y;
               :    int chunks_z;
               :    std::vector<int8> chunk_dimensions_x;
               :    std::vector<int8> chunk_dimensions_y;
               :    std::vector<int8> chunk_offsets_x;
               :    std::vector<int8> chunk_offsets_y;
               :    int8 max_dimension_x;
               :    int8 max_dimension_y;
               :    std::string timestamp;
               :    std::vector<ImagePart> parts;
               :
               :    uint get_num_parts() const {
               :        return this->parts.size();
               :    }
               :    ImagePart get_part(const ImageCoordinate & coordinate)
               :    { /* ImageDescriptor::get_part(ImageCoordinate const&) total:    882  0.1961 */
               :        if (!coordinate_parts_inited) {
               :            delete coordinate_parts;
               :            coordinate_parts = new Array3D<ImagePart*>(chunks_x,
               :                                                       chunks_y,
               :                                                       chunks_z);
    71  0.0158 :            for (uint u = 0; u < parts.size(); u++) {
               :                ImageCoordinate & ic = parts[u].coordinate;
   130  0.0289 :                (*coordinate_parts)(ic.x, ic.y, ic.z) = &parts[u];
               :            }
    96  0.0213 :            coordinate_parts_inited = true;
               :        }
  2000  0.4446 :        return *((*coordinate_parts)(coordinate.x, coordinate.y, coordinate.z)); /* ImagePart::ImagePart(ImagePart const&) total:   1415  0.3146 */
               :    }
               :    void get_pixel_count_in_chunk(const ImageCoordinate & coordinate,
               :                                  off_t & pixels_this_chunk_x,
               :                                  off_t & pixels_this_chunk_y) {
               :        pixels_this_chunk_x = this->chunk_dimensions_x[coordinate.x];
               :        pixels_this_chunk_y = this->chunk_dimensions_y[coordinate.y];
               :    }
               :    void get_coordinate_pixel_range(const ImageCoordinate & coordinate,
               :                                    off_t & x_low,
               :                                    off_t & x_high,
               :                                    off_t & y_low,
               :                                    off_t & y_high) { /* ImageDescriptor::get_coordinate_pixel_range(ImageCoordinate const&, long long&, long long&, long long&, long long&) total:    762  0.1694 */
               :        x_low = chunk_offsets_x[coordinate.x];
               :        x_high = x_low + chunk_dimensions_x[coordinate.x] - 1;
               :        y_low = chunk_offsets_y[coordinate.y];
   623  0.1385 :        y_high = y_low + chunk_dimensions_y[coordinate.y] - 1;
   114  0.0253 :    }
               :    void pixel_to_chunk(off_t pixel_x,
               :                        off_t pixel_y,
               :                        int & chunk_x,
  1462  0.3250 :                        int & chunk_y) { /* ImageDescriptor::pixel_to_chunk(long long, long long, int&, int&) total:  25582  5.6870 */
  2885  0.6413 :        for (chunk_x = 0; chunk_x < this->chunks_x-1; chunk_x++) {
  8529  1.8960 :            if (pixel_x >= this->chunk_offsets_x[chunk_x] &&
               :                pixel_x < this->chunk_offsets_x[chunk_x+1]) {
   138  0.0307 :                break;
               :            }
               :        }
  2904  0.6456 :        for (chunk_y = 0; chunk_y < this->chunks_y -1; chunk_y++) {
  9147  2.0334 :            if (pixel_y >= this->chunk_offsets_y[chunk_y] &&
               :                pixel_y < this->chunk_offsets_y[chunk_y+1]) {
               :                break;
               :            }
               :        }
   239  0.0531 :        assert(chunk_x < chunks_x);
   278  0.0618 :        assert(chunk_y < chunks_y);
               :    }
               :    void pixel_within_chunk(off_t pixel_x,
               :                            off_t pixel_y,
               :                            off_t & pixel_chunk_x,
               :                            off_t & pixel_chunk_y) {
   752  0.1672 :        pixel_chunk_x = 0; pixel_chunk_y = 0;
   524  0.1165 :        for (int chunk_x = 0; chunk_x < this->chunks_x-1; chunk_x++) {
  1305  0.2901 :            if (pixel_x >= this->chunk_offsets_x[chunk_x] &&
               :                pixel_x < this->chunk_offsets_x[chunk_x+1]) {
   377  0.0838 :                pixel_chunk_x = pixel_x - this->chunk_offsets_x[chunk_x];
               :                break;
               :            }
   269  0.0598 :            pixel_chunk_x = pixel_x - this->chunk_offsets_x[this->chunks_x-1];
               :        }
   275  0.0611 :        for (int chunk_y = 0; chunk_y < this->chunks_y -1; chunk_y++) {
  1312  0.2917 :            if (pixel_y >= this->chunk_offsets_y[chunk_y] &&
               :                pixel_y < this->chunk_offsets_y[chunk_y+1]) {
   344  0.0765 :                pixel_chunk_y = pixel_y - this->chunk_offsets_y[chunk_y];
     3 6.7e-04 :                break;
               :            }
    40  0.0089 :            pixel_chunk_y = pixel_y - this->chunk_offsets_y[this->chunks_y-1];
               :        }
               :    }
               :    bool bottommost_pixel_next_chunk_up(
               :        int8 x, int8 y,
               :        int8 & x_out, int8 & y_out)
               :    {
               :        int chunk_x;
               :        int chunk_y;
               :        pixel_to_chunk(x, y, chunk_x, chunk_y);
               :        chunk_y--;
               :        if (chunk_y == -1) {
               :            return false;
               :        }
               :        x_out = x;
               :        y_out = chunk_offsets_y[chunk_y] + chunk_dimensions_y[chunk_y] - 1;
               :        return true;
               :    }
               :    bool rightmost_pixel_next_chunk_to_the_left(
               :        int8 x, int8 y,
               :        int8 & x_out,
               :        int8 & y_out)
               :    {
               :        int chunk_x;
               :        int chunk_y;
               :        pixel_to_chunk(x, y, chunk_x, chunk_y);
               :        chunk_x--;
               :        if (chunk_x == -1) {
               :            return false;
               :        }
               :        x_out = chunk_offsets_x[chunk_x] + chunk_dimensions_x[chunk_x] - 1;
               :        y_out = y;
               :        return true;
               :    }
               :    bool right_lower_corner_pixel_next_chunk_to_the_upper_left(
               :        int8 x, int8 y,
               :        int8 & x_out,
               :        int8 & y_out)
               :    {
               :        int chunk_x;
               :        int chunk_y;
               :        pixel_to_chunk(x, y, chunk_x, chunk_y);
               :        chunk_x--;
               :        chunk_y--;
               :        if (chunk_x == -1 || chunk_y == -1) {
               :            return false;
               :        }
               :        x_out = chunk_offsets_x[chunk_x] + chunk_dimensions_x[chunk_x] - 1;
               :        y_out = chunk_offsets_y[chunk_y] + chunk_dimensions_y[chunk_y] - 1;
               :        return true;
               :    }
               :    std::vector<std::string> get_hosts() const {
               :        std::set<std::string> hosts_set;
               :        std::vector<std::string> hosts_vec;
               :        for (uint u = 0; u < get_num_parts(); u++) {
               :            const ImagePart & part = parts[u];
               :            hosts_set.insert(part.hostname);
               :        }
               :        std::set<std::string>::iterator it;
               :        for (it = hosts_set.begin();
               :             it != hosts_set.end();
               :             it++) {
               :            hosts_vec.push_back(*it);
               :        }
               :        return hosts_vec;
               :    }
               :    friend std::ostream& operator<<(std::ostream &o, const ImageDescriptor& i);
               :private:
               :    Array3D<ImagePart*> * coordinate_parts;
               :    bool coordinate_parts_inited;
               :};
               :
               :class PixelReq : public DCSerializable
               :{
               :public:
               :    PixelReq() : x(-1), y(-1) {}
               :    PixelReq(int8 _x, int8 _y) : x(_x), y(_y) {}
               :    int8 x;
               :    int8 y;
               :    void serialize(DCBuffer * buf) const { 
               :        buf->pack("ll", x, y);
               :    }
               :    void deSerialize(DCBuffer * buf) {
               :        buf->unpack("ll", &x, &y);
               :    }
               :    bool operator<(const PixelReq & i) const
               :    {
               :        CXX_LT_KEYS2(x, y);
               :    }
               :};
               :inline std::ostream& operator<<(std::ostream &o, const PixelReq & i)
               :{
               :    return o << i.x << "," << i.y;
               :}
               :
               :ImageDescriptor conjure_tessellation_descriptor(
               :    ImageDescriptor & original_image_descriptor,
               :    int new_parts_per_chunk,
               :    int8 memory_per_host,
               :    int user_tessellation_x,
               :    int user_tessellation_y,
               :    std::vector<int8> & divided_original_chunk_dims_x,
               :    std::vector<int8> & divided_original_chunk_dims_y,
               :    std::vector<int8> & sourcepixels_x,
               :    std::vector<int8> & sourcepixels_y,
               :    std::vector<int8> & leading_skips_x,
               :    std::vector<int8> & leading_skips_y);
               :
               :inline bool fileExists(const std::string & filename)
               :{
               :    /* stat returns 0 if the file exists */
               :    struct stat stat_out;
               :    return (stat(filename.c_str(), &stat_out) == 0);
               :}
               :
               :inline off_t ocvm_file_size(std::string filename)
               :{
               :    struct stat stat_out;
               :    if (stat(filename.c_str(), &stat_out) != 0) {
               :        std::cerr << "ERROR: file " << filename
               :                  << " does not exist"
               :                  << " at " << __FILE__ << ":" << __LINE__
               :                  << std::endl << std::flush;
               :        exit(1);
               :    }
               :    off_t out = stat_out.st_size;
               :    return out;
               :}
               :
               :inline std::string file_to_string(std::string filename)
               :{
               :    std::string out;
               :    off_t fs = ocvm_file_size(filename);
               :    char * buf = new char[fs+1];
               :    buf[fs] = 0;
               :    FILE * f = fopen(filename.c_str(), "r");
               :    if (!f) {
               :        std::cerr << "ERROR: opening file " << filename
               :                  << " at " << __FILE__ << ":" << __LINE__
               :                  << std::endl << std::flush;
               :        exit(1);
               :    }
               :    if (fread(buf, fs, 1, f) < 1) {
               :        std::cerr << "ERROR: in fread()"
               :                  << " at " << __FILE__ << ":" << __LINE__
               :                  << std::endl << std::flush;
               :        exit(1);
               :    }
               :    out = buf;
               :    fclose(f);
               :    delete[] buf;
               :    return out;
               :}
               :
               :inline int mkdirRecursive(const std::string & dir)
               :{
               :    std::string dirStr = dir;
               :    int rc = 0;
               :    std::vector<std::string> components = str_tokenize(dirStr);
               :    dirStr = "";
               :    if (dir[0] == '/') {
               :        dirStr += "/";
               :    }
               :    
               :    for (unsigned loop = 0, len = components.size(); loop < len; loop++) {
               :        dirStr += components[loop];
               :        if (!fileExists(dirStr)) {
               :            if (mkdir(dirStr.c_str(), 0777) == -1) {
               :                rc = errno;
               :                goto Exit;
               :            }
               :        }
               :        dirStr += "/";
               :    }
               :
               :Exit: 
               :    return rc;
               :}
               :
               :inline std::map<std::string, std::string> file_to_pairs(std::string filename)
               :{
               :    std::map<std::string, std::string> out;
               :    char buf[1024];
               :    FILE * f = fopen(filename.c_str(), "r");
               :    if (!f) {
               :        std::cerr << "ERROR: opening file " << filename
               :                  << " at " << __FILE__ << ":" << __LINE__
               :                  << std::endl << std::flush;
               :        exit(1);
               :    }
               :    while (fgets(buf, sizeof(buf), f) != NULL) {
               :        buf[strlen(buf)-1] = 0;
               :        if (buf[0] != '#') {
               :            std::vector<std::string> toks = str_tokenize(buf, " ");
               :            if (toks.size() != 2) {
               :                std::cerr << "ERROR: parsing line '" << buf
               :                          << "' at " << __FILE__ << ":" << __LINE__
               :                          << std::endl << std::flush;
               :                exit(1);
               :            }
               :            out[toks[0]] = toks[1];
               :        }
               :    }
               :    fclose(f);
               :    return out;
               :}
               :
               :class HostScratch
               :{
               :public:
               :    std::vector<std::vector<std::string> > components;
               :    HostScratch(const std::string & filename)
               :    {
               :        FILE * f;
               :        if ((f = fopen( filename.c_str(), "r")) == NULL) {
               :            std::cerr << "ERROR: opening file"
               :                      << " at " << __FILE__ << ":" << __LINE__
               :                      << std::endl << std::flush;
               :            exit(1);
               :        }
               :        char buf[1024];
               :        while (fgets(buf, sizeof(buf), f) != NULL) {
               :            buf[strlen(buf)-1] = 0;
               :            if (strlen(buf) == 0) {
               :                continue;
               :            }
               :            if (buf [0] != '#') {
               :                std::vector< std::string> tokens =
               :                    dcmpi_string_tokenize(buf, " ");
               :                if (tokens.size() == 2) {
               :                    tokens.push_back("1");
               :                }
               :                if (tokens.size() != 3) {
               :                    std::cerr << "ERROR:  invalid line " << buf
               :                              << " at " << __FILE__ << ":" << __LINE__
               :                              << std::endl << std::flush;
               :                    exit(1);
               :                }
               :                dcmpi_string_trim(tokens[0]);
               :                dcmpi_string_trim(tokens[1]);
               :                dcmpi_string_trim(tokens[2]);
               :                std::vector<std::string > component;
               :                component.push_back(tokens[0]);
               :                component.push_back(tokens[1]);
               :                component.push_back(tokens[2]);
               :                components.push_back(component);
               :            }
               :        }
               :    }
               :};
               :
               :class ByteArray : public DCSerializable
               :{
               :    bool _alias_memory;
               :    uint1 * array;
               :    int4 _xdim, _ydim;
               :public:
               :    ByteArray() : _alias_memory(false), array(NULL) {} // for deSerializing
               :    ByteArray(uint1 * row_major_array, int xdim, int ydim,
               :              bool alias_memory=false) :
               :        _alias_memory(alias_memory),
               :        array(row_major_array),
               :        _xdim(xdim), _ydim(ydim)
               :    {
               :        if (!_alias_memory) {
               :            array = new uint1[xdim*ydim];
               :            memcpy(array, row_major_array, xdim*ydim);
               :        }
               :    }
               :    ~ByteArray()
               :    {
               :        if (!_alias_memory) {
               :            delete[] array;
               :        }
               :    }
               :    void serialize(DCBuffer * buf) const
               :    {
               :        buf->pack("ii", _xdim, _ydim);
               :        buf->Append(array, _xdim * _ydim);
               :    }
               :    void deSerialize(DCBuffer * buf)
               :    {
               :        buf->unpack("ii", &_xdim, &_ydim);
               :        _alias_memory = false;
               :        array = new uint1[_xdim*_ydim];
               :    }
               :};
               :
               :int ocvmOpenClientSocket(const char * serverHost, uint2 port);
               :int ocvmOpenListenSocket(uint2 port);
               :int ocvmOpenListenSocket(uint2 * port);
               :int ocvm_read_all(int fd, void *buf, size_t count, int * hitEOF = NULL);
               :int ocvm_write_all(int fd, const void * buf, size_t count);
               :int ocvm_write_message(int fd, std::string & message);
               :// returns error code, if error code is 0, str gets stripped line (no \n)
               :inline int ocvm_socket_read_line(int s, std::string & str)
               :{
               :    char c;
               :    str = "";
               :    while (1) {
               :        if (ocvm_read_all(s, &c, 1) != 0) {
               :            return -1;
               :        }
               :        if (c=='\n') {
               :            break;
               :        }
               :        str.push_back(c);
               :    }
               :    return 0;
               :}
               :inline std::string ocvmGetPeerOfSocket(int sd)
               :{
               :    static pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;
               :    if (pthread_mutex_lock(&mutex) != 0) {
               :        fprintf(stderr, "ERROR: calling pthread_mutex_lock()\n");
               :        exit(1);
               :    }
               :    struct sockaddr_in tmpAddr;
               :    socklen_t tmpLen = sizeof(tmpAddr);
               :    getpeername(sd, (struct sockaddr*)&tmpAddr, &tmpLen);
               :    std::string out = inet_ntoa(tmpAddr.sin_addr);
               :    if (pthread_mutex_unlock(&mutex) != 0) {
               :        fprintf(stderr, "ERROR: calling pthread_mutex_unlock()\n");
               :        exit(1);
               :    }
               :    return out;
               :}
               :
               :inline int ocvm_fill_file(const std::string & filename,
               :                          int8 file_size,
               :                          unsigned char character)
               :{
               :    FILE * f;
               :    if ((f = fopen(filename.c_str(), "w")) == NULL) {
               :        std::cerr << "ERROR: opening file"
               :                  << " at " << __FILE__ << ":" << __LINE__
               :                  << std::endl << std::flush;
               :        return -1;
               :    }
               :    int8 written = 0;
               :    int8 amt;
               :    const int bufsz = MB_1;
               :    unsigned char * buf = new unsigned char[bufsz];
               :    memset(buf, character, bufsz);
               :    while (written < file_size) {
               :        amt = std::min(file_size - written, (int8)bufsz);
               :        if (fwrite(buf, amt, 1, f) < 1) {
               :            std::cerr << "ERROR: calling fwrite()"
               :                      << " at " << __FILE__ << ":" << __LINE__
               :                      << std::endl << std::flush;
               :            return -1;
               :        }
               :        written += amt;
               :    }
               :    delete[] buf;
               :    if (fclose(f) != 0) {
               :        std::cerr << "ERROR: calling fclose()"
               :                  << " at " << __FILE__ << ":" << __LINE__
               :                  << std::endl << std::flush;
               :        return -1;
               :    }
               :    return 0;
               :}
               :
               :inline int ocvm_fill_file(FILE * f,
               :                          int8 file_size,
               :                          unsigned char character)
               :{
               :    int8 written = 0;
               :    int8 amt;
               :    const int bufsz = MB_1;
               :    unsigned char * buf = new unsigned char[bufsz];
               :    memset(buf, character, bufsz);
               :    while (written < file_size) {
               :        amt = std::min(file_size - written, (int8)bufsz);
               :        if (fwrite(buf, amt, 1, f) < 1) {
               :            std::cerr << "ERROR: calling fwrite()"
               :                      << " at " << __FILE__ << ":" << __LINE__
               :                      << std::endl << std::flush;
               :            return -1;
               :        }
               :        written += amt;
               :    }
               :    delete[] buf;
               :    return 0;
               :}
               :
               :void ocvm_view_bgrp(unsigned char * buffer,
               :                    int width,
               :                    int height);
               :
               :int produce_prefix_sum(
               :    std::string & original_image_descriptor_text,
               :    unsigned char user_threshold_b,
               :    unsigned char user_threshold_g,
               :    unsigned char user_threshold_r,
               :    int           user_tessellation_x,
               :    int           user_tessellation_y,
               :    int8          memory_per_host,
               :    std::string   prefix_sum_descriptor_filename,
               :    std::string & prefix_sum_descriptor_text);
               :
               :int answer_ps_queries(
               :    DCFilter * console_filter,
               :    const std::vector<std::string> & hosts,
               :    ImageDescriptor original_image_descriptor,
               :    ImageDescriptor prefix_sum_descriptor,
               :    std::vector<PixelReq> query_points,
               :    int zslice,
               :    std::vector<std::vector<int8> > & results);
               :
               :class Rectangle {
               :public:
               :    int top_left_x;
               :    int top_left_y;
               :    int bottom_right_x;
               :    int bottom_right_y;
               :public:
               :    Rectangle(int x1, int y1, int x2, int y2) {
               :        top_left_x = x1;
               :        top_left_y = y1;
               :        bottom_right_x = x2;
               :        bottom_right_y = y2;
               :    }
               :    ~Rectangle() {}
               :};
               :
               :#define MEDIATOR_GOODBYE_FROM_CLIENT                0
               :#define MEDIATOR_GOODBYE_FROM_ANOTHER_MEDIATOR      1
               :#define MEDIATOR_READ_REQUEST                       2
               :#define MEDIATOR_READ_RESPONSE                      3
               :#define MEDIATOR_WRITE_REQUEST                      4
               :#define MEDIATOR_WRITE_RESPONSE                     5
               :#define MEDIATOR_PREFETCH_REQUEST                   6
               :#define MEDIATOR_RENAME_THIS_LATER                  7
               :
               :class MediatorInfo
               :{
               :public:
               :    std::vector<DCFilterInstance*> mediators;
               :    std::vector<std::vector<DCFilterInstance*> > readers;
               :};
               :
               :MediatorInfo mediator_setup(
               :    DCLayout & layout,
               :    int nreaders_per_host,
               :    std::vector<std::string> hosts,
               :    int cache_size = 0);
               :
               :void mediator_add_client(
               :    DCLayout & layout,
               :    MediatorInfo & mediator_info,
               :    std::vector<DCFilterInstance *> clients);
               :
               :inline std::string get_dim_output_timestamp()
               :{
               :    time_t    the_time;
               :    struct tm the_time_tm;
               :    the_time = time(NULL);
               :    localtime_r(&the_time, &the_time_tm);
               :    char datestr[64];
               :    strftime(datestr, sizeof(datestr), "%Y%m%d%H%M%S", &the_time_tm);
               :    return tostr(datestr);
               :}
               :
               :class ControlPtCorrespondence {
               :public:
               :    float origin_x;
               :    float origin_y;
               :    float endpoint_x;
               :    float endpoint_y;
               :    uint weight;
               :public:
               :    ControlPtCorrespondence() {}
               :    ControlPtCorrespondence(float x1, float y1, float x2, float y2, uint w) {
               :        origin_x = x1;
               :        origin_y = y1;
               :        endpoint_x = x2;
               :        endpoint_y = y2;
               :        weight = w;
               :    }
               :    ~ControlPtCorrespondence() {}
               :};
               :
               :class JibberXMLDescriptor
               :{
               :public:
               :    uint delta;
               :    uint num_control_points;
               :    std::vector< ControlPtCorrespondence*> correspondences;
               :public:
               :    JibberXMLDescriptor(std::string filename) { init_from_string(filename); }
               :    JibberXMLDescriptor() {}
               :    ~JibberXMLDescriptor() {}
               :    void init_from_file(std::string filename);
               :    void init_from_string(std::string s);
               :    std::string extract_value_from_tag(std::string, std::string);
               :};
               :#endif /* #ifndef OCVM_H */
/* 
 * Total samples for file : "/usr/include/c++/3.2/bits/stl_tree.h"
 * 
 *  32641  7.2562
 */


               :// RB tree implementation -*- C++ -*-
               :
               :// Copyright (C) 2001, 2002 Free Software Foundation, Inc.
               ://
               :// This file is part of the GNU ISO C++ Library.  This library is free
               :// software; you can redistribute it and/or modify it under the
               :// terms of the GNU General Public License as published by the
               :// Free Software Foundation; either version 2, or (at your option)
               :// any later version.
               :
               :// This library is distributed in the hope that it will be useful,
               :// but WITHOUT ANY WARRANTY; without even the implied warranty of
               :// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
               :// GNU General Public License for more details.
               :
               :// You should have received a copy of the GNU General Public License along
               :// with this library; see the file COPYING.  If not, write to the Free
               :// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,
               :// USA.
               :
               :// As a special exception, you may use this file as part of a free software
               :// library without restriction.  Specifically, if other files instantiate
               :// templates or use macros or inline functions from this file, or you compile
               :// this file and link it with other files to produce an executable, this
               :// file does not by itself cause the resulting executable to be covered by
               :// the GNU General Public License.  This exception does not however
               :// invalidate any other reasons why the executable file might be covered by
               :// the GNU General Public License.
               :
               :/*
               : *
               : * Copyright (c) 1996,1997
               : * Silicon Graphics Computer Systems, Inc.
               : *
               : * Permission to use, copy, modify, distribute and sell this software
               : * and its documentation for any purpose is hereby granted without fee,
               : * provided that the above copyright notice appear in all copies and
               : * that both that copyright notice and this permission notice appear
               : * in supporting documentation.  Silicon Graphics makes no
               : * representations about the suitability of this software for any
               : * purpose.  It is provided "as is" without express or implied warranty.
               : *
               : *
               : * Copyright (c) 1994
               : * Hewlett-Packard Company
               : *
               : * Permission to use, copy, modify, distribute and sell this software
               : * and its documentation for any purpose is hereby granted without fee,
               : * provided that the above copyright notice appear in all copies and
               : * that both that copyright notice and this permission notice appear
               : * in supporting documentation.  Hewlett-Packard Company makes no
               : * representations about the suitability of this software for any
               : * purpose.  It is provided "as is" without express or implied warranty.
               : *
               : *
               : */
               :
               :/** @file stl_tree.h
               : *  This is an internal header file, included by other library headers.
               : *  You should not attempt to use it directly.
               : */
               :
               :#ifndef __GLIBCPP_INTERNAL_TREE_H
               :#define __GLIBCPP_INTERNAL_TREE_H
               :
               :/*
               :
               :Red-black tree class, designed for use in implementing STL
               :associative containers (set, multiset, map, and multimap). The
               :insertion and deletion algorithms are based on those in Cormen,
               :Leiserson, and Rivest, Introduction to Algorithms (MIT Press, 1990),
               :except that
               :
               :(1) the header cell is maintained with links not only to the root
               :but also to the leftmost node of the tree, to enable constant time
               :begin(), and to the rightmost node of the tree, to enable linear time
               :performance when used with the generic set algorithms (set_union,
               :etc.);
               :
               :(2) when a node being deleted has two children its successor node is
               :relinked into its place, rather than copied, so that the only
               :iterators invalidated are those referring to the deleted node.
               :
               :*/
               :
               :#include <bits/stl_algobase.h>
               :#include <bits/stl_alloc.h>
               :#include <bits/stl_construct.h>
               :#include <bits/stl_function.h>
               :
               :namespace std
               :{ 
               :  enum _Rb_tree_color { _M_red = false, _M_black = true };
               :
               :  struct _Rb_tree_node_base
               :  {
               :    typedef _Rb_tree_node_base* _Base_ptr;
               :    
               :    _Rb_tree_color 	_M_color; 
               :    _Base_ptr 		_M_parent;
               :    _Base_ptr 		_M_left;
               :    _Base_ptr 		_M_right;
               :    
               :    static _Base_ptr 
               :    _S_minimum(_Base_ptr __x)
               :    {
               :      while (__x->_M_left != 0) __x = __x->_M_left;
               :      return __x;
               :    }
               :
               :    static _Base_ptr 
               :    _S_maximum(_Base_ptr __x)
               :    {
               :      while (__x->_M_right != 0) __x = __x->_M_right;
               :      return __x;
               :    }
               :  };
               :
               :  template<typename _Val>
               :    struct _Rb_tree_node : public _Rb_tree_node_base
               :    {
               :      typedef _Rb_tree_node<_Val>* _Link_type;
               :      _Val _M_value_field;
               :    };
               :  
               :  struct _Rb_tree_base_iterator
               :  {
               :    typedef _Rb_tree_node_base::_Base_ptr 	_Base_ptr;
               :    typedef bidirectional_iterator_tag 		iterator_category;
               :    typedef ptrdiff_t 				difference_type;
               :
               :    _Base_ptr _M_node;
               :
               :    void 
               :    _M_increment()
               :    {
               :      if (_M_node->_M_right != 0) 
               :	{
               :	  _M_node = _M_node->_M_right;
               :	  while (_M_node->_M_left != 0)
               :	    _M_node = _M_node->_M_left;
               :	}
               :      else 
               :	{
               :	  _Base_ptr __y = _M_node->_M_parent;
               :	  while (_M_node == __y->_M_right) 
               :	    {
               :	      _M_node = __y;
               :	      __y = __y->_M_parent;
               :	    }
               :	  if (_M_node->_M_right != __y)
               :	    _M_node = __y;
               :	}
               :    }
               :
               :    void 
               :    _M_decrement()
               :    {
               :      if (_M_node->_M_color == _M_red 
               :	  && _M_node->_M_parent->_M_parent == _M_node)
               :	_M_node = _M_node->_M_right;
               :      else if (_M_node->_M_left != 0) 
               :	{
               :	  _Base_ptr __y = _M_node->_M_left;
               :	  while (__y->_M_right != 0)
               :	    __y = __y->_M_right;
               :	  _M_node = __y;
               :	}
               :      else 
               :	{
               :	  _Base_ptr __y = _M_node->_M_parent;
               :	  while (_M_node == __y->_M_left) 
               :	    {
               :	      _M_node = __y;
               :	      __y = __y->_M_parent;
               :	    }
               :	  _M_node = __y;
               :	}
               :    }
               :  };
               :
               :  template<typename _Val, typename _Ref, typename _Ptr>
               :    struct _Rb_tree_iterator : public _Rb_tree_base_iterator
               :    {
               :      typedef _Val value_type;
               :      typedef _Ref reference;
               :      typedef _Ptr pointer;
               :      typedef _Rb_tree_iterator<_Val, _Val&, _Val*> iterator;
               :      typedef _Rb_tree_iterator<_Val, const _Val&, const _Val*> 
               :      const_iterator;
               :      typedef _Rb_tree_iterator<_Val, _Ref, _Ptr> _Self;
               :      typedef _Rb_tree_node<_Val>* _Link_type;
               :      
               :      _Rb_tree_iterator() {}
               :      _Rb_tree_iterator(_Link_type __x) { _M_node = __x; }
  1652  0.3672 :      _Rb_tree_iterator(const iterator& __it) { _M_node = __it._M_node; } /* std::_Rb_tree_iterator<std::pair<std::string const, DCBuffer*>, std::pair<std::string const, DCBuffer*>&, std::pair<std::string const, DCBuffer*>*>::_Rb_tree_iterator(std::_Rb_tree_iterator<std::pair<std::string const, DCBuffer*>, std::pair<std::string const, DCBuffer*>&, std::pair<std::string const, DCBuffer*>*> const&) total:   1652  0.3672 */
               :
               :      reference 
  1531  0.3403 :      operator*() const { return _Link_type(_M_node)->_M_value_field; } /* std::_Rb_tree_iterator<std::pair<std::string const, DCBuffer*>, std::pair<std::string const, DCBuffer*>&, std::pair<std::string const, DCBuffer*>*>::operator*() const total:   1643  0.3652 */
               :
               :      pointer 
               :      operator->() const { return &(operator*()); }
               :
               :      _Self& 
               :      operator++() 
               :      { 
               :	_M_increment(); 
               :	return *this; 
               :      }
               :
               :      _Self 
               :      operator++(int) 
               :      {
               :	_Self __tmp = *this;
               :	_M_increment();
               :	return __tmp;
               :      }
               :    
               :      _Self& 
               :      operator--() { _M_decrement(); return *this; }
               :
               :      _Self 
               :      operator--(int) 
               :      {
               :	_Self __tmp = *this;
               :	_M_decrement();
               :	return __tmp;
               :      }
               :  };
               :
               :  template<typename _Val, typename _Ref, typename _Ptr>
               :    inline bool 
               :    operator==(const _Rb_tree_iterator<_Val, _Ref, _Ptr>& __x,
               :	       const _Rb_tree_iterator<_Val, _Ref, _Ptr>& __y) 
               :    { return __x._M_node == __y._M_node; }
               :
               :  template<typename _Val>
               :    inline bool 
               :    operator==(const _Rb_tree_iterator<_Val, const _Val&, const _Val*>& __x,
               :	       const _Rb_tree_iterator<_Val, _Val&, _Val*>& __y) 
               :    { return __x._M_node == __y._M_node; }
               :
               :  template<typename _Val>
               :    inline bool 
               :    operator==(const _Rb_tree_iterator<_Val, _Val&, _Val*>& __x,
               :	       const _Rb_tree_iterator<_Val, const _Val&, const _Val*>& __y) 
               :    { return __x._M_node == __y._M_node; }
               :
               :  template<typename _Val, typename _Ref, typename _Ptr>
               :    inline bool 
               :    operator!=(const _Rb_tree_iterator<_Val, _Ref, _Ptr>& __x,
               :	       const _Rb_tree_iterator<_Val, _Ref, _Ptr>& __y) 
               :    { return __x._M_node != __y._M_node; }
               :
               :  template<typename _Val>
               :    inline bool 
               :    operator!=(const _Rb_tree_iterator<_Val, const _Val&, const _Val*>& __x,
               :	       const _Rb_tree_iterator<_Val, _Val&, _Val*>& __y) 
               :    { return __x._M_node != __y._M_node; }
               :
               :  template<typename _Val>
               :    inline bool 
               :    operator!=(const _Rb_tree_iterator<_Val, _Val&, _Val*>& __x,
               :	       const _Rb_tree_iterator<_Val, const _Val&, const _Val*>& __y) 
               :    { return __x._M_node != __y._M_node; }
               :
               :  inline void 
               :  _Rb_tree_rotate_left(_Rb_tree_node_base* __x, _Rb_tree_node_base*& __root)
               :  {
               :    _Rb_tree_node_base* __y = __x->_M_right;
               :    __x->_M_right = __y->_M_left;
               :    if (__y->_M_left !=0)
               :      __y->_M_left->_M_parent = __x;
               :    __y->_M_parent = __x->_M_parent;
               :    
               :    if (__x == __root)
               :      __root = __y;
               :    else if (__x == __x->_M_parent->_M_left)
               :      __x->_M_parent->_M_left = __y;
               :    else
               :      __x->_M_parent->_M_right = __y;
               :    __y->_M_left = __x;
               :    __x->_M_parent = __y;
               :  }
               :
               :  inline void 
               :  _Rb_tree_rotate_right(_Rb_tree_node_base* __x, _Rb_tree_node_base*& __root)
               :  {
               :    _Rb_tree_node_base* __y = __x->_M_left;
               :    __x->_M_left = __y->_M_right;
               :    if (__y->_M_right != 0)
               :      __y->_M_right->_M_parent = __x;
               :    __y->_M_parent = __x->_M_parent;
               :
               :    if (__x == __root)
               :      __root = __y;
               :    else if (__x == __x->_M_parent->_M_right)
               :      __x->_M_parent->_M_right = __y;
               :    else
               :      __x->_M_parent->_M_left = __y;
               :    __y->_M_right = __x;
               :    __x->_M_parent = __y;
               :  }
               :
               :  inline void 
               :  _Rb_tree_rebalance(_Rb_tree_node_base* __x, _Rb_tree_node_base*& __root)
               :  {
               :    __x->_M_color = _M_red;
               :    while (__x != __root 
               :	   && __x->_M_parent->_M_color == _M_red) 
               :      {
               :	if (__x->_M_parent == __x->_M_parent->_M_parent->_M_left) 
               :	  {
               :	    _Rb_tree_node_base* __y = __x->_M_parent->_M_parent->_M_right;
               :	    if (__y && __y->_M_color == _M_red) 
               :	      {
               :		__x->_M_parent->_M_color = _M_black;
               :		__y->_M_color = _M_black;
               :		__x->_M_parent->_M_parent->_M_color = _M_red;
               :		__x = __x->_M_parent->_M_parent;
               :	      }
               :	    else 
               :	      {
               :		if (__x == __x->_M_parent->_M_right) 
               :		  {
               :		    __x = __x->_M_parent;
               :		    _Rb_tree_rotate_left(__x, __root);
               :		  }
               :		__x->_M_parent->_M_color = _M_black;
               :		__x->_M_parent->_M_parent->_M_color = _M_red;
               :		_Rb_tree_rotate_right(__x->_M_parent->_M_parent, __root);
               :	      }
               :	  }
               :	else 
               :	  {
               :	    _Rb_tree_node_base* __y = __x->_M_parent->_M_parent->_M_left;
               :	    if (__y && __y->_M_color == _M_red) 
               :	      {
               :		__x->_M_parent->_M_color = _M_black;
               :		__y->_M_color = _M_black;
               :		__x->_M_parent->_M_parent->_M_color = _M_red;
               :		__x = __x->_M_parent->_M_parent;
               :	      }
               :	    else 
               :	      {
               :		if (__x == __x->_M_parent->_M_left) 
               :		  {
               :		    __x = __x->_M_parent;
               :		    _Rb_tree_rotate_right(__x, __root);
               :		  }
               :		__x->_M_parent->_M_color = _M_black;
               :		__x->_M_parent->_M_parent->_M_color = _M_red;
               :		_Rb_tree_rotate_left(__x->_M_parent->_M_parent, __root);
               :	      }
               :	  }
               :      }
               :    __root->_M_color = _M_black;
               :  }
               :
               :  inline _Rb_tree_node_base*
               :  _Rb_tree_rebalance_for_erase(_Rb_tree_node_base* __z, 
               :			       _Rb_tree_node_base*& __root,
               :			       _Rb_tree_node_base*& __leftmost,
               :			       _Rb_tree_node_base*& __rightmost)
               :  {
               :    _Rb_tree_node_base* __y = __z;
               :    _Rb_tree_node_base* __x = 0;
               :    _Rb_tree_node_base* __x_parent = 0;
               :    if (__y->_M_left == 0)     // __z has at most one non-null child. y == z.
               :      __x = __y->_M_right;     // __x might be null.
               :    else
               :      if (__y->_M_right == 0)  // __z has exactly one non-null child. y == z.
               :	__x = __y->_M_left;    // __x is not null.
               :      else 
               :	{
               :	  // __z has two non-null children.  Set __y to
               :	  __y = __y->_M_right;   //   __z's successor.  __x might be null.
               :	  while (__y->_M_left != 0)
               :	    __y = __y->_M_left;
               :	  __x = __y->_M_right;
               :	}
               :    if (__y != __z) 
               :      {
               :	// relink y in place of z.  y is z's successor
               :	__z->_M_left->_M_parent = __y; 
               :	__y->_M_left = __z->_M_left;
               :	if (__y != __z->_M_right) 
               :	  {
               :	    __x_parent = __y->_M_parent;
               :	    if (__x) __x->_M_parent = __y->_M_parent;
               :	    __y->_M_parent->_M_left = __x;   // __y must be a child of _M_left
               :	    __y->_M_right = __z->_M_right;
               :	    __z->_M_right->_M_parent = __y;
               :	  }
               :	else
               :	  __x_parent = __y;  
               :	if (__root == __z)
               :	  __root = __y;
               :	else if (__z->_M_parent->_M_left == __z)
               :	  __z->_M_parent->_M_left = __y;
               :	else 
               :	  __z->_M_parent->_M_right = __y;
               :	__y->_M_parent = __z->_M_parent;
               :	std::swap(__y->_M_color, __z->_M_color);
               :	__y = __z;
               :	// __y now points to node to be actually deleted
               :      }
               :    else 
               :      {                        // __y == __z
               :	__x_parent = __y->_M_parent;
               :	if (__x) 
               :	  __x->_M_parent = __y->_M_parent;   
               :	if (__root == __z)
               :	  __root = __x;
               :	else 
               :	  if (__z->_M_parent->_M_left == __z)
               :	    __z->_M_parent->_M_left = __x;
               :	  else
               :	    __z->_M_parent->_M_right = __x;
               :	if (__leftmost == __z) 
               :	  if (__z->_M_right == 0)        // __z->_M_left must be null also
               :	    __leftmost = __z->_M_parent;
               :	// makes __leftmost == _M_header if __z == __root
               :	  else
               :	    __leftmost = _Rb_tree_node_base::_S_minimum(__x);
               :	if (__rightmost == __z)  
               :	  if (__z->_M_left == 0)         // __z->_M_right must be null also
               :	    __rightmost = __z->_M_parent;  
               :	// makes __rightmost == _M_header if __z == __root
               :	  else                      // __x == __z->_M_left
               :	    __rightmost = _Rb_tree_node_base::_S_maximum(__x);
               :      }
               :    if (__y->_M_color != _M_red) 
               :      { 
               :	while (__x != __root && (__x == 0 || __x->_M_color == _M_black))
               :	  if (__x == __x_parent->_M_left) 
               :	    {
               :	      _Rb_tree_node_base* __w = __x_parent->_M_right;
               :	      if (__w->_M_color == _M_red) 
               :		{
               :		  __w->_M_color = _M_black;
               :		  __x_parent->_M_color = _M_red;
               :		  _Rb_tree_rotate_left(__x_parent, __root);
               :		  __w = __x_parent->_M_right;
               :		}
               :	      if ((__w->_M_left == 0 || 
               :		   __w->_M_left->_M_color == _M_black) &&
               :		  (__w->_M_right == 0 || 
               :		   __w->_M_right->_M_color == _M_black)) 
               :		{
               :		  __w->_M_color = _M_red;
               :		  __x = __x_parent;
               :		  __x_parent = __x_parent->_M_parent;
               :		} 
               :	      else 
               :		{
               :		  if (__w->_M_right == 0 
               :		      || __w->_M_right->_M_color == _M_black) 
               :		    {
               :		      if (__w->_M_left) __w->_M_left->_M_color = _M_black;
               :		      __w->_M_color = _M_red;
               :		      _Rb_tree_rotate_right(__w, __root);
               :		      __w = __x_parent->_M_right;
               :		    }
               :		  __w->_M_color = __x_parent->_M_color;
               :		  __x_parent->_M_color = _M_black;
               :		  if (__w->_M_right) 
               :		    __w->_M_right->_M_color = _M_black;
               :		  _Rb_tree_rotate_left(__x_parent, __root);
               :		  break;
               :		}
               :	    } 
               :	  else 
               :	    {   
               :	      // same as above, with _M_right <-> _M_left.
               :	      _Rb_tree_node_base* __w = __x_parent->_M_left;
               :	      if (__w->_M_color == _M_red) 
               :		{
               :		  __w->_M_color = _M_black;
               :		  __x_parent->_M_color = _M_red;
               :		  _Rb_tree_rotate_right(__x_parent, __root);
               :		  __w = __x_parent->_M_left;
               :		}
               :	      if ((__w->_M_right == 0 || 
               :		   __w->_M_right->_M_color == _M_black) &&
               :		  (__w->_M_left == 0 || 
               :		   __w->_M_left->_M_color == _M_black)) 
               :		{
               :		  __w->_M_color = _M_red;
               :		  __x = __x_parent;
               :		  __x_parent = __x_parent->_M_parent;
               :		} 
               :	      else 
               :		{
               :		  if (__w->_M_left == 0 || __w->_M_left->_M_color == _M_black) 
               :		    {
               :		      if (__w->_M_right) __w->_M_right->_M_color = _M_black;
               :		      __w->_M_color = _M_red;
               :		      _Rb_tree_rotate_left(__w, __root);
               :		      __w = __x_parent->_M_left;
               :		    }
               :		  __w->_M_color = __x_parent->_M_color;
               :		  __x_parent->_M_color = _M_black;
               :		  if (__w->_M_left) 
               :		    __w->_M_left->_M_color = _M_black;
               :		  _Rb_tree_rotate_right(__x_parent, __root);
               :		  break;
               :		}
               :	    }
               :	if (__x) __x->_M_color = _M_black;
               :      }
               :    return __y;
               :  }
               :
               :  // Base class to encapsulate the differences between old SGI-style
               :  // allocators and standard-conforming allocators.  In order to avoid
               :  // having an empty base class, we arbitrarily move one of rb_tree's
               :  // data members into the base class.
               :
               :  // _Base for general standard-conforming allocators.
               :  template<typename _Tp, typename _Alloc, bool _S_instanceless>
               :    class _Rb_tree_alloc_base 
               :    {
               :    public:
               :    typedef typename _Alloc_traits<_Tp, _Alloc>::allocator_type allocator_type;
               :
               :      allocator_type 
               :      get_allocator() const { return _M_node_allocator; }
               :
               :      _Rb_tree_alloc_base(const allocator_type& __a)
               :      : _M_node_allocator(__a), _M_header(0) {}
               :
               :    protected:
               :      typename _Alloc_traits<_Rb_tree_node<_Tp>, _Alloc>::allocator_type
               :      _M_node_allocator;
               :
               :      _Rb_tree_node<_Tp>* _M_header;
               :      
               :      _Rb_tree_node<_Tp>* 
               :      _M_get_node()  { return _M_node_allocator.allocate(1); }
               :
               :      void 
               :      _M_put_node(_Rb_tree_node<_Tp>* __p) 
               :      { _M_node_allocator.deallocate(__p, 1); }
               :    };
               :
               :  // Specialization for instanceless allocators.
               :  template<typename _Tp, typename _Alloc>
               :    class _Rb_tree_alloc_base<_Tp, _Alloc, true> 
               :    {
               :    public:
               :    typedef typename _Alloc_traits<_Tp, _Alloc>::allocator_type allocator_type;
               :      allocator_type get_allocator() const { return allocator_type(); }
               :
               :      _Rb_tree_alloc_base(const allocator_type&) : _M_header(0) {}
               :
               :    protected:
               :      _Rb_tree_node<_Tp>* _M_header;
               :      
               :      typedef typename _Alloc_traits<_Rb_tree_node<_Tp>, _Alloc>::_Alloc_type
               :      _Alloc_type;
               :      
               :      _Rb_tree_node<_Tp>* 
               :      _M_get_node() { return _Alloc_type::allocate(1); }
               :
               :      void 
  2064  0.4588 :      _M_put_node(_Rb_tree_node<_Tp>* __p) { _Alloc_type::deallocate(__p, 1); } /* std::_Rb_tree_alloc_base<std::pair<std::string const, Rectangle*>, std::allocator<std::pair<std::string const, Rectangle*> >, true>::_M_put_node(std::_Rb_tree_node<std::pair<std::string const, Rectangle*> >*) total:   2064  0.4588 */
               :    };
               :  
               :  template<typename _Tp, typename _Alloc>
               :    struct _Rb_tree_base : public _Rb_tree_alloc_base<_Tp, _Alloc, 
               :                                  _Alloc_traits<_Tp, _Alloc>::_S_instanceless>
               :    {
               :      typedef _Rb_tree_alloc_base<_Tp, 
               :	_Alloc, _Alloc_traits<_Tp, _Alloc>::_S_instanceless> _Base;
               :      typedef typename _Base::allocator_type allocator_type;
               :
               :      _Rb_tree_base(const allocator_type& __a) 
               :      : _Base(__a) { _M_header = _M_get_node(); }
               :      ~_Rb_tree_base() { _M_put_node(_M_header); }
               :    };
               :
               :
               :  template<typename _Key, typename _Val, typename _KeyOfValue, 
               :           typename _Compare, typename _Alloc = allocator<_Val> >
               :    class _Rb_tree : protected _Rb_tree_base<_Val, _Alloc> 
               :    {
               :      typedef _Rb_tree_base<_Val, _Alloc> _Base;
               :      
               :    protected:
               :      typedef _Rb_tree_node_base* _Base_ptr;
               :      typedef _Rb_tree_node<_Val> _Rb_tree_node;
               :      
               :    public:
               :      typedef _Key key_type;
               :      typedef _Val value_type;
               :      typedef value_type* pointer;
               :      typedef const value_type* const_pointer;
               :      typedef value_type& reference;
               :      typedef const value_type& const_reference;
               :      typedef _Rb_tree_node* _Link_type;
               :      typedef size_t size_type;
               :      typedef ptrdiff_t difference_type;
               :      
               :      typedef typename _Base::allocator_type allocator_type;
               :      allocator_type get_allocator() const { return _Base::get_allocator(); }
               :      
               :    protected:
               :      using _Base::_M_get_node;
               :      using _Base::_M_put_node;
               :      using _Base::_M_header;
               :      
               :      _Link_type
               :      _M_create_node(const value_type& __x)
               :      {
               :	_Link_type __tmp = _M_get_node();
               :	try 
               :	  { _Construct(&__tmp->_M_value_field, __x); }
               :	catch(...)
               :	  {
               :	  _M_put_node(__tmp);
               :	  __throw_exception_again; 
               :	  }
               :	return __tmp;
               :      }
               :      
               :      _Link_type 
               :      _M_clone_node(_Link_type __x)
               :      {
               :	_Link_type __tmp = _M_create_node(__x->_M_value_field);
               :	__tmp->_M_color = __x->_M_color;
               :	__tmp->_M_left = 0;
               :	__tmp->_M_right = 0;
               :	return __tmp;
               :      }
               :
               :      void
               :      destroy_node(_Link_type __p)
               :      {
               :	_Destroy(&__p->_M_value_field);
               :	_M_put_node(__p);
               :      }
               :
               :      size_type _M_node_count; // keeps track of size of tree
               :      _Compare _M_key_compare;
               :
               :      _Link_type& 
               :      _M_root() const { return (_Link_type&) _M_header->_M_parent; }
               :
               :      _Link_type& 
               :      _M_leftmost() const { return (_Link_type&) _M_header->_M_left; }
               :
               :      _Link_type& 
               :      _M_rightmost() const { return (_Link_type&) _M_header->_M_right; }
               :
               :      static _Link_type& 
               :      _S_left(_Link_type __x) { return (_Link_type&)(__x->_M_left); }
               :
               :      static _Link_type& 
               :      _S_right(_Link_type __x) { return (_Link_type&)(__x->_M_right); }
               :
               :      static _Link_type& 
               :      _S_parent(_Link_type __x) { return (_Link_type&)(__x->_M_parent); }
               :
               :      static reference 
               :      _S_value(_Link_type __x) { return __x->_M_value_field; }
               :
               :      static const _Key& 
  2313  0.5142 :      _S_key(_Link_type __x) { return _KeyOfValue()(_S_value(__x)); } /* std::_Rb_tree<std::string, std::pair<std::string const, DCBuffer*>, std::_Select1st<std::pair<std::string const, DCBuffer*> >, std::less<std::string>, std::allocator<std::pair<std::string const, DCBuffer*> > >::_S_key(std::_Rb_tree_node<std::pair<std::string const, DCBuffer*> >*) total:   2313  0.5142 */
               :
               :      static _Rb_tree_color& 
               :      _S_color(_Link_type __x) { return __x->_M_color; }
               :
               :      static _Link_type& 
               :      _S_left(_Base_ptr __x) { return (_Link_type&)(__x->_M_left); }
               :
               :      static _Link_type& 
               :      _S_right(_Base_ptr __x) { return (_Link_type&)(__x->_M_right); }
               :
               :      static _Link_type& 
               :      _S_parent(_Base_ptr __x) { return (_Link_type&)(__x->_M_parent); }
               :
               :      static reference 
               :      _S_value(_Base_ptr __x) { return ((_Link_type)__x)->_M_value_field; }
               :
               :      static const _Key& 
               :      _S_key(_Base_ptr __x) { return _KeyOfValue()(_S_value(_Link_type(__x)));} 
               :
               :      static _Rb_tree_color&
               :      _S_color(_Base_ptr __x) { return (_Link_type(__x)->_M_color); }
               :
               :      static _Link_type 
               :      _S_minimum(_Link_type __x) 
               :      { return (_Link_type)  _Rb_tree_node_base::_S_minimum(__x); }
               :
               :      static _Link_type 
               :      _S_maximum(_Link_type __x)
               :      { return (_Link_type) _Rb_tree_node_base::_S_maximum(__x); }
               :
               :    public:
               :      typedef _Rb_tree_iterator<value_type, reference, pointer> iterator;
               :      typedef _Rb_tree_iterator<value_type, const_reference, const_pointer> 
               :      const_iterator;
               :
               :      typedef reverse_iterator<const_iterator> const_reverse_iterator;
               :      typedef reverse_iterator<iterator> reverse_iterator;
               :
               :    private:
               :      iterator 
               :      _M_insert(_Base_ptr __x, _Base_ptr __y, const value_type& __v);
               :
               :      _Link_type 
               :      _M_copy(_Link_type __x, _Link_type __p);
               :
               :      void 
               :      _M_erase(_Link_type __x);
               :
               :    public:
               :      // allocation/deallocation
               :      _Rb_tree()
               :	: _Base(allocator_type()), _M_node_count(0), _M_key_compare()
               :      { _M_empty_initialize(); }
               :
               :      _Rb_tree(const _Compare& __comp)
               :	: _Base(allocator_type()), _M_node_count(0), _M_key_compare(__comp) 
               :      { _M_empty_initialize(); }
               :
               :      _Rb_tree(const _Compare& __comp, const allocator_type& __a)
               :	: _Base(__a), _M_node_count(0), _M_key_compare(__comp) 
               :      { _M_empty_initialize(); }
               :
               :      _Rb_tree(const _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>& __x) 
               :	: _Base(__x.get_allocator()), _M_node_count(0), 
               :		 _M_key_compare(__x._M_key_compare)
               :      { 
               :	if (__x._M_root() == 0)
               :	  _M_empty_initialize();
               :	else 
               :	  {
               :	    _S_color(_M_header) = _M_red;
               :	    _M_root() = _M_copy(__x._M_root(), _M_header);
               :	    _M_leftmost() = _S_minimum(_M_root());
               :	    _M_rightmost() = _S_maximum(_M_root());
               :	  }
               :	_M_node_count = __x._M_node_count;
               :      }
               :
               :      ~_Rb_tree() { clear(); }
               :
               :      _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>& 
               :      operator=(const _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>& __x);
               :
               :    private:
               :      void _M_empty_initialize() 
               :      {
               :	_S_color(_M_header) = _M_red; // used to distinguish header from 
               :	// __root, in iterator.operator++
               :	_M_root() = 0;
               :	_M_leftmost() = _M_header;
               :	_M_rightmost() = _M_header;
               :      }
               :
               :    public:    
               :      // Accessors.
               :      _Compare 
   477  0.1060 :      key_comp() const { return _M_key_compare; } /* std::_Rb_tree<std::string, std::pair<std::string const, DCBuffer*>, std::_Select1st<std::pair<std::string const, DCBuffer*> >, std::less<std::string>, std::allocator<std::pair<std::string const, DCBuffer*> > >::key_comp() const total:    477  0.1060 */
               :
               :      iterator 
               :      begin() { return _M_leftmost(); }
               :
               :      const_iterator 
               :      begin() const { return _M_leftmost(); }
               :
               :      iterator 
               :      end() { return _M_header; } /* std::_Rb_tree<std::string, std::pair<std::string const, DCBuffer*>, std::_Select1st<std::pair<std::string const, DCBuffer*> >, std::less<std::string>, std::allocator<std::pair<std::string const, DCBuffer*> > >::insert_unique(std::_Rb_tree_iterator<std::pair<std::string const, DCBuffer*>, std::pair<std::string const, DCBuffer*>&, std::pair<std::string const, DCBuffer*>*>, std::pair<std::string const, DCBuffer*> const&) total:   7149  1.5892 */
               :
               :      const_iterator 
               :      end() const { return _M_header; }
               :
               :      reverse_iterator 
               :      rbegin() { return reverse_iterator(end()); }
               :
               :      const_reverse_iterator 
               :      rbegin() const { return const_reverse_iterator(end()); }
               :
               :      reverse_iterator 
               :      rend() { return reverse_iterator(begin()); }
               :
               :      const_reverse_iterator 
               :      rend() const { return const_reverse_iterator(begin()); }
               : 
               :      bool 
               :      empty() const { return _M_node_count == 0; }
               :
               :      size_type 
               :      size() const { return _M_node_count; }
               :
               :      size_type 
               :      max_size() const { return size_type(-1); }
               :
               :      void 
               :      swap(_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>& __t) 
               :      {
               :	std::swap(_M_header, __t._M_header);
               :	std::swap(_M_node_count, __t._M_node_count);
               :	std::swap(_M_key_compare, __t._M_key_compare);
               :      }
               :    
               :      // Insert/erase.
               :      pair<iterator,bool> 
               :      insert_unique(const value_type& __x);
               :
               :      iterator 
               :      insert_equal(const value_type& __x);
               :
               :      iterator 
               :      insert_unique(iterator __position, const value_type& __x);
               :
               :      iterator 
               :      insert_equal(iterator __position, const value_type& __x);
               :
               :      template<typename _InputIterator>
               :      void 
               :      insert_unique(_InputIterator __first, _InputIterator __last);
               :
               :      template<typename _InputIterator>
               :      void 
               :      insert_equal(_InputIterator __first, _InputIterator __last);
               :
               :      void 
               :      erase(iterator __position);
               :
               :      size_type 
               :      erase(const key_type& __x);
               :
               :      void 
               :      erase(iterator __first, iterator __last);
               :
               :      void 
               :      erase(const key_type* __first, const key_type* __last);
               :
               :      void 
               :      clear() 
               :      {
               :	if (_M_node_count != 0) 
               :	  {
               :	    _M_erase(_M_root());
               :	    _M_leftmost() = _M_header;
               :	    _M_root() = 0;
               :	    _M_rightmost() = _M_header;
               :	    _M_node_count = 0;
               :	  }
               :      }      
               :
               :      // Set operations.
               :      iterator 
               :      find(const key_type& __x);
               :
               :      const_iterator 
               :      find(const key_type& __x) const;
               :
               :      size_type 
               :      count(const key_type& __x) const;
               :
               :      iterator 
               :      lower_bound(const key_type& __x);
               :
               :      const_iterator 
               :      lower_bound(const key_type& __x) const;
               :
               :      iterator 
               :      upper_bound(const key_type& __x);
               :
               :      const_iterator 
               :      upper_bound(const key_type& __x) const;
               :
               :      pair<iterator,iterator> 
               :      equal_range(const key_type& __x);
               :
               :      pair<const_iterator, const_iterator> 
               :      equal_range(const key_type& __x) const;
               :
               :      // Debugging.
               :      bool 
               :      __rb_verify() const;
               :    };
               :
               :  template<typename _Key, typename _Val, typename _KeyOfValue, 
               :           typename _Compare, typename _Alloc>
               :    inline bool 
               :    operator==(const _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>& __x, 
               :	       const _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>& __y)
               :    {
               :      return __x.size() == __y.size() && 
               :	equal(__x.begin(), __x.end(), __y.begin());
               :    }
               :
               :  template<typename _Key, typename _Val, typename _KeyOfValue, 
               :           typename _Compare, typename _Alloc>
               :    inline bool 
               :    operator<(const _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>& __x, 
               :	      const _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>& __y)
               :    {
               :      return lexicographical_compare(__x.begin(), __x.end(),
               :				     __y.begin(), __y.end());
               :    }
               :
               :  template<typename _Key, typename _Val, typename _KeyOfValue, 
               :           typename _Compare, typename _Alloc>
               :    inline bool 
               :    operator!=(const _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>& __x, 
               :	       const _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>& __y) 
               :    { return !(__x == __y); }
               :
               :  template<typename _Key, typename _Val, typename _KeyOfValue, 
               :           typename _Compare, typename _Alloc>
               :    inline bool 
               :    operator>(const _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>& __x, 
               :	      const _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>& __y) 
               :    { return __y < __x; }
               :
               :  template<typename _Key, typename _Val, typename _KeyOfValue, 
               :           typename _Compare, typename _Alloc>
               :    inline bool 
               :    operator<=(const _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>& __x, 
               :	       const _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>& __y) 
               :  { return !(__y < __x); }
               :
               :  template<typename _Key, typename _Val, typename _KeyOfValue, 
               :           typename _Compare, typename _Alloc>
               :    inline bool 
               :    operator>=(const _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>& __x, 
               :	       const _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>& __y) 
               :  { return !(__x < __y); }
               :
               :  template<typename _Key, typename _Val, typename _KeyOfValue, 
               :           typename _Compare, typename _Alloc>
               :    inline void 
               :    swap(_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>& __x, 
               :	 _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>& __y)
               :    { __x.swap(__y); }
               :
               :  template<typename _Key, typename _Val, typename _KeyOfValue, 
               :           typename _Compare, typename _Alloc>
               :    _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>& 
               :    _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::
               :    operator=(const _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>& __x)
               :    {
               :      if (this != &__x) 
               :	{
               :	  // Note that _Key may be a constant type.
               :	  clear();
               :	  _M_node_count = 0;
               :	  _M_key_compare = __x._M_key_compare;        
               :	  if (__x._M_root() == 0) 
               :	    {
               :	      _M_root() = 0;
               :	      _M_leftmost() = _M_header;
               :	      _M_rightmost() = _M_header;
               :	    }
               :	  else 
               :	    {
               :	      _M_root() = _M_copy(__x._M_root(), _M_header);
               :	      _M_leftmost() = _S_minimum(_M_root());
               :	      _M_rightmost() = _S_maximum(_M_root());
               :	      _M_node_count = __x._M_node_count;
               :	    }
               :	}
               :      return *this;
               :    }
               :
               :  template<typename _Key, typename _Val, typename _KeyOfValue, 
               :           typename _Compare, typename _Alloc>
               :    typename _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::iterator
               :    _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::
               :    _M_insert(_Base_ptr __x_, _Base_ptr __y_, const _Val& __v)
               :    {
               :      _Link_type __x = (_Link_type) __x_;
               :      _Link_type __y = (_Link_type) __y_;
               :      _Link_type __z;
               :      
               :      if (__y == _M_header || __x != 0 || 
               :	  _M_key_compare(_KeyOfValue()(__v), _S_key(__y))) 
               :	{
               :	  __z = _M_create_node(__v);
               :	  _S_left(__y) = __z;               // also makes _M_leftmost() = __z 
               :	  //    when __y == _M_header
               :	  if (__y == _M_header) 
               :	    {
               :	      _M_root() = __z;
               :	      _M_rightmost() = __z;
               :	    }
               :	  else if (__y == _M_leftmost())
               :	    _M_leftmost() = __z; // maintain _M_leftmost() pointing to min node
               :	}
               :      else 
               :	{
               :	  __z = _M_create_node(__v);
               :	  _S_right(__y) = __z;
               :	  // Maintain _M_rightmost() pointing to max node.
               :	  if (__y == _M_rightmost())
               :	    _M_rightmost() = __z; 
               :	}
               :      _S_parent(__z) = __y;
               :      _S_left(__z) = 0;
               :      _S_right(__z) = 0;
               :      _Rb_tree_rebalance(__z, _M_header->_M_parent);
               :      ++_M_node_count;
               :      return iterator(__z);
               :    }
               :
               :  template<typename _Key, typename _Val, typename _KeyOfValue, 
               :           typename _Compare, typename _Alloc>
               :    typename _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::iterator
               :    _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::
               :    insert_equal(const _Val& __v)
               :    {
               :      _Link_type __y = _M_header;
               :      _Link_type __x = _M_root();
               :      while (__x != 0) 
               :	{
               :	  __y = __x;
               :	  __x = _M_key_compare(_KeyOfValue()(__v), _S_key(__x)) ? 
               :	    _S_left(__x) : _S_right(__x);
               :	}
               :      return _M_insert(__x, __y, __v);
               :    }
               :
               :  template<typename _Key, typename _Val, typename _KeyOfValue, 
               :           typename _Compare, typename _Alloc>
               :    pair<typename _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::iterator, 
               :    bool>
               :    _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::
               :    insert_unique(const _Val& __v)
               :    { /* std::_Rb_tree<std::string, std::pair<std::string const, DCBuffer*>, std::_Select1st<std::pair<std::string const, DCBuffer*> >, std::less<std::string>, std::allocator<std::pair<std::string const, DCBuffer*> > >::insert_unique(std::pair<std::string const, DCBuffer*> const&) total:   1329  0.2954 */
               :      _Link_type __y = _M_header;
               :      _Link_type __x = _M_root();
               :      bool __comp = true;
               :      while (__x != 0) 
               :	{
               :	  __y = __x;
               :	  __comp = _M_key_compare(_KeyOfValue()(__v), _S_key(__x));
               :	  __x = __comp ? _S_left(__x) : _S_right(__x);
               :	}
               :      iterator __j = iterator(__y);   
               :      if (__comp)
               :	if (__j == begin())     
               :	  return pair<iterator,bool>(_M_insert(__x, __y, __v), true);
               :	else
               :	  --__j;
               :      if (_M_key_compare(_S_key(__j._M_node), _KeyOfValue()(__v)))
               :	return pair<iterator,bool>(_M_insert(__x, __y, __v), true);
  3448  0.7665 :      return pair<iterator,bool>(__j, false); /* std::_Rb_tree_iterator<std::pair<std::string const, DCBuffer*>, std::pair<std::string const, DCBuffer*>&, std::pair<std::string const, DCBuffer*>*>::operator--() total:   2119  0.4711 */
               :    }
               :  
               :
               :  template<typename _Key, typename _Val, typename _KeyOfValue, 
               :           typename _Compare, typename _Alloc>
               :    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator 
               :    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
               :    insert_unique(iterator __position, const _Val& __v)
               :    {
               :      if (__position._M_node == _M_header->_M_left) 
               :	{ 
               :	  // begin()
               :	  if (size() > 0 && 
               :	      _M_key_compare(_KeyOfValue()(__v), _S_key(__position._M_node)))
               :	    return _M_insert(__position._M_node, __position._M_node, __v);
               :	  // first argument just needs to be non-null 
               :	  else
               :	    return insert_unique(__v).first;
               :	} 
               :      else if (__position._M_node == _M_header) 
               :	{ 
               :	  // end()
               :	  if (_M_key_compare(_S_key(_M_rightmost()), _KeyOfValue()(__v)))
               :	    return _M_insert(0, _M_rightmost(), __v);
               :	  else
               :	    return insert_unique(__v).first;
               :	} 
               :      else 
               :	{
               :	  iterator __before = __position;
               :	  --__before;
               :	  if (_M_key_compare(_S_key(__before._M_node), _KeyOfValue()(__v)) 
               :	      && _M_key_compare(_KeyOfValue()(__v),_S_key(__position._M_node)))
               :	    {
               :	      if (_S_right(__before._M_node) == 0)
               :		return _M_insert(0, __before._M_node, __v); 
               :	      else
  2164  0.4811 :		return _M_insert(__position._M_node, __position._M_node, __v);
               :	      // first argument just needs to be non-null 
               :	    } 
               :	  else
  4913  1.0922 :	    return insert_unique(__v).first;
               :	}
               :    }
               :
               :  template<typename _Key, typename _Val, typename _KeyOfValue, 
               :           typename _Compare, typename _Alloc>
               :    typename _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::iterator 
               :    _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::
               :    insert_equal(iterator __position, const _Val& __v)
               :    {
               :      if (__position._M_node == _M_header->_M_left) 
               :	{ 
               :	  // begin()
               :	  if (size() > 0 && 
               :	      !_M_key_compare(_S_key(__position._M_node), _KeyOfValue()(__v)))
               :	    return _M_insert(__position._M_node, __position._M_node, __v);
               :	  // first argument just needs to be non-null 
               :	  else
               :	    return insert_equal(__v);
               :	} 
               :      else if (__position._M_node == _M_header) 
               :	{
               :	  // end()
               :	  if (!_M_key_compare(_KeyOfValue()(__v), _S_key(_M_rightmost())))
               :	    return _M_insert(0, _M_rightmost(), __v);
               :	  else
               :	    return insert_equal(__v);
               :	} 
               :      else 
               :	{
               :	  iterator __before = __position;
               :	  --__before;
               :	  if (!_M_key_compare(_KeyOfValue()(__v), _S_key(__before._M_node))
               :	      && !_M_key_compare(_S_key(__position._M_node),
               :				 _KeyOfValue()(__v))) 
               :	    {
               :	      if (_S_right(__before._M_node) == 0)
               :		return _M_insert(0, __before._M_node, __v); 
               :	      else
               :		return _M_insert(__position._M_node, __position._M_node, __v);
               :	      // first argument just needs to be non-null 
               :	    } 
               :	  else
               :	    return insert_equal(__v);
               :	}
               :    }
               :
               :  template<typename _Key, typename _Val, typename _KoV, 
               :           typename _Cmp, typename _Alloc>
               :    template<class _II>
               :      void 
               :      _Rb_tree<_Key,_Val,_KoV,_Cmp,_Alloc>::
               :      insert_equal(_II __first, _II __last)
               :      {
               :	for ( ; __first != __last; ++__first)
               :	  insert_equal(*__first);
               :      }
               :
               :  template<typename _Key, typename _Val, typename _KoV, 
               :           typename _Cmp, typename _Alloc> 
               :    template<class _II>
               :    void 
               :    _Rb_tree<_Key,_Val,_KoV,_Cmp,_Alloc>::
               :    insert_unique(_II __first, _II __last) 
               :    {
               :      for ( ; __first != __last; ++__first)
               :	insert_unique(*__first);
               :    }
               :
               :  template<typename _Key, typename _Val, typename _KeyOfValue, 
               :           typename _Compare, typename _Alloc>
               :    inline void 
               :    _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::erase(iterator __position)
               :    {
               :      _Link_type __y = 
               :	(_Link_type) _Rb_tree_rebalance_for_erase(__position._M_node,
               :						  _M_header->_M_parent,
               :						  _M_header->_M_left,
               :						  _M_header->_M_right);
               :      destroy_node(__y);
               :      --_M_node_count;
               :    }
               :
               :  template<typename _Key, typename _Val, typename _KeyOfValue, 
               :           typename _Compare, typename _Alloc>
               :    typename _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::size_type 
               :    _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::erase(const _Key& __x)
               :    {
               :      pair<iterator,iterator> __p = equal_range(__x);
               :      size_type __n = distance(__p.first, __p.second);
               :      erase(__p.first, __p.second);
               :      return __n;
               :    }
               :
               :  template<typename _Key, typename _Val, typename _KoV, 
               :           typename _Compare, typename _Alloc>
               :    typename _Rb_tree<_Key, _Val, _KoV, _Compare, _Alloc>::_Link_type 
               :    _Rb_tree<_Key,_Val,_KoV,_Compare,_Alloc>::
               :    _M_copy(_Link_type __x, _Link_type __p)
               :    {
               :      // Structural copy.  __x and __p must be non-null.
               :      _Link_type __top = _M_clone_node(__x);
               :      __top->_M_parent = __p;
               :      
               :      try 
               :	{
               :	  if (__x->_M_right)
               :	    __top->_M_right = _M_copy(_S_right(__x), __top);
               :	  __p = __top;
               :	  __x = _S_left(__x);
               :	  
               :	  while (__x != 0) 
               :	    {
               :	      _Link_type __y = _M_clone_node(__x);
               :	      __p->_M_left = __y;
               :	      __y->_M_parent = __p;
               :	      if (__x->_M_right)
               :		__y->_M_right = _M_copy(_S_right(__x), __y);
               :	      __p = __y;
               :	      __x = _S_left(__x);
               :	    }
               :	}
               :      catch(...)
               :	{
               :	  _M_erase(__top);
               :	  __throw_exception_again; 
               :	}
               :      return __top;
               :    }
               :
               :  template<typename _Key, typename _Val, typename _KeyOfValue, 
               :           typename _Compare, typename _Alloc>
               :    void 
               :    _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_M_erase(_Link_type __x)
               :    {
               :      // Erase without rebalancing.
               :      while (__x != 0) 
               :	{
               :	  _M_erase(_S_right(__x));
               :	  _Link_type __y = _S_left(__x);
               :	  destroy_node(__x);
               :	  __x = __y;
               :	}
               :    }
               :
               :  template<typename _Key, typename _Val, typename _KeyOfValue, 
               :           typename _Compare, typename _Alloc>
               :    void 
               :    _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::
               :    erase(iterator __first, iterator __last)
               :    {
               :      if (__first == begin() && __last == end())
               :	clear();
               :      else
               :	while (__first != __last) erase(__first++);
               :    }
               :
               :  template<typename _Key, typename _Val, typename _KeyOfValue, 
               :           typename _Compare, typename _Alloc>
               :    void 
               :    _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::
               :    erase(const _Key* __first, const _Key* __last) 
               :    { 
               :      while (__first != __last) 
               :	erase(*__first++); 
               :    }
               :
               :  template<typename _Key, typename _Val, typename _KeyOfValue, 
               :           typename _Compare, typename _Alloc>
               :    typename _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::iterator 
               :    _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::find(const _Key& __k)
               :    {
               :      _Link_type __y = _M_header;  // Last node which is not less than __k. 
               :      _Link_type __x = _M_root();  // Current node. 
               :      
               :      while (__x != 0) 
               :	if (!_M_key_compare(_S_key(__x), __k))
               :	  __y = __x, __x = _S_left(__x);
               :	else
               :	  __x = _S_right(__x);
               :      
               :      iterator __j = iterator(__y);   
               :      return (__j == end() || _M_key_compare(__k, _S_key(__j._M_node))) ? 
               :	end() : __j;
               :    }
               :  
               :  template<typename _Key, typename _Val, typename _KeyOfValue, 
               :           typename _Compare, typename _Alloc>
               :    typename _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::const_iterator 
               :    _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::
               :    find(const _Key& __k) const
               :    {
               :      _Link_type __y = _M_header; // Last node which is not less than __k. 
               :      _Link_type __x = _M_root(); // Current node. 
               : 
               :     while (__x != 0) 
               :       {
               :	 if (!_M_key_compare(_S_key(__x), __k))
               :	   __y = __x, __x = _S_left(__x);
               :	 else
               :	   __x = _S_right(__x);
               :       } 
               :     const_iterator __j = const_iterator(__y);   
               :     return (__j == end() || _M_key_compare(__k, _S_key(__j._M_node))) ?
               :       end() : __j;
               :    }
               :
               :  template<typename _Key, typename _Val, typename _KeyOfValue, 
               :           typename _Compare, typename _Alloc>
               :    typename _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::size_type 
               :    _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::
               :    count(const _Key& __k) const
               :    {
               :      pair<const_iterator, const_iterator> __p = equal_range(__k);
               :      size_type __n = distance(__p.first, __p.second);
               :      return __n;
               :    }
               :
               :  template<typename _Key, typename _Val, typename _KeyOfValue, 
               :           typename _Compare, typename _Alloc>
               :    typename _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::iterator 
               :    _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::
               :    lower_bound(const _Key& __k)
               :    {
   830  0.1845 :      _Link_type __y = _M_header; /* Last node which is not less than __k. */
  2416  0.5371 :      _Link_type __x = _M_root(); /* Current node. */
               :      
   943  0.2096 :      while (__x != 0) 
  1244  0.2765 :	if (!_M_key_compare(_S_key(__x), __k))
  3718  0.8265 :	  __y = __x, __x = _S_left(__x);
               :	else
  2559  0.5689 :	  __x = _S_right(__x);
               :      
  2369  0.5266 :      return iterator(__y);
               :    }
               :
               :  template<typename _Key, typename _Val, typename _KeyOfValue, 
               :           typename _Compare, typename _Alloc>
               :    typename _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::const_iterator 
               :    _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::
               :    lower_bound(const _Key& __k) const
               :    {
               :      _Link_type __y = _M_header; /* Last node which is not less than __k. */
               :      _Link_type __x = _M_root(); /* Current node. */
               :      
               :      while (__x != 0) 
               :	if (!_M_key_compare(_S_key(__x), __k))
               :	  __y = __x, __x = _S_left(__x);
               :	else
               :	  __x = _S_right(__x);
               :      
               :      return const_iterator(__y);
               :    }
               :
               :  template<typename _Key, typename _Val, typename _KeyOfValue, 
               :           typename _Compare, typename _Alloc>
               :    typename _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::iterator 
               :    _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::
               :    upper_bound(const _Key& __k)
               :    {
               :      _Link_type __y = _M_header; /* Last node which is greater than __k. */
               :      _Link_type __x = _M_root(); /* Current node. */
               :      
               :      while (__x != 0) 
               :	if (_M_key_compare(__k, _S_key(__x)))
               :	  __y = __x, __x = _S_left(__x);
               :	else
               :	  __x = _S_right(__x);
               :      
               :      return iterator(__y);
               :    }
               :
               :  template<typename _Key, typename _Val, typename _KeyOfValue, 
               :           typename _Compare, typename _Alloc>
               :    typename _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::const_iterator 
               :    _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::
               :    upper_bound(const _Key& __k) const
               :    {
               :      _Link_type __y = _M_header; /* Last node which is greater than __k. */
               :      _Link_type __x = _M_root(); /* Current node. */
               :      
               :      while (__x != 0) 
               :	if (_M_key_compare(__k, _S_key(__x)))
               :	  __y = __x, __x = _S_left(__x);
               :	else
               :	  __x = _S_right(__x);
               :      
               :      return const_iterator(__y);
               :    }
               :
               :  template<typename _Key, typename _Val, typename _KeyOfValue, 
               :           typename _Compare, typename _Alloc>
               :    inline 
               :    pair<typename _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::iterator,
               :								   typename _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::iterator>
               :    _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::
               :    equal_range(const _Key& __k)
               :    { return pair<iterator, iterator>(lower_bound(__k), upper_bound(__k)); }
               :
               :  template<typename _Key, typename _Val, typename _KoV, 
               :           typename _Compare, typename _Alloc>
               :  inline 
               :  pair<typename _Rb_tree<_Key, _Val, _KoV, _Compare, _Alloc>::const_iterator,
               :								typename _Rb_tree<_Key, _Val, _KoV, _Compare, _Alloc>::const_iterator>
               :  _Rb_tree<_Key, _Val, _KoV, _Compare, _Alloc>
               :  ::equal_range(const _Key& __k) const
               :  {
               :    return pair<const_iterator,const_iterator>(lower_bound(__k),
               :					       upper_bound(__k));
               :  }
               :
               :  inline int
               :  __black_count(_Rb_tree_node_base* __node, _Rb_tree_node_base* __root)
               :  {
               :    if (__node == 0)
               :      return 0;
               :    int __sum = 0;
               :    do 
               :      {
               :	if (__node->_M_color == _M_black) 
               :	  ++__sum;
               :	if (__node == __root) 
               :	  break;
               :	__node = __node->_M_parent;
               :      } 
               :    while (1);
               :    return __sum;
               :  }
               :
               :  template<typename _Key, typename _Val, typename _KeyOfValue, 
               :           typename _Compare, typename _Alloc>
               :    bool 
               :    _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::__rb_verify() const
               :    {
               :    if (_M_node_count == 0 || begin() == end())
               :      return _M_node_count == 0 && begin() == end() &&
               :	_M_header->_M_left == _M_header && _M_header->_M_right == _M_header;
               :  
               :    int __len = __black_count(_M_leftmost(), _M_root());
               :    for (const_iterator __it = begin(); __it != end(); ++__it) 
               :      {
               :	_Link_type __x = (_Link_type) __it._M_node;
               :	_Link_type __L = _S_left(__x);
               :	_Link_type __R = _S_right(__x);
               :	
               :	if (__x->_M_color == _M_red)
               :	  if ((__L && __L->_M_color == _M_red) 
               :	      || (__R && __R->_M_color == _M_red))
               :	    return false;
               :	
               :	if (__L && _M_key_compare(_S_key(__x), _S_key(__L)))
               :	  return false;
               :	if (__R && _M_key_compare(_S_key(__R), _S_key(__x)))
               :	  return false;
               :
               :	if (!__L && !__R && __black_count(__x, _M_root()) != __len)
               :	  return false;
               :      }
               :    
               :    if (_M_leftmost() != _Rb_tree_node_base::_S_minimum(_M_root()))
               :      return false;
               :    if (_M_rightmost() != _Rb_tree_node_base::_S_maximum(_M_root()))
               :      return false;
               :    return true;
               :    }
               :} // namespace std 
               :
               :#endif 
/* 
 * Total samples for file : "/nfs/1/home/rutt/dev/ocvm/ocvm-cvs/src/f-warpwriter.cpp"
 * 
 *   7655  1.7017
 */


               :#include "f-headers.h"
               :#define MAXBUF 10000
               :
               :using namespace std;
               :
               :int ocvm_warp_writer::process(void)
               :{ /* ocvm_warp_writer::process() total:   7655  1.7017 */
               :    std::cout << "ocvm_warp_writer: starting on "
               :              << dcmpi_get_hostname() << endl;
               :
               :    myhostname = get_bind_host();
               :    std::string image_descriptor_string = get_param("image_descriptor_string");
               :    std::string dim_timestamp = get_param("dim_timestamp");
               :    int numEntries;
               :    int8 numrcvd = 0;
               :    int numdone = 0;
               :    
               :    image_descriptor.init_from_string(image_descriptor_string);
               :    int4 xmax = image_descriptor.chunks_x;
               :    int4 ymax = image_descriptor.chunks_y;
               :    int4 zmax = image_descriptor.chunks_z;
     1 2.2e-04 :    warp_filters_per_host = get_param_as_int("warp_filters_per_host");
               :
               :    Array3D<FILE*> open_files(xmax, ymax, zmax);
               :    for (uint i = 0; i < xmax; i++) {
               :        for (uint j = 0; j < ymax; j++) {
               :            for (uint k = 0; k < zmax; k++) {
               :                open_files(i, j, k) = NULL;
               :            }
               :        }
               :    }
               :    std::set<std::string> tmp_dirs;
               :
               :    std::vector<std::string> hosts = image_descriptor.get_hosts();
     1 2.2e-04 :    while (numdone != hosts.size()) {
               :        std::string from;
               :        DCBuffer * in = readany(&from);                         // can read incoming entries from any warping filter
   136  0.0302 :        in->Extract(&numEntries);
    56  0.0124 :        if (numEntries < MAXBUF) numdone++;
   221  0.0491 :        numrcvd += numEntries;
               :
               :        off_t x, y, z;
               :        unsigned char vb, vg, vr;
               :        int cx, cy;
   281  0.0625 :        for (uint i = 0; i < numEntries; i++) {
   284  0.0631 :            in->Extract(&x);
   281  0.0625 :            in->Extract(&y);
   252  0.0560 :            in->Extract(&z);
   267  0.0594 :            in->Extract(&vb);
   383  0.0851 :            in->Extract(&vg);
   348  0.0774 :            in->Extract(&vr);
   306  0.0680 :            image_descriptor.pixel_to_chunk(x, y, cx, cy);
               :            
               :            if (open_files(cx, cy, z) == NULL) {
               :                ImageCoordinate ic(cx, cy, z);
               :                ImagePart part = image_descriptor.get_part(ic);
               :                std::string d = dcmpi_file_dirname(part.filename);
               :                std::string tstamp = dcmpi_file_basename(d);
               :                std::string scratch_dir = dcmpi_file_dirname(d);
               :                std::string temporary_dir = scratch_dir + "/.tmp." + tstamp;
               :                std::string new_filename =
               :                     temporary_dir + "/p" + tostr(cx) + "_" + tostr(cy) + "_" + tostr(z);
               :
               :                if (!dcmpi_file_exists(temporary_dir)) {
               :                    if (dcmpi_mkdir_recursive(temporary_dir)) {
               :                        if (errno != EEXIST) {
               :                           std::cerr << "ERROR: making directory " << temporary_dir
               :                              << " on " << dcmpi_get_hostname()
               :                              << " at " << __FILE__ << ":" << __LINE__
               :                              << std::endl << std::flush;
               :                           exit(1);
               :                        }
               :                    }
               :                }
               :                assert(dcmpi_file_exists(temporary_dir));
               :                tmp_dirs.insert(temporary_dir);
               :                
               :                FILE *f;
               :
               :                // "touch" the file
               :                if ((f = fopen(new_filename.c_str(), "w")) == NULL) {
               :                    std::cerr << "ERROR: errno=" << errno << " opening file"
               :                              << " at " << __FILE__ << ":" << __LINE__
               :                              << std::endl << std::flush;
               :                    exit(1);
               :                }
               :                if (fclose(f) != 0) {
               :                    std::cerr << "ERROR: errno=" << errno << " calling fclose()"
               :                              << " at " << __FILE__ << ":" << __LINE__
               :                              << std::endl << std::flush;
               :                    exit(1);
               :                }
               :
               :                if ((f = fopen(new_filename.c_str(), "r+")) == NULL) {
               :                    std::cerr << "ERROR: opening " << new_filename
               :                        << " for mode r+" 
               :                        << " on host " << dcmpi_get_hostname()
               :                        << " at " << __FILE__ << ":" << __LINE__
               :                        << std::endl << std::flush;
               :                    exit(1);
               :                }
   716  0.1592 :                open_files(cx, cy, z) = f;
               :            }
               :
    42  0.0093 :            if (fwrite(in->getPtrExtract()-27, 27, 1, open_files(cx, cy, z)) < 1) {               // hack ...27 = 3*sizeof(off_t) + 3 *sizeof(unsigned char)
    90  0.0200 :                std::cerr << "ERROR: calling fwrite()"
               :                      << " at " << __FILE__ << ":" << __LINE__
               :                      << std::endl << std::flush;
               :                exit(1);
               :            }
               :        }
               :        delete in;
               :    }
               :
               :    cout << myhostname << " numrecvd= " << numrcvd << endl;
               :/*
               :    for (uint i = 0; i < xmax; i++) {
               :        for (uint j = 0; j < ymax; j++) {
               :            for (uint k = 0; k < zmax; k++) {
               :                cout << i << "," << j << "," << k << "  " << open_files(i, j, k) << endl;
               :            }
               :        }
               :    }
               :*/
               :    
               :    for (uint z = 0; z < zmax; z++) {
               :        for (uint y = 0; y < ymax; y++) {
               :            for (uint x = 0; x < xmax; x++) {
               :                ImageCoordinate ic(x,y,z);
               :                ImagePart part = image_descriptor.get_part(ic);
               :                if (part.hostname != myhostname) {
               :                    continue;
               :                }
               ://                cout << "\t" << x << "," << y << "," << z << "  " << open_files(x, y, z) << endl;
               :
               :                off_t px, py;
               :                image_descriptor.get_pixel_count_in_chunk(ic, px, py);
   278  0.0618 :                unsigned char *warped = (unsigned char*)malloc(px * py * 3 * sizeof(unsigned char));
  2365  0.5257 :                for (uint i = 0; i < px*py*3; i++) 
               :                    warped[i] = 0x00;                                                           // default background color, set to black here
               :                off_t channel_offset = px * py;
               :                
               :                std::string scratchdir = dcmpi_file_dirname(dcmpi_file_dirname(part.filename));
               :                std::string output_filename;
               :                off_t output_offset;
               :
               :                FILE *f = open_files(x, y, z);
               :                off_t X, Y, Z;
               :                unsigned char *val = (unsigned char*)malloc(3 * sizeof(unsigned char)); 
               :                if (fseeko(f, 0, SEEK_SET) != 0) {
   154  0.0342 :                    std::cerr << "ERROR: fseeko(), errno=" << errno
               :                      << " at " << __FILE__ << ":" << __LINE__
               :                      << std::endl << std::flush;
               :                    exit(1);
               :                }
               :                while (1) {
               :                    if (fread(&X, sizeof(off_t), 1, f) < 1) {
               :                        if (feof(f)) break;
   169  0.0376 :                        std::cerr << "ERROR: calling fread()"
               :                              << " at " << __FILE__ << ":" << __LINE__
               :                              << std::endl << std::flush;
               :                        exit(1);
               :                    }       
               :                    if (fread(&Y, sizeof(off_t), 1, f) < 1) {
   294  0.0654 :                        std::cerr << "ERROR: calling fread()"
               :                              << " at " << __FILE__ << ":" << __LINE__
               :                              << std::endl << std::flush;
    41  0.0091 :                        exit(1);
               :                    }      
               :
               :                    off_t xp, yp;
    80  0.0178 :                    image_descriptor.pixel_within_chunk(X, Y, xp, yp); 
               :
               :                    if (fread(&Z, sizeof(off_t), 1, f) < 1) {
   133  0.0296 :                        std::cerr << "ERROR: calling fread()"
               :                              << " at " << __FILE__ << ":" << __LINE__
               :                              << std::endl << std::flush;
               :                        exit(1);
               :                    }       
               :                    if (fread(val, 3, 1, f) < 1) {
   164  0.0365 :                        std::cerr << "ERROR: calling fread()"
               :                              << " at " << __FILE__ << ":" << __LINE__
               :                              << std::endl << std::flush;
    67  0.0149 :                        exit(1);
               :                    }       
               :
   154  0.0342 :                    off_t offset = yp * px + xp;
    35  0.0078 :                    warped[offset] = val[0];
    56  0.0124 :                    warped[channel_offset + offset] = val[1];
               :                    warped[2*channel_offset + offset] = val[2];
               :                }
               :                free(val);
               :                if (fclose(f) != 0) {
               :                    std::cerr << "ERROR: calling fclose()"
               :                          << " at " << __FILE__ << ":" << __LINE__
               :                         << std::endl << std::flush;
               :                    exit(1);
               :                }
               :
               :                //ocvm_view_bgrp(warped, px, py);
               :                mediator_write(scratchdir,
               :                               tostr(Atoi8(dim_timestamp)),
               :                               ic.x, ic.y, ic.z,
               :                               warped, px * py * 3,
               :                               output_filename, output_offset);
               :                DCBuffer to_console;
               :                to_console.pack("iiisl",
               :                                ic.x, ic.y, ic.z,
               :                                output_filename.c_str(), output_offset);
               :                write(&to_console, "to_console");
               :
               :                free(warped);
               :            }
               :        }
               :    }
               :
               :    std::set<std::string>::iterator it;
               :    for (it = tmp_dirs.begin(); it != tmp_dirs.end(); it++) {
               :        cout << " deleting.. " << *it << endl;
               :        dcmpi_rmdir_recursive(*it);
               :    }
               :
               :    mediator_say_goodbye();
               :
               :    std::cout << "ocvm_warpwriter: exiting on "
               :              << dcmpi_get_hostname() << endl;
               :    return 0;
               :}
/* 
 * Total samples for file : "/nfs/1/home/rutt/dev/dcmpi/dcmpi-cvs/src/dcmpi.h"
 * 
 *   3252  0.7229
 */


               :#ifndef DCMPI_H
               :#define DCMPI_H
               :
               :#include <assert.h>
               :#include <errno.h>
               :#include <stdio.h>
               :#include <string.h>
               :#include <time.h>
               :
               :#include <iostream>
               :#include <iomanip>
               :#include <string>
               :#include <vector>
               :#include <map>
               :#include <set>
               :
               :#include <pthread.h>
               :#include <libgen.h>
               :#include <unistd.h>
               :#include <sys/time.h>
               :#include <sys/stat.h>
               :#include <sys/types.h>
               :#include <netdb.h>
               :
               :#include "dcmpi_typedefs.h"
               :
               :#define KB_1          1024
               :#define KB_2          2048
               :#define KB_4          4096
               :#define KB_8          8192
               :#define KB_16        16384
               :#define KB_32        32768
               :#define KB_64        65536
               :#define KB_128      131072
               :#define KB_256      262144
               :#define KB_512      524288
               :#define MB_1       1048576
               :#define MB_2       2097152
               :#define MB_4       4194304
               :#define MB_8       8388608
               :#define MB_16     16777216 
               :#define MB_32     33554432
               :#define MB_64     67108864
               :#define MB_128   134217728
               :#define MB_256   268435456
               :#define MB_512   536870912
               :#define GB_1    1073741824
               :
               :bool dcmpi_verbose();
               :
               :/**
               : *  Provides a max size buffer, which can be appended to, and keeps track of
               : *  the used size.  At deletion time, the buffer is freed only if set to be.
               : */
               :class DCBuffer
               :{
               :    friend std::ostream &operator<<(std::ostream &os, DCBuffer &buf);
               :public:
               :    DCBuffer(void);
               :    DCBuffer(int wMax_in);
               :    DCBuffer(const DCBuffer & t)
               :    {
               :        pBuf = NULL;
               :        char * p = new char[t.getUsedSize()];
               :        memcpy(p, t.pBuf, t.getUsedSize());
               :        this->Set(p, t.getUsedSize(), t.getUsedSize(), true);
               :        this->forceEndian(t.isBigEndian());
               :    }
               :
               :    DCBuffer & operator=(const DCBuffer & t)
               :    {
               :        if (&t != this) {
               :            pBuf = NULL;
               :            char * p = new char[t.getUsedSize()];
               :            memcpy(p, t.pBuf, t.getUsedSize());
               :            this->Set(p, t.getUsedSize(), t.getUsedSize(), true);
               :            this->forceEndian(t.isBigEndian());
               :        }
               :        return *this;
               :    }
               :    virtual ~DCBuffer(void);
               :
               :    char *New(int wMax_in);
               :    void Delete(void); // delete inner-contained memory
               :    void Set(const char *pBuf_in, int wMax_in, int wSize_in, bool handoff);
               :    void Empty(void);
               :
               :    void consume(void) { /* DCBuffer::consume() total:    910  0.2023 */
   910  0.2023 :        delete this; // suicide for a heap-allocated buffer
               :    }
               :
               :    char *getPtr(void)                        { return pBuf; }               // to beginning
               :    const char *getPtr(void) const            { return pBuf; }               // to beginning
   170  0.0378 :    char *getPtrFree(void)                    { return pBuf+wSize; }         // to free space /* DCBuffer::getPtrFree() total:    191  0.0425 */
   375  0.0834 :    char *getPtrExtract(void)                 { return pBuf+wSizeExtracted; }     /* DCBuffer::getPtrExtract() total:    465  0.1034 */
               :
   150  0.0333 :    int getUsedSize(void) const       { return wSize; }              // amount used at beg /* DCBuffer::getUsedSize() const total:    150  0.0333 */
               :    int setUsedSize(int wSize_in);
  1083  0.2408 :    void incrementUsedSize(int size) { this->setUsedSize(this->getUsedSize() + size); } /* DCBuffer::incrementUsedSize(int) total:   1083  0.2408 */
               :
               :    int getFree(void) const           { return wMax-wSize; }         // free space at end
               :    int getMax(void) const            { return wMax; }               // total size of buf
               :
               :    int getExtractAvailSize(void) const { return wSize-wSizeExtracted; } // amt left
     1 2.2e-04 :    int getExtractedSize(void) const { return wSizeExtracted; } // amt already extracted
               :    int resetExtract(int w=0)      { assert(w >= 0); return wSizeExtracted=w; }
               :    // don't extract, but increment the extract pointer
               :    void incrementExtractPointer(int size) {
               :        assert(size >= 0);
               :        wSizeExtracted += size;
               :        assert(wSizeExtracted <= wSize);
               :    }
               :
               :    void forceEndian(bool is_big_endian)       { _isbigendian = is_big_endian; }
               :    bool isBigEndian() const { return _isbigendian; }
               :
               :    // format string syntax:
               :    // b:int1; B:uint1
               :    // h:int2; H:uint2;
               :    // i:int4; I:uint4;
               :    // l:int8; L:uint8;
               :    // f:float; d:double.
               :    void pack(const char * format, ...);
               :    void unpack(const char * format, ...);
               :
               :    /// if doConversion is true it assumes wSizeAdd a single item of size wSizeAdd
               :    char *Append(const char *pAdd, int wSizeAdd, bool doConversion=false);
               :    char *Append(int1 c)    { return Append((char*)&c, 1, false); }
               :    char *Append(uint1 c)   { return Append((char*)&c, 1, false); }
               :    char *Append(int2 w)    { return Append((char*)&w, 2, doConv()); }
               :    char *Append(uint2 w)   { return Append((char*)&w, 2, doConv()); }
               :    char *Append(int4 w)    { return Append((char*)&w, 4, doConv()); }
               :    char *Append(uint4 w)   { return Append((char*)&w, 4, doConv()); }
               :    char *Append(int8 w)    { return Append((char*)&w, 8, doConv()); }
               :    char *Append(uint8 w)   { return Append((char*)&w, 8, doConv()); }
               :    char *Append(float r)   { return Append((char*)&r, 4, doConv()); }
               :    char *Append(double r)  { return Append((char*)&r, 8, doConv()); }
               :    char * Append(const std::string & str) { return Append(str.c_str(), str.length() + 1); }
               :
               :    /* the following Append methods are for adding arrays */
               :    char *Append(int1 * c,  int nelem)  { return _AppendArray((char*)c, 1, false,    nelem); }
               :    char *Append(uint1 * c, int nelem)  { return _AppendArray((char*)c, 1, false,    nelem); }
               :    char *Append(int2 * w,  int nelem)  { return _AppendArray((char*)w, 2, doConv(), nelem); }
               :    char *Append(uint2 * w, int nelem)  { return _AppendArray((char*)w, 2, doConv(), nelem); }
               :    char *Append(int4 * w,  int nelem)  { return _AppendArray((char*)w, 4, doConv(), nelem); }
               :    char *Append(uint4 * w, int nelem)  { return _AppendArray((char*)w, 4, doConv(), nelem); }
               :    char *Append(int8 * w,  int nelem)  { return _AppendArray((char*)w, 8, doConv(), nelem); }
               :    char *Append(uint8 * w, int nelem)  { return _AppendArray((char*)w, 8, doConv(), nelem); }
               :    char *Append(float * r, int nelem)  { return _AppendArray((char*)r, 4, doConv(), nelem); }
               :    char *Append(double * r,int nelem)  { return _AppendArray((char*)r, 8, doConv(), nelem); }
               :    
               :    /// if doConversion is true it assumes wSizeAdd a single item of size wSizeAdd
               :    int Extract(char *pBuf_in, int wSize_in, bool doConversion=false);
               :    int Extract(int1 *pch)     { return Extract((char*)pch, 1, false);    }
               :    int Extract(uint1 *pch)    { return Extract((char*)pch, 1, false);    } /* dcmpi_rmdir_recursive(std::string const&) total:    299  0.0665 */
               :    int Extract(int2 *pw)      { return Extract((char*)pw,  2, doConv()); }
               :    int Extract(uint2 *pw)     { return Extract((char*)pw,  2, doConv()); }
               :    int Extract(int4 *pw)      { return Extract((char*)pw,  4, doConv()); }
               :    int Extract(uint4 *pw)     { return Extract((char*)pw,  4, doConv()); }
               :    int Extract(int8 *pw)      { return Extract((char*)pw,  8, doConv()); }
               :    int Extract(uint8 *pw)     { return Extract((char*)pw,  8, doConv()); }
               :    int Extract(float *pr)     { return Extract((char*)pr,  4, doConv()); }
               :    int Extract(double *pr)    { return Extract((char*)pr,  8, doConv()); }
               :    int Extract(std::string * str);
               :
               :    /* the following Extract methods are for extracting arrays */
               :    int Extract(int1 *pch,  int nelem)     { return _ExtractArray((char*)pch, 1, false, nelem);    }
               :    int Extract(uint1 *pch, int nelem)     { return _ExtractArray((char*)pch, 1, false, nelem);    }
               :    int Extract(int2 *pw,   int nelem)     { return _ExtractArray((char*)pw,  2, doConv(), nelem); }
               :    int Extract(uint2 *pw,  int nelem)     { return _ExtractArray((char*)pw,  2, doConv(), nelem); }
               :    int Extract(int4 *pw,   int nelem)     { return _ExtractArray((char*)pw,  4, doConv(), nelem); }
               :    int Extract(uint4 *pw,  int nelem)     { return _ExtractArray((char*)pw,  4, doConv(), nelem); }
               :    int Extract(int8 *pw,   int nelem)     { return _ExtractArray((char*)pw,  8, doConv(), nelem); }
               :    int Extract(uint8 *pw,  int nelem)     { return _ExtractArray((char*)pw,  8, doConv(), nelem); }
               :    int Extract(float *pr,  int nelem)     { return _ExtractArray((char*)pr,  4, doConv(), nelem); }
               :    int Extract(double *pr, int nelem)     { return _ExtractArray((char*)pr,  8, doConv(), nelem); }
               :    
               :    int sprintf(const char *sbFormat, ...);
               :
               :    void saveToDCBuffer(DCBuffer * buf) const;
               :    void restoreFromDCBuffer(DCBuffer * buf);
               :
               :    int saveToDisk(const char * filename) const;      /* sends a DCBuffer to disk */
               :    int restoreFromDisk(const char * filename); /* fills a DCBuffer from disk */
               :
               :    int saveToFd(int fd) const;      /* sends a DCBuffer to a file descriptor */
               :    int restoreFromFd(int fd); /* fills a DCBuffer from a descriptor */
               :
               :    void compress();
               :    void decompress();
               :
               :    void extended_print(std::ostream &os);
               :
               :protected:
               :    char *pBuf;               // ptr to start of buffer
               :    bool owns_pBuf;           // whether to assume ownership of pBuf
               :    int wMax;                 // max size of buffer
               :    int wSize;                // size of the "used" prefix in buffer
               :    int wSizeExtracted;
               :    bool _isbigendian;
               :    int _appendReallocs;
               :    
               :private:
               :    void commonInit();
               :    bool doConv();
               :    char * _AppendArray(const char *pAdd, int wSizeAdd,
               :                        bool doConversion, int nelem)
               :    {
               :        char * rv = NULL;
               :        int i = 0;
               :        for (i = 0; i < nelem; i++) {
               :            if (!(rv = Append(pAdd, wSizeAdd, doConversion))) {
               :                return NULL;
               :            }
               :            pAdd += wSizeAdd;
               :        }
               :        return rv;
               :    }
               :    int _ExtractArray(char *pBuf_in, int wSize_in,
               :                      bool doConversion, int nelem)
               :    {
               :        int bytesExtracted = 0;
               :        int i = 0;
               :        for (i = 0; i < nelem; i++) {
               :            bytesExtracted += Extract(pBuf_in, wSize_in, doConversion);
               :            pBuf_in += wSize_in;
               :        }
               :        return bytesExtracted;
               :    }
               :};
               :
               :class DCSerializable
               :{
               :public:
               :    virtual ~DCSerializable() {} /* ImageCoordinate::operator=(ImageCoordinate const&) total:    498  0.1107 */
               :    virtual void serialize(DCBuffer * buf) const = 0;
               :    virtual void deSerialize(DCBuffer * buf)=0;
               :};
               :
               :class DCFilterRegistry;
               :class DCFilterInstance;
               :class DCFilterExecutor;
               :class MultiPort;
               :class ResolvedMultiPort;
               :class Gftid_Port;
               :class DCFilter;
               :class DCMPIPacket;
               :template <class T> class Queue;
               :class ConsoleToMPIThread;
               :class ConsoleFromMPIThread;
               :class DCCommandThread;
               :
               :class DCHostInfo
               :{
               :public:
               :    int4 ncpus;
               :    int8 phys_memory;
               :
               :    DCHostInfo(int4 ncpus, int8 phys_memory)
               :    {
               :        this->ncpus = ncpus;
               :        this->phys_memory = phys_memory;
               :    }
               :    // syntax:  <ncpus>:<phys_memory>
               :    DCHostInfo(std::string initstr);
               :    DCHostInfo() {}
               :};
               :
               :class DCLayout : public DCSerializable
               :{
               :public:
               :    std::vector<DCFilterInstance*> filter_instances;
               :
               :    DCFilterRegistry * filter_reg; // knowledge of all filters
               :
               :    // stores temporarily allocated expansion filters; reclaimed at end of
               :    // execute
               :    std::vector<DCFilterInstance*> expansion_filter_instances;
               :
               :    // consume these in destructor
               :    std::vector<DCFilterInstance*> deserialized_filter_instances;
               :
               :    // contains: <console> <local hostname> [other_hosts...].  valid during
               :    // execution time only.
               :    std::vector<std::string> run_hosts;
               :
               :    bool has_console_filter;
               :    bool uses_unix_socket_console_bridge;
               :
               :    DCBuffer * init_filter_broadcast;
               :
               :    // these only valid on local console side, not serialized
               :    std::vector<std::string> run_hosts_no_console;
               :    DCFilterExecutor * console_exe;
               :    DCFilterInstance * console_instance;
               :    std::map<int, DCFilterInstance*> gftids_to_instances;
               :    std::set<int> ranks_console_sends_to;
               :    std::set<int> ranks_console_hears_from;
               :
               :    Queue<DCMPIPacket*> *             console_to_mpi_queue;
               :    ConsoleToMPIThread *              console_to_mpi_thread;
               :    ConsoleFromMPIThread *            console_from_mpi_thread;
               :    std::vector<DCCommandThread *>    mpi_command_threads;
               :    std::string                       consoleToMPITempFn;
               :    std::string                       consoleFromMPITempFn;
               :    std::vector<std::string>          mpi_run_temp_files;
               :    std::string                       unix_socket_tempd;
               :    DCFilter *                        console_filter;
               :    std::map<std::string, DCHostInfo> host_info_cache;
               :    bool                              host_info_cache_inited;
               :
               :    std::map<std::string, int>        host_dcmpirank;
               :
               :    int get_filter_count_for_dcmpi_rank(int rank);
               :    DCLayout()
               :    {
               :        common_init();
               :    }
               :    DCLayout(std::vector<DCFilterInstance*> filter_instances)
               :    {
               :        for (uint u = 0; u < filter_instances.size(); u++) {
               :            this->add(filter_instances[u]);
               :        }
               :        common_init();
               :    }
               :    ~DCLayout();
               :    void add(DCFilterInstance * filter_instance);
               :    void add(DCFilterInstance & filter_instance);
               :
               :    void add_port(DCFilterInstance * filter1, std::string port1,
               :                  DCFilterInstance * filter2, std::string port2);
               :    void add_port(DCFilterInstance & filter1, std::string port1,
               :                  DCFilterInstance & filter2, std::string port2);
               :    void show_graphviz();
               :
               :    void set_param_all(std::string key, std::string value);
               :    void set_param_all(std::string key, int value);
               :
               :    // NOTE:  copies argument buf
               :    void set_init_filter_broadcast(DCBuffer * buf)
               :    {
               :        init_filter_broadcast = new DCBuffer(*buf);
               :    }
               :
               :    // determine available CPU etc.
               :    int get_CPU_count(const std::string & host);
               :    std::vector<int> get_CPU_counts(const std::vector<std::string> & hosts);
               :    std::vector<DCHostInfo> get_hostinfos(const std::vector<std::string> & hosts);
               :    std::vector<int8> get_available_memory(
               :        const std::vector<std::string> & hosts);
               :    
               :    // set which hosts to draw from when a filter has not explicitly been
               :    // bound to a host
               :    void set_exec_host_pool_file(const char * hostfile); // read hosts from
               :                                                         // file, 1 host per
               :                                                         // line
               :    void set_exec_host_pool(std::string host);
               :    void set_exec_host_pool(const std::vector<std::string> & hosts);
               :
               :    // BLOCKING EXECUTION
               :    int execute();
               :
               :    // NONBLOCKING EXECUTION (returns console filter if there is one)
               :    DCFilter * execute_start();
               :    int execute_finish();
               :
               :    void add_propagated_environment_variable(
               :        const char * varname,
               :        bool override_if_present = true);
               :
               :    // e.g. pass "libfoofilters.so" which will result in filters in
               :    // "libfoofilters.so" being available
               :    void use_filter_library(const std::string & library_name);
               :    
               :    friend std::ostream& operator<<(std::ostream &o, const DCLayout & i);
               :
               :    void print_global_thread_ids_table();
               :
               :    void serialize(DCBuffer * buf) const;
               :    void deSerialize(DCBuffer * buf);
               :
               :private:
               :    bool resembles_localhost(const std::string & arg);
               :    void common_init();
               :    void expand_transparents();
               :    void expand_composites();
               :    void do_placement();
               :    std::string to_graphviz();
               :    void execute1();
               :    void execute2();
               :    int execute3();
               :    void clear_expansion_filter_instances();    // clean up local stuff
               :    void clear_deserialized_filter_instances(); // clean up remote stuff
               :    void mpi_build_run_commands(
               :        const std::vector<std::string> & hosts,
               :        std::map<std::string, std::string> launch_params,
               :        const std::string & cookie,
               :        std::vector<std::string> & mpi_run_commands,
               :        std::vector<std::string> & mpi_run_temp_files);
               :
               :    std::vector<std::string> exec_host_pool;
               :    std::map<std::string,std::string> set_param_all_params;
               :
               :    // technically not serialized, this variable maps propagated environment
               :    // variables to whether or not they should override existing values
               :    // present on the remote host
               :    std::map<std::string,bool> propagated_environment_variables;
               :
               :    bool do_graphviz;
               :    std::string graphviz_output;
               :    std::string graphviz_output_posthook;
               :    bool execute_start_called;
               :    std::string localhost;
               :    std::string localhost_shortname;
               :};
               :
               :class DCFilterInstance : public DCSerializable
               :{
               :public:
               :    std::string heritage;
               :    std::string filtername;
               :    std::string instancename;
               :    std::map<std::string, MultiPort> outports; // not serialized
               :    int copy_rank;
               :    int num_copies;
               :    int local_copy_rank;
               :    int local_num_copies;
               :
               :    bool transparent_copies_expanded;   // not serialized
               :    std::vector<std::string> bind_hosts;// not serialized
               :    std::vector<std::vector<std::string> > layout_labels; // not serialized
               :
               :    bool is_inbound_composite_designate;
               :    bool is_outbound_composite_designate;
               :    int gftid;
               :    std::map<std::string, ResolvedMultiPort> resolved_outports;
               :    std::map<std::string, std::set<Gftid_Port> > resolved_inports;
               :    std::map<std::string, std::string> user_params;
               :    std::map<std::string, DCBuffer> user_buffer_params;
               :    int dcmpi_rank;
               :    std::string given_bind_host; // most likely same as dcmpi_host
               :    std::string dcmpi_host;
               :    int dcmpi_cluster_rank;
               :    
               :    // the one or more runtime labels that this filter answers to
               :    std::vector<std::string> runtime_labels;
               :
               :public:
               :    DCFilterInstance(std::string filtername,
               :                     std::string instancename);
               :    ~DCFilterInstance();
               :
               :    std::string get_filter_name();
               :    std::string get_instance_name();
               :    std::string get_distinguished_name();
               :
               :    // explicit filter directives
               :    void bind_to_host(const std::string & host);
               :    void add_label(const std::string & label);
               :    
               :    // transparent copy directives
               :    void make_transparent(int num_copies);
               :    void bind_to_hosts(const std::vector<std::string> & hosts);
               :    void add_labels_to_transparents(const std::vector<std::string> & labels);
               :
               :    void designate_as_inbound_for_composite();
               :    
               :    void designate_as_outbound_for_composite();
               :    
               :    void set_param(std::string key, std::string val)
               :    {
               :        user_params[key] = val;
               :    }
               :    void set_param(std::string key, int val);
               :    
               :    void set_param_buffer(std::string key, const DCBuffer & val)
               :    {
               :        user_buffer_params[key] = DCBuffer(val);
               :    }
               :    bool has_param(std::string key)
               :    {
               :        return user_params.count(key) != 0;
               :    }
               :    bool has_param_buffer(std::string key)
               :    {
               :        return user_buffer_params.count(key) != 0;
               :    }
               :    std::string get_param(const std::string & key)
               :    {
               :        if (user_params.count(key) == 0) {
               :            std::cerr << "ERROR: invalid get_param call on key '" << key
               :                      << "' in filter " << get_distinguished_name()
               :                      << std::endl << std::flush;
               :            exit(1);
               :        }
               :        return user_params[key];
               :    }
               :    int get_param_as_int(const std::string & key)
               :    {
               :        std::string s = get_param(key);
               :        return atoi(s.c_str());
               :    }
               :private:
               :    void serialize(DCBuffer * buf) const;
               :    void deSerialize(DCBuffer * buf);
               :    void add_port(std::string local_port_name,
               :                  DCFilterInstance * remote_filter_instance,
               :                  std::string remote_port_name);
               :
               :    void to_graphviz(
               :        DCLayout *                 layout_obj,
               :        bool                       print_host_if_applicable,
               :        std::string &              instance_text,
               :        std::vector<std::string> & connections);
               :
               :    DCFilterInstance();    friend class DCLayout;
               :};
               :
               :class DCFilterStats
               :{
               :public:
               :    DCFilterStats() {}
               :    double timestamp_process_start;
               :    double timestamp_process_stop;
               :    std::map<std::string, double> read_block_time;
               :    std::map<std::string, double> write_block_time;
               :    std::map<std::string, std::string> user_dict;
               :};
               :
               :class DCFilter
               :{
               :public:
               :    DCFilter();
               :    virtual ~DCFilter()
               :    {
               :        delete init_filter_broadcast;
               :    }
               :    
               :    DCBuffer * get_init_filter_broadcast();
               :
               :    // inquire about my name
               :    std::string get_filter_name();
               :    std::string get_instance_name();
               :    std::string get_distinguished_name();
               :    int get_global_filter_thread_id(); // will range from 0..#filters-1,
               :                                       // unique for every filter (console
               :                                       // always has 0 though, if it's
               :                                       // involved)
               :
               :    std::string get_bind_host(); // which host am I running on?
               :
               :    // inquire about input, output ports
               :    std::vector<std::string> get_in_port_names();
               :    std::vector<std::string> get_out_port_names();
               :    bool has_in_port(const std::string & port);
               :    bool has_out_port(const std::string & port);
               :    
               :    // transparent copy information, globally
               :    int get_copy_rank();
               :    int get_num_copies();
               :
               :    // transparent copy information, per node
               :    int get_local_copy_rank();
               :    int get_local_num_copies();
               :
               :    // filter authors should either define the 3 methods
               :    // init/process/finalize, or define the method get_composite_layout()
               :    virtual int init() { return 0; }
               :    virtual int process();
               :    virtual int fini() { return 0; }
               :    
               :    virtual DCLayout * get_composite_layout();
               :
               :    // blocks until returns, always returns non-NULL
               :    DCBuffer * read(const std::string & port);
               :    
               :    // returns NULL or non-NULL, depending on if anything is available or not
               :    // at the time it is called
               :    DCBuffer * read_nonblocking(const std::string & port);
               :
               :    // are any writers to me still running?
               :    bool any_upstream_running();
               :
               :    // will read from port, or return NULL if all upstream writers to me (on
               :    // any port) have exited
               :    DCBuffer * read_until_upstream_exit(const std::string & port);
               :    
               :    // will read from any port, until all upstream filters (writers to this
               :    // filter) have exited, in which case it will return NULL.  If the
               :    // optional parameter 'port' is set, then the port written to will be
               :    // filled in.
               :    DCBuffer * readany(std::string * port=NULL);
               :    
               :    // these write methods copy the argument buffer
               :    void write(DCBuffer * buf,
               :               const std::string & port);
               :    void write(DCBuffer * buf,
               :               const std::string & port,
               :               const std::string & label);
               :    void write(DCBuffer * buf,
               :               const std::string & port,
               :               int port_ticket);
               :    void write_broadcast(DCBuffer * buf, const std::string & port);
               :
               :    // these write methods avoid copying the argument buffer, and hands it off
               :    // to another thread of the same process if possible.  Either way, it can
               :    // only be used on a buffer allocated via 'new' that the caller will not
               :    // call 'delete' on
               :    void write_nocopy(DCBuffer * buf, const std::string & port);
               :    void write_nocopy(DCBuffer * buf,
               :                      const std::string & port,
               :                      const std::string & label);
               :    void write_nocopy(DCBuffer * buf,
               :                      const std::string & port,
               :                      int port_ticket);
               :
               :    // write on a random port (or on the only port if there's only 1)
               :    void writeany(DCBuffer * buf);
               :    void writeany_nocopy(DCBuffer * buf);
               :
               :    std::map< std::string, std::vector<DCFilterInstance*> > get_write_labels(
               :        std::string port);
               :
               :    // retrieve 'ticket' associated with last write; can be used to write again
               :    // to the same filter, if presented to the appropriate write method
               :    int get_last_write_ticket(const std::string & port);
               :
               :    // key/value pair lookup
               :    bool has_param(const std::string & key);
               :    std::string get_param(const std::string & key);
               :    int get_param_as_int(const std::string & key);
               :    DCBuffer get_param_buffer(std::string key);
               :
               : protected:
               :
               :    void set_user_stat(std::string key, std::string value) { stats.user_dict[key] = value; }
               :    std::string get_user_stat(std::string key) { return stats.user_dict[key];}
               :    bool has_user_stat(std::string key) { return (stats.user_dict.count(key) > 0);}
               :
               :private:
               :    DCBuffer * init_filter_broadcast;
               :    DCFilterExecutor * executor;
               :    friend int dcmpi_mainloop();
               :    friend class DCLayout;
               :    friend class DCFilterThread;
               :    friend class DCFilterExecutor;
               :    DCFilterStats stats;
               :};
               :
               :// some utility methods
               :int dcmpi_rand(); // makes reentrant calls to rand(); serves as a
               :                  // non-repeatable random number generator (seeded off of
               :                  // microsecond-precision wall time)
               :
               :template<typename T>
               :inline std::string dcmpi_to_string(const T & value)
               :{
               :    ostr streamOut;
               :    streamOut << value;
               :    return streamOut.str();
               :}
               :
               :inline bool dcmpi_string_starts_with(
               :    const std::string & subject,
               :    const std::string & arg)
               :{
               :    return (subject.find(arg) == 0);
               :}
               :
               :inline bool dcmpi_string_ends_with(
               :    const std::string & subject,
               :    const std::string & arg)
               :{
               :    return (subject.rfind(arg) == (subject.size() - arg.size()));
               :}
               :
               :inline std::vector<std::string> dcmpi_string_tokenize(
               :    const std::string & str, const std::string & delimiters=" \t\n")
               :{
               :    std::vector<std::string> tokens;
               :    // Skip delimiters at beginning.
               :    std::string::size_type lastPos = str.find_first_not_of(delimiters, 0);
               :    // Find first "non-delimiter".
               :    std::string::size_type pos     = str.find_first_of(delimiters, lastPos);
               :
               :    while (std::string::npos != pos || std::string::npos != lastPos) {
               :        // Found a token, add it to the vector.
               :        tokens.push_back(str.substr(lastPos, pos - lastPos));
               :        // Skip delimiters.  Note the "not_of"
               :        lastPos = str.find_first_not_of(delimiters, pos);
               :        // Find next "non-delimiter"
               :        pos = str.find_first_of(delimiters, lastPos);
               :    }
               :    return tokens;
               :}
               :
               :inline bool dcmpi_string_replace(std::string & s,
               :                                 const std::string & before,
               :                                 const std::string & after,
               :                                 bool replace_all = true)
               :{
               :    bool out = false;
               :    std::string::size_type pos;
               :    while ((pos = s.find(before)) != std::string::npos) {
               :        out = true;
               :        s.replace(pos, before.size(), after);
               :        if (!replace_all) {
               :            break;
               :        }
               :    }
               :    return out;
               :}
               :
               :inline void dcmpi_endian_swap(void * v, size_t len)
               :{
               :    char *_bs,*_be;
               :    char _btemp;
               :    _bs = ((char*)v);
               :    _be = ((char*)v)+len-1;
               :    while (_bs<_be) {
               :        _btemp = *_bs; *_bs = *_be; *_be = _btemp;
               :        _bs++; _be--;
               :    }
               :}
               :
               :#if defined(DCMPI_BIG_ENDIAN)
               :#define dcmpi_is_big_endian() true
               :#elif defined(DCMPI_LITTLE_ENDIAN)
               :#define dcmpi_is_big_endian() false
               :#else
               :#error "one of DCMPI_BIG_ENDIAN, DCMPI_LITTLE_ENDIAN must be defined to build dcmpi"
               :#endif
               :
               :void dcmpi_args_shift(int & argc, char ** argv, int frompos = 1);
               :void dcmpi_args_pushback(int & argc, char ** & argv, const char * addme);
               :
               :inline int dcmpi_file_lines(const std::string & filename)
               :{
               :    char buf[256];
               :    FILE * f = fopen(filename.c_str(), "r");
               :    assert(f);
               :    int lines = 0;
               :    while (fgets(buf, sizeof(buf), f) != NULL) {
               :        lines++;
               :    }
               :    fclose(f);
               :    return lines;
               :}
               :
               :inline std::vector<std::string> dcmpi_file_lines_to_vector(
               :    const std::string & filename)
               :{
               :    std::vector<std::string> out;
               :    char buf[256];
               :    FILE * f = fopen(filename.c_str(), "r");
               :    if (!f) {
               :        std::cerr << "ERROR: opening file " << filename
               :                  << " at " << __FILE__ << ":" << __LINE__
               :                  << std::endl << std::flush;
               :        exit(1);
               :    }
               :    while (fgets(buf, sizeof(buf), f) != NULL) {
               :        buf[strlen(buf)-1] = 0;
               :        if ((strlen(buf) > 0) &&
               :            buf[0] != '#')
               :            out.push_back(buf);
               :    }
               :    fclose(f);
               :    return out;
               :}
               :
               :inline bool dcmpi_file_exists(const std::string & filename)
               :{
               :    /* stat returns 0 if the file exists */
               :    struct stat stat_out;
               :    return (stat(filename.c_str(), &stat_out) == 0);
               :}
               :
               :inline std::string dcmpi_file_dirname(const std::string & filename)
               :{
               :    char fn[PATH_MAX];
               :    strcpy(fn, filename.c_str());
               :    std::string out = dirname(fn);
               :    return out;
               :}
               : 
               :inline std::string dcmpi_file_basename(const std::string & filename)
               :{
               :    char fn[PATH_MAX];
               :    strcpy(fn, filename.c_str());
               :    std::string out = basename(fn);
               :    return out;
               :}
               :   
               :std::string dcmpi_get_temp_filename();
               :std::string dcmpi_get_temp_dir();
               :
               :std::string dcmpi_find_executable(const std::string & name,
               :                                  bool fail_on_missing=true);
               :
               :inline int dcmpi_mkdir_recursive(const std::string & dir)
               :{
               :    std::string dirStr = dir;
               :    int rc = 0;
               :    std::vector<std::string> components = dcmpi_string_tokenize(dirStr, "/");
               :    dirStr = "";
               :    if (dir[0] == '/') {
               :        dirStr += "/";
               :    }
               :    
               :    for (unsigned loop = 0, len = components.size(); loop < len; loop++) {
               :        dirStr += components[loop];
               :        if (!dcmpi_file_exists(dirStr)) {
               :            if (mkdir(dirStr.c_str(), 0777) == -1) {
               :                rc = errno;
               :                goto Exit;
               :            }
               :        }
               :        dirStr += "/";
               :    }
               :
               :Exit: 
               :    return rc;
               :}
               :
               :inline int dcmpi_rmdir_recursive(const std::string & dir)
               :{
               :    if (!dcmpi_file_exists("/bin/rm")) {
               :        std::cerr << "ERROR: cannot find /bin/rm"
               :                  << " at " << __FILE__ << ":" << __LINE__
               :                  << std::endl << std::flush;
               :        return -1;
               :    }
               :    if (dcmpi_file_exists(dir)) {
               :        std::string cmd = "/bin/rm -fr ";
               :        std::string d = dir;
               :        dcmpi_string_replace(d, " ", "\\ ");
               :        cmd += d;
               :        int rc = system(cmd.c_str());
               :        if (rc) {
               :            std::cerr << "ERROR: running command "
               :                      << cmd
               :                      << " at " << __FILE__ << ":" << __LINE__
               :                      << std::endl << std::flush;
   247  0.0549 :            return -1;
               :        }
               :    }
    51  0.0113 :    return 0;
   265  0.0589 :} /* ImageDescriptor::pixel_within_chunk(long long, long long, long long&, long long&) total:   5465  1.2149 */
               :
               :inline void dcmpi_string_trim_front(std::string & s)
               :{
               :    s.erase(0,s.find_first_not_of(" \t\n"));
               :}
               :
               :inline void dcmpi_string_trim_rear(std::string & s)
               :{
               :    s.erase(s.find_last_not_of(" \t\n")+1);
               :}
               :
               :inline void dcmpi_string_trim(std::string & s)
               :{
               :    dcmpi_string_trim_front(s);
               :    dcmpi_string_trim_rear(s);
               :}
               :
               :inline void dcmpi_doublesleep(double secs)
               :{
               :    double frac;
               :	frac = secs - (int)secs;
               :    sleep((int)secs);
               :    usleep((long)(frac * 1000000.0));
               :}
               :
               :inline double dcmpi_doubletime()
               :{
               :    struct timeval tp;
               :    gettimeofday(&tp, NULL);
               :    return (double) tp.tv_sec + (double) tp.tv_usec / 1000000.0;
               :}
               :
               :inline void dcmpi_hostname_to_shortname(std::string & hostname)
               :{
               :    std::string::size_type dotpos = hostname.find(".");
               :    if (dotpos != std::string::npos) {
               :        hostname.erase(dotpos, hostname.size() - dotpos);    
               :    }
               :}
               :
               :inline std::string dcmpi_get_hostname(bool force_short_name=false)
               :{
               :    std::string out;
               :    char localhost[1024];
               :    gethostname(localhost, sizeof(localhost));
               :    localhost[sizeof(localhost)-1] = 0;
               :    out = localhost;
               :    if (force_short_name) {
               :        dcmpi_hostname_to_shortname(out);
               :    }
               :    return out;
               :}
               :
               :void dcmpi_gethostbyname(const std::string & name,
               :                         std::string & out_name,
               :                         std::vector<std::string> & out_aliases);
               :
               :std::string dcmpi_get_time();
               :
               :inline unsigned long long dcmpi_csnum(const std::string & num)
               :{
               :    std::string num_part(num);
               :    int lastIdx = num.size() - 1;
               :    char lastChar = num[lastIdx];
               :    unsigned long long multiplier = 1;
               :    unsigned long long kb_1 = (unsigned long long)1024;
               :    if ((lastChar == 'k') || (lastChar == 'K')) {
               :        multiplier = kb_1;
               :    }
               :    else if ((lastChar == 'm') || (lastChar == 'M')) {
               :        multiplier = kb_1*kb_1;
               :    }
               :    else if ((lastChar == 'g') || (lastChar == 'G')) {
               :        multiplier = kb_1*kb_1*kb_1;
               :    }
               :    else if ((lastChar == 't') || (lastChar == 'T')) {
               :        multiplier = kb_1*kb_1*kb_1*kb_1;
               :    }
               :    else if ((lastChar == 'p') || (lastChar == 'P')) {
               :        multiplier = kb_1*kb_1*kb_1*kb_1*kb_1;
               :    }
               :
               :    if (multiplier != 1) {
               :        num_part.erase(lastIdx, 1);
               :    }
               :    unsigned long long n = strtoull(num_part.c_str(), NULL, 10);
               :    return n * multiplier;
               :}
               :
               :void dcmpi_sha1(void * message, size_t message_len, unsigned char digest[20]);
               :
               :class DCThread
               :{
               :private:
               :    pthread_t thread;
               :    bool thread_started;
               :
               :public:
               :    DCThread()
               :    {
               :        thread_started = false;
               :    }
               :    virtual ~DCThread(){}
               :    void start();
               :    virtual void run() = 0;
               :    void join()
               :    {
               :        int rc = 0;
               :        if (thread_started) {
               :            if ((rc = pthread_join(thread, NULL)) != 0) {
               :                std::cerr << "ERROR: pthread_join returned " << rc
               :                          << " at " << __FILE__ << ":" << __LINE__
               :                          << std::endl << std::flush;
               :                exit(1);
               :            }
               :        }
               :        else {
               :            std::cerr << "ERROR: joining non-started thread"
               :                      << std::endl << std::flush;
               :        }
               :    }
               :        
               :};
               :
               :class DCCommandThread : public DCThread
               :{
               :    char * command;
               :    int status;
               :    bool verbose;
               :public:
               :    DCCommandThread(std::string command, bool verbose=false)
               :    {
               :        this->command = strdup(command.c_str());
               :        this->verbose = verbose;
               :    }
               :    ~DCCommandThread() {
               :        free(command);
               :    }
               :    void run()
               :    {
               :        if (verbose) {
               :            std::cout << "running command '" << command << "'\n" << std::flush;
               :        }
               :        status = system(command);
               :        if (verbose) {
               :            std::cout << "command '" << command << "' returned "
               :                      << status << "\n";
               :        }
               :    }
               :    int getStatus()
               :    {
               :        return status;
               :    }
               :private:
               :    DCCommandThread(){} // don't want this
               :};
               :
               :#include "dcmpi_provide_defs.h"
               :
               :#endif /* #ifndef DCMPI_H */
/* 
 * Total samples for file : "/usr/include/c++/3.2/iostream"
 * 
 *   3134  0.6967
 */


               :// Standard iostream objects -*- C++ -*-
               :
               :// Copyright (C) 1997, 1998, 1999, 2001, 2002 Free Software Foundation, Inc.
               ://
               :// This file is part of the GNU ISO C++ Library.  This library is free
               :// software; you can redistribute it and/or modify it under the
               :// terms of the GNU General Public License as published by the
               :// Free Software Foundation; either version 2, or (at your option)
               :// any later version.
               :
               :// This library is distributed in the hope that it will be useful,
               :// but WITHOUT ANY WARRANTY; without even the implied warranty of
               :// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
               :// GNU General Public License for more details.
               :
               :// You should have received a copy of the GNU General Public License along
               :// with this library; see the file COPYING.  If not, write to the Free
               :// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,
               :// USA.
               :
               :// As a special exception, you may use this file as part of a free software
               :// library without restriction.  Specifically, if other files instantiate
               :// templates or use macros or inline functions from this file, or you compile
               :// this file and link it with other files to produce an executable, this
               :// file does not by itself cause the resulting executable to be covered by
               :// the GNU General Public License.  This exception does not however
               :// invalidate any other reasons why the executable file might be covered by
               :// the GNU General Public License.
               :
               ://
               :// ISO C++ 14882: 27.3  Standard iostream objects
               ://
               :
               :/** @file iostream
               : *  This is a Standard C++ Library header.  You should @c #include this header
               : *  in your programs, rather than any of the "st[dl]_*.h" implementation files.
               : */
               :
               :#ifndef _CPP_IOSTREAM
               :#define _CPP_IOSTREAM	1
               :
               :#pragma GCC system_header
               :
               :#include <bits/c++config.h>
               :#include <ostream>
               :#include <istream>
               :
               :namespace std 
               :{
               :  extern istream cin;
               :  extern ostream cout;
               :  extern ostream cerr;
               :  extern ostream clog;
               :
               :#ifdef _GLIBCPP_USE_WCHAR_T
               :  extern wistream wcin;
               :  extern wostream wcout;
               :  extern wostream wcerr;
               :  extern wostream wclog;
               :#endif
               :
               :  // For construction of filebuffers for cout, cin, cerr, clog et. al.
  3134  0.6967 :  static ios_base::Init __ioinit; /* DCBuffer::getExtractedSize() const total:      1 2.2e-04 */
               :} // namespace std
               :
               :#endif
/* 
 * Total samples for file : "/usr/include/c++/3.2/bits/stl_iterator.h"
 * 
 *   2782  0.6184
 */


               :// Iterators -*- C++ -*-
               :
               :// Copyright (C) 2001, 2002 Free Software Foundation, Inc.
               ://
               :// This file is part of the GNU ISO C++ Library.  This library is free
               :// software; you can redistribute it and/or modify it under the
               :// terms of the GNU General Public License as published by the
               :// Free Software Foundation; either version 2, or (at your option)
               :// any later version.
               :
               :// This library is distributed in the hope that it will be useful,
               :// but WITHOUT ANY WARRANTY; without even the implied warranty of
               :// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
               :// GNU General Public License for more details.
               :
               :// You should have received a copy of the GNU General Public License along
               :// with this library; see the file COPYING.  If not, write to the Free
               :// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,
               :// USA.
               :
               :// As a special exception, you may use this file as part of a free software
               :// library without restriction.  Specifically, if other files instantiate
               :// templates or use macros or inline functions from this file, or you compile
               :// this file and link it with other files to produce an executable, this
               :// file does not by itself cause the resulting executable to be covered by
               :// the GNU General Public License.  This exception does not however
               :// invalidate any other reasons why the executable file might be covered by
               :// the GNU General Public License.
               :
               :/*
               : *
               : * Copyright (c) 1994
               : * Hewlett-Packard Company
               : *
               : * Permission to use, copy, modify, distribute and sell this software
               : * and its documentation for any purpose is hereby granted without fee,
               : * provided that the above copyright notice appear in all copies and
               : * that both that copyright notice and this permission notice appear
               : * in supporting documentation.  Hewlett-Packard Company makes no
               : * representations about the suitability of this software for any
               : * purpose.  It is provided "as is" without express or implied warranty.
               : *
               : *
               : * Copyright (c) 1996-1998
               : * Silicon Graphics Computer Systems, Inc.
               : *
               : * Permission to use, copy, modify, distribute and sell this software
               : * and its documentation for any purpose is hereby granted without fee,
               : * provided that the above copyright notice appear in all copies and
               : * that both that copyright notice and this permission notice appear
               : * in supporting documentation.  Silicon Graphics makes no
               : * representations about the suitability of this software for any
               : * purpose.  It is provided "as is" without express or implied warranty.
               : */
               :
               :/** @file stl_iterator.h
               : *  This is an internal header file, included by other library headers.
               : *  You should not attempt to use it directly.
               : *
               : *  This file implements reverse_iterator, back_insert_iterator,
               : *  front_insert_iterator, insert_iterator, __normal_iterator, and their
               : *  supporting functions and overloaded operators.
               : */
               :
               :#ifndef __GLIBCPP_INTERNAL_ITERATOR_H
               :#define __GLIBCPP_INTERNAL_ITERATOR_H
               :
               :namespace std
               :{
               :  // 24.4.1 Reverse iterators
               :  /**
               :   *  "Bidirectional and random access iterators have corresponding reverse
               :   *  %iterator adaptors that iterate through the data structure in the
               :   *  opposite direction.  They have the same signatures as the corresponding
               :   *  iterators.  The fundamental relation between a reverse %iterator and its
               :   *  corresponding %iterator @c i is established by the identity:
               :   *  @code
               :   *      &*(reverse_iterator(i)) == &*(i - 1)
               :   *  @endcode
               :   *
               :   *  This mapping is dictated by the fact that while there is always a
               :   *  pointer past the end of an array, there might not be a valid pointer
               :   *  before the beginning of an array." [24.4.1]/1,2
               :   *
               :   *  Reverse iterators can be tricky and surprising at first.  Their
               :   *  semantics make sense, however, and the trickiness is a side effect of
               :   *  the requirement that the iterators must be safe.
               :  */
               :  template<typename _Iterator>
               :    class reverse_iterator 
               :    : public iterator<typename iterator_traits<_Iterator>::iterator_category,
               :		      typename iterator_traits<_Iterator>::value_type,
               :		      typename iterator_traits<_Iterator>::difference_type,
               :		      typename iterator_traits<_Iterator>::pointer,
               :                      typename iterator_traits<_Iterator>::reference>
               :    {
               :    protected:
               :      _Iterator current;
               :
               :    public:
               :      typedef _Iterator 				       iterator_type;
               :      typedef typename iterator_traits<_Iterator>::difference_type 	
               :      							       difference_type;
               :      typedef typename iterator_traits<_Iterator>::reference   reference;
               :      typedef typename iterator_traits<_Iterator>::pointer     pointer;
               :
               :    public:
               :      /**
               :       *  The default constructor gives an undefined state to this %iterator.
               :      */
               :      reverse_iterator() { }
               :
               :      /**
               :       *  This %iterator will move in the opposite direction that @p x does.
               :      */
               :      explicit 
               :      reverse_iterator(iterator_type __x) : current(__x) { }
               :
               :      /**
               :       *  The copy constructor is normal.
               :      */
               :      reverse_iterator(const reverse_iterator& __x) 
               :      : current(__x.current) { }
               :
               :      /**
               :       *  A reverse_iterator across other types can be copied in the normal
               :       *  fashion.
               :      */
               :      template<typename _Iter>
               :        reverse_iterator(const reverse_iterator<_Iter>& __x)
               :	: current(__x.base()) { }
               :    
               :      /**
               :       *  @return  @c current, the %iterator used for underlying work.
               :      */
               :      iterator_type 
               :      base() const { return current; }
               :
               :      /**
               :       *  @return  TODO
               :       *
               :       *  @doctodo
               :      */
               :      reference 
               :      operator*() const 
               :      {
               :	_Iterator __tmp = current;
               :	return *--__tmp;
               :      }
               :
               :      /**
               :       *  @return  TODO
               :       *
               :       *  @doctodo
               :      */
               :      pointer 
               :      operator->() const { return &(operator*()); }
               :
               :      /**
               :       *  @return  TODO
               :       *
               :       *  @doctodo
               :      */
               :      reverse_iterator& 
               :      operator++() 
               :      {
               :	--current;
               :	return *this;
               :      }
               :
               :      /**
               :       *  @return  TODO
               :       *
               :       *  @doctodo
               :      */
               :      reverse_iterator 
               :      operator++(int) 
               :      {
               :	reverse_iterator __tmp = *this;
               :	--current;
               :	return __tmp;
               :      }
               :
               :      /**
               :       *  @return  TODO
               :       *
               :       *  @doctodo
               :      */
               :      reverse_iterator& 
               :      operator--() 
               :      {
               :	++current;
               :	return *this;
               :      }
               :
               :      /**
               :       *  @return  TODO
               :       *
               :       *  @doctodo
               :      */
               :      reverse_iterator operator--(int) 
               :      {
               :	reverse_iterator __tmp = *this;
               :	++current;
               :	return __tmp;
               :      }
               :      
               :      /**
               :       *  @return  TODO
               :       *
               :       *  @doctodo
               :      */
               :      reverse_iterator 
               :      operator+(difference_type __n) const 
               :      { return reverse_iterator(current - __n); }
               :
               :      /**
               :       *  @return  TODO
               :       *
               :       *  @doctodo
               :      */
               :      reverse_iterator& 
               :      operator+=(difference_type __n) 
               :      {
               :	current -= __n;
               :	return *this;
               :      }
               :
               :      /**
               :       *  @return  TODO
               :       *
               :       *  @doctodo
               :      */
               :      reverse_iterator 
               :      operator-(difference_type __n) const 
               :      { return reverse_iterator(current + __n); }
               :
               :      /**
               :       *  @return  TODO
               :       *
               :       *  @doctodo
               :      */
               :      reverse_iterator& 
               :      operator-=(difference_type __n) 
               :      {
               :	current += __n;
               :	return *this;
               :      }
               :
               :      /**
               :       *  @return  TODO
               :       *
               :       *  @doctodo
               :      */
               :      reference 
               :      operator[](difference_type __n) const { return *(*this + __n); }  
               :    }; 
               : 
               :  //@{
               :  /**
               :   *  @param  x  A %reverse_iterator.
               :   *  @param  y  A %reverse_iterator.
               :   *  @return  A simple bool.
               :   *
               :   *  Reverse iterators forward many operations to their underlying base()
               :   *  iterators.  Others are implemented in terms of one another.
               :   *
               :  */
               :  template<typename _Iterator>
               :    inline bool 
               :    operator==(const reverse_iterator<_Iterator>& __x, 
               :	       const reverse_iterator<_Iterator>& __y) 
               :    { return __x.base() == __y.base(); }
               :
               :  template<typename _Iterator>
               :    inline bool 
               :    operator<(const reverse_iterator<_Iterator>& __x, 
               :	      const reverse_iterator<_Iterator>& __y) 
               :    { return __y.base() < __x.base(); }
               :
               :  template<typename _Iterator>
               :    inline bool 
               :    operator!=(const reverse_iterator<_Iterator>& __x, 
               :	       const reverse_iterator<_Iterator>& __y) 
               :    { return !(__x == __y); }
               :
               :  template<typename _Iterator>
               :    inline bool 
               :    operator>(const reverse_iterator<_Iterator>& __x, 
               :	      const reverse_iterator<_Iterator>& __y) 
               :    { return __y < __x; }
               :
               :  template<typename _Iterator>
               :    inline bool 
               :    operator<=(const reverse_iterator<_Iterator>& __x, 
               :		const reverse_iterator<_Iterator>& __y) 
               :    { return !(__y < __x); }
               :
               :  template<typename _Iterator>
               :    inline bool 
               :    operator>=(const reverse_iterator<_Iterator>& __x, 
               :	       const reverse_iterator<_Iterator>& __y) 
               :    { return !(__x < __y); }
               :
               :  template<typename _Iterator>
               :    inline typename reverse_iterator<_Iterator>::difference_type
               :    operator-(const reverse_iterator<_Iterator>& __x, 
               :	      const reverse_iterator<_Iterator>& __y) 
               :    { return __y.base() - __x.base(); }
               :
               :  template<typename _Iterator>
               :    inline reverse_iterator<_Iterator> 
               :    operator+(typename reverse_iterator<_Iterator>::difference_type __n,
               :	      const reverse_iterator<_Iterator>& __x) 
               :    { return reverse_iterator<_Iterator>(__x.base() - __n); }
               :  //@}
               :
               :  // 24.4.2.2.1 back_insert_iterator
               :  /**
               :   *  These are output iterators, constructed from a container-of-T.
               :   *  Assigning a T to the iterator appends it to the container using
               :   *  push_back.
               :   *
               :   *  Tip:  Using the back_inserter function to create these iterators can
               :   *  save typing.
               :  */
               :  template<typename _Container>
               :    class back_insert_iterator 
               :    : public iterator<output_iterator_tag, void, void, void, void>
               :    {
               :    protected:
               :      _Container* container;
               :
               :    public:
               :      /// A nested typedef for the type of whatever container you used.
               :      typedef _Container          container_type;
               :      
               :      /// The only way to create this %iterator is with a container.
               :      explicit 
               :      back_insert_iterator(_Container& __x) : container(&__x) { }
               :
               :      /**
               :       *  @param  value  An instance of whatever type
               :       *                 container_type::const_reference is; presumably a
               :       *                 reference-to-const T for container<T>.
               :       *  @return  This %iterator, for chained operations.
               :       *
               :       *  This kind of %iterator doesn't really have a "position" in the
               :       *  container (you can think of the position as being permanently at
               :       *  the end, if you like).  Assigning a value to the %iterator will
               :       *  always append the value to the end of the container.
               :      */
               :      back_insert_iterator&
               :      operator=(typename _Container::const_reference __value) 
               :      { 
               :	container->push_back(__value);
               :	return *this;
               :      }
               :
               :      /// Simply returns *this.
               :      back_insert_iterator& 
               :      operator*() { return *this; }
               :
               :      /// Simply returns *this.  (This %iterator does not "move".)
               :      back_insert_iterator& 
               :      operator++() { return *this; }
               :
               :      /// Simply returns *this.  (This %iterator does not "move".)
               :      back_insert_iterator
               :      operator++(int) { return *this; }
               :    };
               :
               :  /**
               :   *  @param  x  A container of arbitrary type.
               :   *  @return  An instance of back_insert_iterator working on @p x.
               :   *
               :   *  This wrapper function helps in creating back_insert_iterator instances.
               :   *  Typing the name of the %iterator requires knowing the precise full
               :   *  type of the container, which can be tedious and impedes generic
               :   *  programming.  Using this function lets you take advantage of automatic
               :   *  template parameter deduction, making the compiler match the correct
               :   *  types for you.
               :  */
               :  template<typename _Container>
               :    inline back_insert_iterator<_Container> 
               :    back_inserter(_Container& __x) 
               :    { return back_insert_iterator<_Container>(__x); }
               :
               :  /**
               :   *  These are output iterators, constructed from a container-of-T.
               :   *  Assigning a T to the iterator prepends it to the container using
               :   *  push_front.
               :   *
               :   *  Tip:  Using the front_inserter function to create these iterators can
               :   *  save typing.
               :  */
               :  template<typename _Container>
               :    class front_insert_iterator 
               :    : public iterator<output_iterator_tag, void, void, void, void>
               :    {
               :    protected:
               :      _Container* container;
               :
               :    public:
               :      /// A nested typedef for the type of whatever container you used.
               :      typedef _Container          container_type;
               :
               :      /// The only way to create this %iterator is with a container.
               :      explicit front_insert_iterator(_Container& __x) : container(&__x) { }
               :
               :      /**
               :       *  @param  value  An instance of whatever type
               :       *                 container_type::const_reference is; presumably a
               :       *                 reference-to-const T for container<T>.
               :       *  @return  This %iterator, for chained operations.
               :       *
               :       *  This kind of %iterator doesn't really have a "position" in the
               :       *  container (you can think of the position as being permanently at
               :       *  the front, if you like).  Assigning a value to the %iterator will
               :       *  always prepend the value to the front of the container.
               :      */
               :      front_insert_iterator&
               :      operator=(typename _Container::const_reference __value) 
               :      { 
               :	container->push_front(__value);
               :	return *this;
               :      }
               :
               :      /// Simply returns *this.
               :      front_insert_iterator& 
               :      operator*() { return *this; }
               :
               :      /// Simply returns *this.  (This %iterator does not "move".)
               :      front_insert_iterator& 
               :      operator++() { return *this; }
               :
               :      /// Simply returns *this.  (This %iterator does not "move".)
               :      front_insert_iterator 
               :      operator++(int) { return *this; }
               :    };
               :
               :  /**
               :   *  @param  x  A container of arbitrary type.
               :   *  @return  An instance of front_insert_iterator working on @p x.
               :   *
               :   *  This wrapper function helps in creating front_insert_iterator instances.
               :   *  Typing the name of the %iterator requires knowing the precise full
               :   *  type of the container, which can be tedious and impedes generic
               :   *  programming.  Using this function lets you take advantage of automatic
               :   *  template parameter deduction, making the compiler match the correct
               :   *  types for you.
               :  */
               :  template<typename _Container>
               :    inline front_insert_iterator<_Container> 
               :    front_inserter(_Container& __x) 
               :    { return front_insert_iterator<_Container>(__x); }
               :
               :  /**
               :   *  These are output iterators, constructed from a container-of-T.
               :   *  Assigning a T to the iterator inserts it in the container at the
               :   *  %iterator's position, rather than overwriting the value at that
               :   *  position.
               :   *
               :   *  (Sequences will actually insert a @e copy of the value before the
               :   *  %iterator's position.)
               :   *
               :   *  Tip:  Using the inserter function to create these iterators can
               :   *  save typing.
               :  */
               :  template<typename _Container>
               :    class insert_iterator 
               :    : public iterator<output_iterator_tag, void, void, void, void>
               :    {
               :    protected:
               :      _Container* container;
               :      typename _Container::iterator iter;
               :
               :    public:
               :      /// A nested typedef for the type of whatever container you used.
               :      typedef _Container          container_type;
               :      
               :      /**
               :       *  The only way to create this %iterator is with a container and an
               :       *  initial position (a normal %iterator into the container).
               :      */
               :      insert_iterator(_Container& __x, typename _Container::iterator __i) 
               :      : container(&__x), iter(__i) {}
               :   
               :      /**
               :       *  @param  value  An instance of whatever type
               :       *                 container_type::const_reference is; presumably a
               :       *                 reference-to-const T for container<T>.
               :       *  @return  This %iterator, for chained operations.
               :       *
               :       *  This kind of %iterator maintains its own position in the
               :       *  container.  Assigning a value to the %iterator will insert the
               :       *  value into the container at the place before the %iterator.
               :       *
               :       *  The position is maintained such that subsequent assignments will
               :       *  insert values immediately after one another.  For example,
               :       *  @code
               :       *     // vector v contains A and Z
               :       *
               :       *     insert_iterator i (v, ++v.begin());
               :       *     i = 1;
               :       *     i = 2;
               :       *     i = 3;
               :       *
               :       *     // vector v contains A, 1, 2, 3, and Z
               :       *  @endcode
               :      */
               :      insert_iterator&
               :      operator=(const typename _Container::const_reference __value) 
               :      { 
               :	iter = container->insert(iter, __value);
               :	++iter;
               :	return *this;
               :      }
               :
               :      /// Simply returns *this.
               :      insert_iterator& 
               :      operator*() { return *this; }
               :
               :      /// Simply returns *this.  (This %iterator does not "move".)
               :      insert_iterator& 
               :      operator++() { return *this; }
               :
               :      /// Simply returns *this.  (This %iterator does not "move".)
               :      insert_iterator& 
               :      operator++(int) { return *this; }
               :    };
               :  
               :  /**
               :   *  @param  x  A container of arbitrary type.
               :   *  @return  An instance of insert_iterator working on @p x.
               :   *
               :   *  This wrapper function helps in creating insert_iterator instances.
               :   *  Typing the name of the %iterator requires knowing the precise full
               :   *  type of the container, which can be tedious and impedes generic
               :   *  programming.  Using this function lets you take advantage of automatic
               :   *  template parameter deduction, making the compiler match the correct
               :   *  types for you.
               :  */
               :  template<typename _Container, typename _Iterator>
               :    inline insert_iterator<_Container> 
               :    inserter(_Container& __x, _Iterator __i)
               :    {
               :      return insert_iterator<_Container>(__x, 
               :					 typename _Container::iterator(__i));
               :    }
               :} // namespace std
               :
               :namespace __gnu_cxx
               :{  
               :  // This iterator adapter is 'normal' in the sense that it does not
               :  // change the semantics of any of the operators of its iterator
               :  // parameter.  Its primary purpose is to convert an iterator that is
               :  // not a class, e.g. a pointer, into an iterator that is a class.
               :  // The _Container parameter exists solely so that different containers
               :  // using this template can instantiate different types, even if the
               :  // _Iterator parameter is the same.
               :  using std::iterator_traits;
               :  using std::iterator;
               :  template<typename _Iterator, typename _Container>
               :    class __normal_iterator
               :      : public iterator<typename iterator_traits<_Iterator>::iterator_category,
               :                        typename iterator_traits<_Iterator>::value_type,
               :                        typename iterator_traits<_Iterator>::difference_type,
               :                        typename iterator_traits<_Iterator>::pointer,
               :                        typename iterator_traits<_Iterator>::reference>
               :    {
               :    protected:
               :      _Iterator _M_current;
               :      
               :    public:
               :      typedef typename iterator_traits<_Iterator>::difference_type 	
               :      							       difference_type;
               :      typedef typename iterator_traits<_Iterator>::reference   reference;
               :      typedef typename iterator_traits<_Iterator>::pointer     pointer;
               :
               :      __normal_iterator() : _M_current(_Iterator()) { }
               :
               :      explicit 
               :      __normal_iterator(const _Iterator& __i) : _M_current(__i) { }
               :
               :      // Allow iterator to const_iterator conversion
               :      template<typename _Iter>
               :      inline __normal_iterator(const __normal_iterator<_Iter, _Container>& __i)
               :	: _M_current(__i.base()) { }
               :
               :      // Forward iterator requirements
               :      reference
     1 2.2e-04 :      operator*() const { return *_M_current; } /* std::_Vector_alloc_base<std::pair<std::string, std::string>, std::allocator<std::pair<std::string, std::string> >, true>::_Vector_alloc_base(std::allocator<std::pair<std::string, std::string> > const&) total:      1 2.2e-04 */
               :      
               :      pointer
               :      operator->() const { return _M_current; }
               :      
               :      __normal_iterator&
               :      operator++() { ++_M_current; return *this; }
               :      
               :      __normal_iterator
               :      operator++(int) { return __normal_iterator(_M_current++); }
               :      
               :      // Bidirectional iterator requirements
               :      __normal_iterator&
               :      operator--() { --_M_current; return *this; }
               :      
               :      __normal_iterator
               :      operator--(int) { return __normal_iterator(_M_current--); }
               :      
               :      // Random access iterator requirements
               :      reference
               :      operator[](const difference_type& __n) const
               :      { return _M_current[__n]; }
               :      
               :      __normal_iterator&
               :      operator+=(const difference_type& __n)
               :      { _M_current += __n; return *this; }
               :
               :      __normal_iterator
               :      operator+(const difference_type& __n) const
  2781  0.6182 :      { return __normal_iterator(_M_current + __n); }
               :      
               :      __normal_iterator&
               :      operator-=(const difference_type& __n)
               :      { _M_current -= __n; return *this; }
               :      
               :      __normal_iterator
               :      operator-(const difference_type& __n) const
               :      { return __normal_iterator(_M_current - __n); }
               :      
               :      const _Iterator& 
               :      base() const { return _M_current; }
               :    };
               :
               :  // Note: In what follows, the left- and right-hand-side iterators are
               :  // allowed to vary in types (conceptually in cv-qualification) so that
               :  // comparaison between cv-qualified and non-cv-qualified iterators be
               :  // valid.  However, the greedy and unfriendly operators in std::rel_ops
               :  // will make overload resolution ambiguous (when in scope) if we don't
               :  // provide overloads whose operands are of the same type.  Can someone
               :  // remind me what generic programming is about? -- Gaby
               :  
               :  // Forward iterator requirements
               :  template<typename _IteratorL, typename _IteratorR, typename _Container>
               :  inline bool
               :  operator==(const __normal_iterator<_IteratorL, _Container>& __lhs,
               :	     const __normal_iterator<_IteratorR, _Container>& __rhs)
               :  { return __lhs.base() == __rhs.base(); }
               :
               :  template<typename _Iterator, typename _Container>
               :  inline bool
               :  operator==(const __normal_iterator<_Iterator, _Container>& __lhs,
               :             const __normal_iterator<_Iterator, _Container>& __rhs)
               :  { return __lhs.base() == __rhs.base(); }
               :
               :  template<typename _IteratorL, typename _IteratorR, typename _Container>
               :  inline bool
               :  operator!=(const __normal_iterator<_IteratorL, _Container>& __lhs,
               :	     const __normal_iterator<_IteratorR, _Container>& __rhs)
               :  { return __lhs.base() != __rhs.base(); }
               :
               :  template<typename _Iterator, typename _Container>
               :  inline bool
               :  operator!=(const __normal_iterator<_Iterator, _Container>& __lhs,
               :             const __normal_iterator<_Iterator, _Container>& __rhs)
               :  { return __lhs.base() != __rhs.base(); }
               :
               :  // Random access iterator requirements
               :  template<typename _IteratorL, typename _IteratorR, typename _Container>
               :  inline bool 
               :  operator<(const __normal_iterator<_IteratorL, _Container>& __lhs,
               :	    const __normal_iterator<_IteratorR, _Container>& __rhs)
               :  { return __lhs.base() < __rhs.base(); }
               :
               :  template<typename _Iterator, typename _Container>
               :  inline bool
               :  operator<(const __normal_iterator<_Iterator, _Container>& __lhs,
               :             const __normal_iterator<_Iterator, _Container>& __rhs)
               :  { return __lhs.base() < __rhs.base(); }
               :
               :  template<typename _IteratorL, typename _IteratorR, typename _Container>
               :  inline bool
               :  operator>(const __normal_iterator<_IteratorL, _Container>& __lhs,
               :	    const __normal_iterator<_IteratorR, _Container>& __rhs)
               :  { return __lhs.base() > __rhs.base(); }
               :
               :  template<typename _Iterator, typename _Container>
               :  inline bool
               :  operator>(const __normal_iterator<_Iterator, _Container>& __lhs,
               :	    const __normal_iterator<_Iterator, _Container>& __rhs)
               :  { return __lhs.base() > __rhs.base(); }
               :
               :  template<typename _IteratorL, typename _IteratorR, typename _Container>
               :  inline bool
               :  operator<=(const __normal_iterator<_IteratorL, _Container>& __lhs,
               :	     const __normal_iterator<_IteratorR, _Container>& __rhs)
               :  { return __lhs.base() <= __rhs.base(); }
               :
               :  template<typename _Iterator, typename _Container>
               :  inline bool
               :  operator<=(const __normal_iterator<_Iterator, _Container>& __lhs,
               :	     const __normal_iterator<_Iterator, _Container>& __rhs)
               :  { return __lhs.base() <= __rhs.base(); }
               :
               :  template<typename _IteratorL, typename _IteratorR, typename _Container>
               :  inline bool
               :  operator>=(const __normal_iterator<_IteratorL, _Container>& __lhs,
               :	     const __normal_iterator<_IteratorR, _Container>& __rhs)
               :  { return __lhs.base() >= __rhs.base(); }
               :
               :  template<typename _Iterator, typename _Container>
               :  inline bool
               :  operator>=(const __normal_iterator<_Iterator, _Container>& __lhs,
               :	     const __normal_iterator<_Iterator, _Container>& __rhs)
               :  { return __lhs.base() >= __rhs.base(); }
               :
               :  // _GLIBCPP_RESOLVE_LIB_DEFECTS
               :  // According to the resolution of DR179 not only the various comparison
               :  // operators but also operator- must accept mixed iterator/const_iterator
               :  // parameters.
               :  template<typename _IteratorL, typename _IteratorR, typename _Container>
               :  inline typename __normal_iterator<_IteratorL, _Container>::difference_type
               :  operator-(const __normal_iterator<_IteratorL, _Container>& __lhs,
               :	     const __normal_iterator<_IteratorR, _Container>& __rhs)
               :  { return __lhs.base() - __rhs.base(); }
               :
               :  template<typename _Iterator, typename _Container>
               :  inline __normal_iterator<_Iterator, _Container>
               :  operator+(typename __normal_iterator<_Iterator, _Container>::difference_type __n,
               :	    const __normal_iterator<_Iterator, _Container>& __i)
               :  { return __normal_iterator<_Iterator, _Container>(__i.base() + __n); }
               :} // namespace __gnu_cxx
               :
               :#endif 
               :
               :// Local Variables:
               :// mode:C++
               :// End:
/* 
 * Total samples for file : "/usr/include/c++/3.2/bits/stl_pair.h"
 * 
 *   2509  0.5578
 */


               :// Pair implementation -*- C++ -*-
               :
               :// Copyright (C) 2001 Free Software Foundation, Inc.
               ://
               :// This file is part of the GNU ISO C++ Library.  This library is free
               :// software; you can redistribute it and/or modify it under the
               :// terms of the GNU General Public License as published by the
               :// Free Software Foundation; either version 2, or (at your option)
               :// any later version.
               :
               :// This library is distributed in the hope that it will be useful,
               :// but WITHOUT ANY WARRANTY; without even the implied warranty of
               :// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
               :// GNU General Public License for more details.
               :
               :// You should have received a copy of the GNU General Public License along
               :// with this library; see the file COPYING.  If not, write to the Free
               :// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,
               :// USA.
               :
               :// As a special exception, you may use this file as part of a free software
               :// library without restriction.  Specifically, if other files instantiate
               :// templates or use macros or inline functions from this file, or you compile
               :// this file and link it with other files to produce an executable, this
               :// file does not by itself cause the resulting executable to be covered by
               :// the GNU General Public License.  This exception does not however
               :// invalidate any other reasons why the executable file might be covered by
               :// the GNU General Public License.
               :
               :/*
               : *
               : * Copyright (c) 1994
               : * Hewlett-Packard Company
               : *
               : * Permission to use, copy, modify, distribute and sell this software
               : * and its documentation for any purpose is hereby granted without fee,
               : * provided that the above copyright notice appear in all copies and
               : * that both that copyright notice and this permission notice appear
               : * in supporting documentation.  Hewlett-Packard Company makes no
               : * representations about the suitability of this software for any
               : * purpose.  It is provided "as is" without express or implied warranty.
               : *
               : *
               : * Copyright (c) 1996,1997
               : * Silicon Graphics Computer Systems, Inc.
               : *
               : * Permission to use, copy, modify, distribute and sell this software
               : * and its documentation for any purpose is hereby granted without fee,
               : * provided that the above copyright notice appear in all copies and
               : * that both that copyright notice and this permission notice appear
               : * in supporting documentation.  Silicon Graphics makes no
               : * representations about the suitability of this software for any
               : * purpose.  It is provided "as is" without express or implied warranty.
               : */
               :
               :/** @file stl_pair.h
               : *  This is an internal header file, included by other library headers.
               : *  You should not attempt to use it directly.
               : */
               :
               :#ifndef __GLIBCPP_INTERNAL_PAIR_H
               :#define __GLIBCPP_INTERNAL_PAIR_H
               :
               :namespace std
               :{
               :
               :/// pair holds two objects of arbitrary type.
               :template <class _T1, class _T2>
               :struct pair {
               :  typedef _T1 first_type;    ///<  @c first_type is the first bound type
               :  typedef _T2 second_type;   ///<  @c second_type is the second bound type
               :
               :  _T1 first;                 ///< @c first is a copy of the first object
               :  _T2 second;                ///< @c second is a copy of the second object
               :#ifdef _GLIBCPP_RESOLVE_LIB_DEFECTS
               ://265.  std::pair::pair() effects overly restrictive
               :  /** The default constructor creates @c first and @c second using their
               :   *  respective default constructors.  */
               :  pair() : first(), second() {}
               :#else
               :  pair() : first(_T1()), second(_T2()) {}
               :#endif
               :  /** Two objects may be passed to a @c pair constructor to be copied.  */
  2509  0.5578 :  pair(const _T1& __a, const _T2& __b) : first(__a), second(__b) {} /* std::map<std::string, DCBuffer*, std::less<std::string>, std::allocator<std::pair<std::string const, DCBuffer*> > >::insert(std::_Rb_tree_iterator<std::pair<std::string const, DCBuffer*>, std::pair<std::string const, DCBuffer*>&, std::pair<std::string const, DCBuffer*>*>, std::pair<std::string const, DCBuffer*> const&) total:   8207  1.8244 */
               :
               :  /** There is also a templated copy ctor for the @c pair class itself.  */
               :  template <class _U1, class _U2>
               :  pair(const pair<_U1, _U2>& __p) : first(__p.first), second(__p.second) {}
               :};
               :
               :/// Two pairs of the same type are equal iff their members are equal.
               :template <class _T1, class _T2>
               :inline bool operator==(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
               :{ 
               :  return __x.first == __y.first && __x.second == __y.second; 
               :}
               :
               :/// <http://gcc.gnu.org/onlinedocs/libstdc++/20_util/howto.html#pairlt>
               :template <class _T1, class _T2>
               :inline bool operator<(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
               :{ 
               :  return __x.first < __y.first || 
               :         (!(__y.first < __x.first) && __x.second < __y.second); 
               :}
               :
               :/// Uses @c operator== to find the result.
               :template <class _T1, class _T2>
               :inline bool operator!=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y) {
               :  return !(__x == __y);
               :}
               :
               :/// Uses @c operator< to find the result.
               :template <class _T1, class _T2>
               :inline bool operator>(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y) {
               :  return __y < __x;
               :}
               :
               :/// Uses @c operator< to find the result.
               :template <class _T1, class _T2>
               :inline bool operator<=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y) {
               :  return !(__y < __x);
               :}
               :
               :/// Uses @c operator< to find the result.
               :template <class _T1, class _T2>
               :inline bool operator>=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y) {
               :  return !(__x < __y);
               :}
               :
               :/**
               : *  @brief A convenience wrapper for creating a pair from two objects.
               : *  @param  x  The first object.
               : *  @param  y  The second object.
               : *  @return   A newly-constructed pair<> object of the appropriate type.
               : *
               : *  The standard requires that the objects be passed by reference-to-const,
               : *  but LWG issue #181 says they should be passed by const value.  We follow
               : *  the LWG by default.
               :*/
               :template <class _T1, class _T2>
               :#ifdef _GLIBCPP_RESOLVE_LIB_DEFECTS
               ://181.  make_pair() unintended behavior
               :inline pair<_T1, _T2> make_pair(_T1 __x, _T2 __y)
               :#else
               :inline pair<_T1, _T2> make_pair(const _T1& __x, const _T2& __y)
               :#endif
               :{
               :  return pair<_T1, _T2>(__x, __y);
               :}
               :
               :} // namespace std
               :
               :#endif /* __GLIBCPP_INTERNAL_PAIR_H */
               :
               :// Local Variables:
               :// mode:C++
               :// End:
/* 
 * Total samples for file : "/usr/include/c++/3.2/bits/stl_alloc.h"
 * 
 *   2178  0.4842
 */


               :// Allocators -*- C++ -*-
               :
               :// Copyright (C) 2001, 2002 Free Software Foundation, Inc.
               ://
               :// This file is part of the GNU ISO C++ Library.  This library is free
               :// software; you can redistribute it and/or modify it under the
               :// terms of the GNU General Public License as published by the
               :// Free Software Foundation; either version 2, or (at your option)
               :// any later version.
               :
               :// This library is distributed in the hope that it will be useful,
               :// but WITHOUT ANY WARRANTY; without even the implied warranty of
               :// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
               :// GNU General Public License for more details.
               :
               :// You should have received a copy of the GNU General Public License along
               :// with this library; see the file COPYING.  If not, write to the Free
               :// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,
               :// USA.
               :
               :// As a special exception, you may use this file as part of a free software
               :// library without restriction.  Specifically, if other files instantiate
               :// templates or use macros or inline functions from this file, or you compile
               :// this file and link it with other files to produce an executable, this
               :// file does not by itself cause the resulting executable to be covered by
               :// the GNU General Public License.  This exception does not however
               :// invalidate any other reasons why the executable file might be covered by
               :// the GNU General Public License.
               :
               :/*
               : * Copyright (c) 1996-1997
               : * Silicon Graphics Computer Systems, Inc.
               : *
               : * Permission to use, copy, modify, distribute and sell this software
               : * and its documentation for any purpose is hereby granted without fee,
               : * provided that the above copyright notice appear in all copies and
               : * that both that copyright notice and this permission notice appear
               : * in supporting documentation.  Silicon Graphics makes no
               : * representations about the suitability of this software for any
               : * purpose.  It is provided "as is" without express or implied warranty.
               : */
               :
               :/** @file stl_alloc.h
               : *  This is an internal header file, included by other library headers.
               : *  You should not attempt to use it directly.
               : */
               :
               :#ifndef __GLIBCPP_INTERNAL_ALLOC_H
               :#define __GLIBCPP_INTERNAL_ALLOC_H
               :
               :/**
               : *  @defgroup Allocators Memory Allocators
               : *  @if maint
               : *  stl_alloc.h implements some node allocators.  These are NOT the same as
               : *  allocators in the C++ standard, nor in the original H-P STL.  They do not
               : *  encapsulate different pointer types; we assume that there is only one
               : *  pointer type.  The C++ standard allocators are intended to allocate
               : *  individual objects, not pools or arenas.
               : *
               : *  In this file allocators are of two different styles:  "standard" and
               : *  "SGI" (quotes included).  "Standard" allocators conform to 20.4.  "SGI"
               : *  allocators differ in AT LEAST the following ways (add to this list as you
               : *  discover them):
               : *
               : *   - "Standard" allocate() takes two parameters (n_count,hint=0) but "SGI"
               : *     allocate() takes one paramter (n_size).
               : *   - Likewise, "standard" deallocate()'s argument is a count, but in "SGI"
               : *     is a byte size.
               : *   - max_size(), construct(), and destroy() are missing in "SGI" allocators.
               : *   - reallocate(p,oldsz,newsz) is added in "SGI", and behaves as
               : *     if p=realloc(p,newsz).
               : *
               : *  "SGI" allocators may be wrapped in __allocator to convert the interface
               : *  into a "standard" one.
               : *  @endif
               : *
               : *  @note The @c reallocate member functions have been deprecated for 3.2
               : *        and will be removed in 3.4.  You must define @c _GLIBCPP_DEPRECATED
               : *        to make this visible in 3.2; see c++config.h.
               : *
               : *  The canonical description of these classes is in docs/html/ext/howto.html
               : *  or online at http://gcc.gnu.org/onlinedocs/libstdc++/ext/howto.html#3
               :*/
               :
               :#include <cstddef>
               :#include <cstdlib>
               :#include <cstring>
               :#include <cassert>
               :#include <bits/functexcept.h>   // For __throw_bad_alloc
               :#include <bits/stl_threads.h>
               :
               :#include <bits/atomicity.h>
               :
               :namespace std
               :{
               :  /**
               :   *  @if maint
               :   *  A new-based allocator, as required by the standard.  Allocation and
               :   *  deallocation forward to global new and delete.  "SGI" style, minus
               :   *  reallocate().
               :   *  @endif
               :   *  (See @link Allocators allocators info @endlink for more.)
               :   */
               :  class __new_alloc
               :  {
               :  public:
               :    static void*
               :    allocate(size_t __n)
               :    { return ::operator new(__n); }
               :
               :    static void
               :    deallocate(void* __p, size_t)
               :    { ::operator delete(__p); }
               :  };
               :
               :
               :  /**
               :   *  @if maint
               :   *  A malloc-based allocator.  Typically slower than the
               :   *  __default_alloc_template (below).  Typically thread-safe and more
               :   *  storage efficient.  The template argument is unused and is only present
               :   *  to permit multiple instantiations (but see __default_alloc_template
               :   *  for caveats).  "SGI" style, plus __set_malloc_handler for OOM conditions.
               :   *  @endif
               :   *  (See @link Allocators allocators info @endlink for more.)
               :   */
               :  template<int __inst>
               :    class __malloc_alloc_template
               :    {
               :    private:
               :      static void* _S_oom_malloc(size_t);
               :
               :      // _GLIBCPP_DEPRECATED
               :      static void* _S_oom_realloc(void*, size_t);
               :
               :      static void (* __malloc_alloc_oom_handler)();
               :
               :    public:
               :      static void*
               :      allocate(size_t __n)
               :      {
               :        void* __result = malloc(__n);
               :        if (__builtin_expect(__result == 0, 0))
               :	  __result = _S_oom_malloc(__n);
               :        return __result;
               :      }
               :
               :      static void
               :      deallocate(void* __p, size_t /* __n */)
               :      { free(__p); }
               :
               :      // _GLIBCPP_DEPRECATED
               :      static void*
               :      reallocate(void* __p, size_t /* old_sz */, size_t __new_sz)
               :      {
               :        void* __result = realloc(__p, __new_sz);
               :        if (__builtin_expect(__result == 0, 0))
               :          __result = _S_oom_realloc(__p, __new_sz);
               :        return __result;
               :      }
               :
               :      static void (* __set_malloc_handler(void (*__f)()))()
               :      {
               :        void (* __old)() = __malloc_alloc_oom_handler;
               :        __malloc_alloc_oom_handler = __f;
               :        return __old;
               :      }
               :    };
               :
               :  // malloc_alloc out-of-memory handling
               :  template<int __inst>
               :    void (* __malloc_alloc_template<__inst>::__malloc_alloc_oom_handler)() = 0;
               :
               :  template<int __inst>
               :    void*
               :    __malloc_alloc_template<__inst>::
               :    _S_oom_malloc(size_t __n)
               :    {
               :      void (* __my_malloc_handler)();
               :      void* __result;
               :
               :      for (;;)
               :        {
               :          __my_malloc_handler = __malloc_alloc_oom_handler;
               :          if (__builtin_expect(__my_malloc_handler == 0, 0))
               :            __throw_bad_alloc();
               :          (*__my_malloc_handler)();
               :          __result = malloc(__n);
               :          if (__result)
               :            return __result;
               :        }
               :    }
               :
               :  // _GLIBCPP_DEPRECATED
               :  template<int __inst>
               :    void*
               :    __malloc_alloc_template<__inst>::
               :    _S_oom_realloc(void* __p, size_t __n)
               :    {
               :      void (* __my_malloc_handler)();
               :      void* __result;
               :
               :      for (;;)
               :        {
               :          __my_malloc_handler = __malloc_alloc_oom_handler;
               :          if (__builtin_expect(__my_malloc_handler == 0, 0))
               :            __throw_bad_alloc();
               :          (*__my_malloc_handler)();
               :          __result = realloc(__p, __n);
               :          if (__result)
               :            return __result;
               :        }
               :    }
               :
               :  // Should not be referenced within the library anymore.
               :  typedef __new_alloc                 __mem_interface;
               :
               :  /**
               :   *  @if maint
               :   *  This is used primarily (only?) in _Alloc_traits and other places to
               :   *  help provide the _Alloc_type typedef.  All it does is forward the
               :   *  requests after some minimal checking.
               :   *
               :   *  This is neither "standard"-conforming nor "SGI".  The _Alloc parameter
               :   *  must be "SGI" style.
               :   *  @endif
               :   *  (See @link Allocators allocators info @endlink for more.)
               :   */
               :  template<typename _Tp, typename _Alloc>
               :    class __simple_alloc
               :    {
               :    public:
               :      static _Tp*
               :      allocate(size_t __n)
               :      {
               :	_Tp* __ret = 0;
               :	if (__n)
               :	  __ret = static_cast<_Tp*>(_Alloc::allocate(__n * sizeof(_Tp)));
               :	return __ret;
               :      }
               :  
               :      static _Tp*
               :      allocate()
               :      { return (_Tp*) _Alloc::allocate(sizeof (_Tp)); }
               :  
               :      static void
               :      deallocate(_Tp* __p, size_t __n)
  2178  0.4842 :      { if (0 != __n) _Alloc::deallocate(__p, __n * sizeof (_Tp)); } /* std::__simple_alloc<std::_Rb_tree_node<std::pair<std::string const, Rectangle*> >, std::__default_alloc_template<true, 0> >::deallocate(std::_Rb_tree_node<std::pair<std::string const, Rectangle*> >*, unsigned int) total:   2178  0.4842 */
               :  
               :      static void
               :      deallocate(_Tp* __p)
               :      { _Alloc::deallocate(__p, sizeof (_Tp)); }
               :    };
               :
               :
               :  /**
               :   *  @if maint
               :   *  An adaptor for an underlying allocator (_Alloc) to check the size
               :   *  arguments for debugging.  Errors are reported using assert; these
               :   *  checks can be disabled via NDEBUG, but the space penalty is still
               :   *  paid, therefore it is far better to just use the underlying allocator
               :   *  by itelf when no checking is desired.
               :   *
               :   *  "There is some evidence that this can confuse Purify." - SGI comment
               :   *
               :   *  This adaptor is "SGI" style.  The _Alloc parameter must also be "SGI".
               :   *  @endif
               :   *  (See @link Allocators allocators info @endlink for more.)
               :   */
               :  template<typename _Alloc>
               :    class __debug_alloc
               :    {
               :    private:
               :      // Size of space used to store size.  Note that this must be
               :      // large enough to preserve alignment.
               :      enum {_S_extra = 8};
               :
               :    public:
               :      static void*
               :      allocate(size_t __n)
               :      {
               :        char* __result = (char*)_Alloc::allocate(__n + (int) _S_extra);
               :        *(size_t*)__result = __n;
               :        return __result + (int) _S_extra;
               :      }
               :
               :      static void
               :      deallocate(void* __p, size_t __n)
               :      {
               :        char* __real_p = (char*)__p - (int) _S_extra;
               :        assert(*(size_t*)__real_p == __n);
               :        _Alloc::deallocate(__real_p, __n + (int) _S_extra);
               :      }
               :
               :      // _GLIBCPP_DEPRECATED
               :      static void*
               :      reallocate(void* __p, size_t __old_sz, size_t __new_sz)
               :      {
               :        char* __real_p = (char*)__p - (int) _S_extra;
               :        assert(*(size_t*)__real_p == __old_sz);
               :        char* __result = (char*) _Alloc::reallocate(__real_p, 
               :						    __old_sz + (int) _S_extra,
               :						    __new_sz + (int) _S_extra);
               :        *(size_t*)__result = __new_sz;
               :        return __result + (int) _S_extra;
               :      }
               :    };
               :
               :
               :  /**
               :   *  @if maint
               :   *  Default node allocator.  "SGI" style.  Uses various allocators to
               :   *  fulfill underlying requests (and makes as few requests as possible
               :   *  when in default high-speed pool mode).
               :   *
               :   *  Important implementation properties:
               :   *  0. If globally mandated, then allocate objects from __new_alloc
               :   *  1. If the clients request an object of size > _MAX_BYTES, the resulting
               :   *     object will be obtained directly from __new_alloc
               :   *  2. In all other cases, we allocate an object of size exactly
               :   *     _S_round_up(requested_size).  Thus the client has enough size
               :   *     information that we can return the object to the proper free list
               :   *     without permanently losing part of the object.
               :   *
               :   *  The first template parameter specifies whether more than one thread may
               :   *  use this allocator.  It is safe to allocate an object from one instance
               :   *  of a default_alloc and deallocate it with another one.  This effectively
               :   *  transfers its ownership to the second one.  This may have undesirable
               :   *  effects on reference locality.
               :   *
               :   *  The second parameter is unused and serves only to allow the creation of
               :   *  multiple default_alloc instances.  Note that containers built on different
               :   *  allocator instances have different types, limiting the utility of this
               :   *  approach.  If you do not wish to share the free lists with the main
               :   *  default_alloc instance, instantiate this with a non-zero __inst.
               :   *
               :   *  @endif
               :   *  (See @link Allocators allocators info @endlink for more.)
               :   */
               :  template<bool __threads, int __inst>
               :    class __default_alloc_template
               :    {
               :    private:
               :      enum {_ALIGN = 8};
               :      enum {_MAX_BYTES = 128};
               :      enum {_NFREELISTS = _MAX_BYTES / _ALIGN};
               :
               :      union _Obj
               :      {
               :        union _Obj* _M_free_list_link;
               :        char        _M_client_data[1];    // The client sees this.
               :      };
               :
               :      static _Obj* volatile         _S_free_list[_NFREELISTS];
               :
               :      // Chunk allocation state.
               :      static char*                  _S_start_free;
               :      static char*                  _S_end_free;
               :      static size_t                 _S_heap_size;
               :
               :      static _STL_mutex_lock        _S_node_allocator_lock;
               :
               :      static size_t
               :      _S_round_up(size_t __bytes)
               :      { return (((__bytes) + (size_t) _ALIGN-1) & ~((size_t) _ALIGN - 1)); }
               :
               :      static size_t
               :      _S_freelist_index(size_t __bytes)
               :      { return (((__bytes) + (size_t)_ALIGN - 1)/(size_t)_ALIGN - 1); }
               :
               :      // Returns an object of size __n, and optionally adds to size __n
               :      // free list.
               :      static void*
               :      _S_refill(size_t __n);
               :
               :      // Allocates a chunk for nobjs of size size.  nobjs may be reduced
               :      // if it is inconvenient to allocate the requested number.
               :      static char*
               :      _S_chunk_alloc(size_t __size, int& __nobjs);
               :
               :      // It would be nice to use _STL_auto_lock here.  But we need a
               :      // test whether threads are in use.
               :      struct _Lock
               :      {
               :        _Lock() { if (__threads) _S_node_allocator_lock._M_acquire_lock(); }
               :        ~_Lock() { if (__threads) _S_node_allocator_lock._M_release_lock(); }
               :      } __attribute__ ((__unused__));
               :      friend struct _Lock;
               :
               :      static _Atomic_word _S_force_new;
               :
               :    public:
               :      // __n must be > 0
               :      static void*
               :      allocate(size_t __n)
               :      {
               :	void* __ret = 0;
               :
               :	// If there is a race through here, assume answer from getenv
               :	// will resolve in same direction.  Inspired by techniques
               :	// to efficiently support threading found in basic_string.h.
               :	if (_S_force_new == 0)
               :	  {
               :	    if (getenv("GLIBCPP_FORCE_NEW"))
               :	      __atomic_add(&_S_force_new, 1);
               :	    else
               :	      __atomic_add(&_S_force_new, -1);
               :	    // Trust but verify...
               :	    assert(_S_force_new != 0);
               :	  }
               :
               :	if ((__n > (size_t) _MAX_BYTES) || (_S_force_new > 0))
               :	  __ret = __new_alloc::allocate(__n);
               :	else
               :	  {
               :	    _Obj* volatile* __my_free_list = _S_free_list
               :	      + _S_freelist_index(__n);
               :	    // Acquire the lock here with a constructor call.  This
               :	    // ensures that it is released in exit or during stack
               :	    // unwinding.
               :	    _Lock __lock_instance;
               :	    _Obj* __restrict__ __result = *__my_free_list;
               :	    if (__builtin_expect(__result == 0, 0))
               :	      __ret = _S_refill(_S_round_up(__n));
               :	    else
               :	      {
               :		*__my_free_list = __result -> _M_free_list_link;
               :		__ret = __result;
               :	      }	    
               :	    if (__builtin_expect(__ret == 0, 0))
               :	      __throw_bad_alloc();
               :	  }
               :	return __ret;
               :      }
               :
               :      // __p may not be 0
               :      static void
               :      deallocate(void* __p, size_t __n)
               :      {
               :	if ((__n > (size_t) _MAX_BYTES) || (_S_force_new > 0))
               :	  __new_alloc::deallocate(__p, __n);
               :	else
               :	  {
               :	    _Obj* volatile*  __my_free_list = _S_free_list
               :	      + _S_freelist_index(__n);
               :	    _Obj* __q = (_Obj*)__p;
               :
               :	    // Acquire the lock here with a constructor call.  This
               :	    // ensures that it is released in exit or during stack
               :	    // unwinding.
               :	    _Lock __lock_instance;
               :	    __q -> _M_free_list_link = *__my_free_list;
               :	    *__my_free_list = __q;
               :	  }
               :      }
               :
               :      // _GLIBCPP_DEPRECATED
               :      static void*
               :      reallocate(void* __p, size_t __old_sz, size_t __new_sz);
               :    };
               :
               :  template<bool __threads, int __inst> _Atomic_word
               :  __default_alloc_template<__threads, __inst>::_S_force_new = 0;
               :
               :  template<bool __threads, int __inst>
               :    inline bool
               :    operator==(const __default_alloc_template<__threads,__inst>&,
               :               const __default_alloc_template<__threads,__inst>&)
               :    { return true; }
               :
               :  template<bool __threads, int __inst>
               :    inline bool
               :    operator!=(const __default_alloc_template<__threads,__inst>&,
               :               const __default_alloc_template<__threads,__inst>&)
               :    { return false; }
               :
               :
               :  // We allocate memory in large chunks in order to avoid fragmenting the
               :  // heap too much.  We assume that __size is properly aligned.  We hold
               :  // the allocation lock.
               :  template<bool __threads, int __inst>
               :    char*
               :    __default_alloc_template<__threads, __inst>::
               :    _S_chunk_alloc(size_t __size, int& __nobjs)
               :    {
               :      char* __result;
               :      size_t __total_bytes = __size * __nobjs;
               :      size_t __bytes_left = _S_end_free - _S_start_free;
               :
               :      if (__bytes_left >= __total_bytes)
               :        {
               :          __result = _S_start_free;
               :          _S_start_free += __total_bytes;
               :          return __result ;
               :        }
               :      else if (__bytes_left >= __size)
               :        {
               :          __nobjs = (int)(__bytes_left/__size);
               :          __total_bytes = __size * __nobjs;
               :          __result = _S_start_free;
               :          _S_start_free += __total_bytes;
               :          return __result;
               :        }
               :      else
               :        {
               :          size_t __bytes_to_get =
               :            2 * __total_bytes + _S_round_up(_S_heap_size >> 4);
               :          // Try to make use of the left-over piece.
               :          if (__bytes_left > 0)
               :            {
               :              _Obj* volatile* __my_free_list =
               :                _S_free_list + _S_freelist_index(__bytes_left);
               :
               :              ((_Obj*)_S_start_free) -> _M_free_list_link = *__my_free_list;
               :              *__my_free_list = (_Obj*)_S_start_free;
               :            }
               :          _S_start_free = (char*) __new_alloc::allocate(__bytes_to_get);
               :          if (_S_start_free == 0)
               :            {
               :              size_t __i;
               :              _Obj* volatile* __my_free_list;
               :              _Obj* __p;
               :              // Try to make do with what we have.  That can't hurt.  We
               :              // do not try smaller requests, since that tends to result
               :              // in disaster on multi-process machines.
               :              __i = __size;
               :              for (; __i <= (size_t) _MAX_BYTES; __i += (size_t) _ALIGN)
               :                {
               :                  __my_free_list = _S_free_list + _S_freelist_index(__i);
               :                  __p = *__my_free_list;
               :                  if (__p != 0)
               :                    {
               :                      *__my_free_list = __p -> _M_free_list_link;
               :                      _S_start_free = (char*)__p;
               :                      _S_end_free = _S_start_free + __i;
               :                      return _S_chunk_alloc(__size, __nobjs);
               :                      // Any leftover piece will eventually make it to the
               :                      // right free list.
               :                    }
               :                }
               :              _S_end_free = 0;        // In case of exception.
               :              _S_start_free = (char*)__new_alloc::allocate(__bytes_to_get);
               :              // This should either throw an exception or remedy the situation.
               :              // Thus we assume it succeeded.
               :            }
               :          _S_heap_size += __bytes_to_get;
               :          _S_end_free = _S_start_free + __bytes_to_get;
               :          return _S_chunk_alloc(__size, __nobjs);
               :        }
               :    }
               :
               :
               :  // Returns an object of size __n, and optionally adds to "size
               :  // __n"'s free list.  We assume that __n is properly aligned.  We
               :  // hold the allocation lock.
               :  template<bool __threads, int __inst>
               :    void*
               :    __default_alloc_template<__threads, __inst>::_S_refill(size_t __n)
               :    {
               :      int __nobjs = 20;
               :      char* __chunk = _S_chunk_alloc(__n, __nobjs);
               :      _Obj* volatile* __my_free_list;
               :      _Obj* __result;
               :      _Obj* __current_obj;
               :      _Obj* __next_obj;
               :      int __i;
               :
               :      if (1 == __nobjs)
               :        return __chunk;
               :      __my_free_list = _S_free_list + _S_freelist_index(__n);
               :
               :      // Build free list in chunk.
               :      __result = (_Obj*)__chunk;
               :      *__my_free_list = __next_obj = (_Obj*)(__chunk + __n);
               :      for (__i = 1; ; __i++)
               :        {
               :	  __current_obj = __next_obj;
               :          __next_obj = (_Obj*)((char*)__next_obj + __n);
               :	  if (__nobjs - 1 == __i)
               :	    {
               :	      __current_obj -> _M_free_list_link = 0;
               :	      break;
               :	    }
               :	  else
               :	    __current_obj -> _M_free_list_link = __next_obj;
               :	}
               :      return __result;
               :    }
               :
               :
               :  // _GLIBCPP_DEPRECATED
               :  template<bool threads, int inst>
               :    void*
               :    __default_alloc_template<threads, inst>::
               :    reallocate(void* __p, size_t __old_sz, size_t __new_sz)
               :    {
               :      void* __result;
               :      size_t __copy_sz;
               :
               :      if (__old_sz > (size_t) _MAX_BYTES && __new_sz > (size_t) _MAX_BYTES)
               :        return(realloc(__p, __new_sz));
               :      if (_S_round_up(__old_sz) == _S_round_up(__new_sz))
               :        return(__p);
               :      __result = allocate(__new_sz);
               :      __copy_sz = __new_sz > __old_sz? __old_sz : __new_sz;
               :      memcpy(__result, __p, __copy_sz);
               :      deallocate(__p, __old_sz);
               :      return __result;
               :    }
               :
               :  template<bool __threads, int __inst>
               :    _STL_mutex_lock
               :    __default_alloc_template<__threads,__inst>::_S_node_allocator_lock
               :    __STL_MUTEX_INITIALIZER;
               :
               :  template<bool __threads, int __inst>
               :    char* __default_alloc_template<__threads,__inst>::_S_start_free = 0;
               :
               :  template<bool __threads, int __inst>
               :    char* __default_alloc_template<__threads,__inst>::_S_end_free = 0;
               :
               :  template<bool __threads, int __inst>
               :    size_t __default_alloc_template<__threads,__inst>::_S_heap_size = 0;
               :
               :  template<bool __threads, int __inst>
               :    typename __default_alloc_template<__threads,__inst>::_Obj* volatile
               :    __default_alloc_template<__threads,__inst>::_S_free_list[_NFREELISTS];
               :
               :  typedef __default_alloc_template<true,0>    __alloc;
               :  typedef __default_alloc_template<false,0>   __single_client_alloc;
               :
               :
               :  /**
               :   *  @brief  The "standard" allocator, as per [20.4].
               :   *
               :   *  The private _Alloc is "SGI" style.  (See comments at the top
               :   *  of stl_alloc.h.)
               :   *
               :   *  The underlying allocator behaves as follows.
               :   *    - __default_alloc_template is used via two typedefs
               :   *    - "__single_client_alloc" typedef does no locking for threads
               :   *    - "__alloc" typedef is threadsafe via the locks
               :   *    - __new_alloc is used for memory requests
               :   *
               :   *  (See @link Allocators allocators info @endlink for more.)
               :   */
               :  template<typename _Tp>
               :    class allocator
               :    {
               :      typedef __alloc _Alloc;          // The underlying allocator.
               :    public:
               :      typedef size_t     size_type;
               :      typedef ptrdiff_t  difference_type;
               :      typedef _Tp*       pointer;
               :      typedef const _Tp* const_pointer;
               :      typedef _Tp&       reference;
               :      typedef const _Tp& const_reference;
               :      typedef _Tp        value_type;
               :
               :      template<typename _Tp1>
               :        struct rebind
               :        { typedef allocator<_Tp1> other; };
               :
               :      allocator() throw() {}
               :      allocator(const allocator&) throw() {}
               :      template<typename _Tp1>
               :        allocator(const allocator<_Tp1>&) throw() {}
               :      ~allocator() throw() {}
               :
               :      pointer
               :      address(reference __x) const { return &__x; }
               :
               :      const_pointer
               :      address(const_reference __x) const { return &__x; }
               :
               :      // NB: __n is permitted to be 0.  The C++ standard says nothing
               :      // about what the return value is when __n == 0.
               :      _Tp*
               :      allocate(size_type __n, const void* = 0)
               :      {
               :	_Tp* __ret = 0;
               :	if (__n)
               :	  {
               :	    if (__n <= this->max_size())
               :	      __ret = static_cast<_Tp*>(_Alloc::allocate(__n * sizeof(_Tp)));
               :	    else
               :	      __throw_bad_alloc();
               :	  }
               :	return __ret;
               :      }
               :
               :      // __p is not permitted to be a null pointer.
               :      void
               :      deallocate(pointer __p, size_type __n)
               :      { _Alloc::deallocate(__p, __n * sizeof(_Tp)); }
               :
               :      size_type
               :      max_size() const throw() { return size_t(-1) / sizeof(_Tp); }
               :
               :      void construct(pointer __p, const _Tp& __val) { new(__p) _Tp(__val); }
               :      void destroy(pointer __p) { __p->~_Tp(); }
               :    };
               :
               :  template<>
               :    class allocator<void>
               :    {
               :    public:
               :      typedef size_t      size_type;
               :      typedef ptrdiff_t   difference_type;
               :      typedef void*       pointer;
               :      typedef const void* const_pointer;
               :      typedef void        value_type;
               :
               :      template<typename _Tp1>
               :        struct rebind
               :        { typedef allocator<_Tp1> other; };
               :    };
               :
               :
               :  template<typename _T1, typename _T2>
               :    inline bool
               :    operator==(const allocator<_T1>&, const allocator<_T2>&)
               :    { return true; }
               :
               :  template<typename _T1, typename _T2>
               :    inline bool
               :    operator!=(const allocator<_T1>&, const allocator<_T2>&)
               :    { return false; }
               :
               :
               :  /**
               :   *  @if maint
               :   *  Allocator adaptor to turn an "SGI" style allocator (e.g.,
               :   *  __alloc, __malloc_alloc_template) into a "standard" conforming
               :   *  allocator.  Note that this adaptor does *not* assume that all
               :   *  objects of the underlying alloc class are identical, nor does it
               :   *  assume that all of the underlying alloc's member functions are
               :   *  static member functions.  Note, also, that __allocator<_Tp,
               :   *  __alloc> is essentially the same thing as allocator<_Tp>.
               :   *  @endif
               :   *  (See @link Allocators allocators info @endlink for more.)
               :   */
               :  template<typename _Tp, typename _Alloc>
               :    struct __allocator
               :    {
               :      _Alloc __underlying_alloc;
               :      
               :      typedef size_t    size_type;
               :      typedef ptrdiff_t difference_type;
               :      typedef _Tp*       pointer;
               :      typedef const _Tp* const_pointer;
               :      typedef _Tp&       reference;
               :      typedef const _Tp& const_reference;
               :      typedef _Tp        value_type;
               :
               :      template<typename _Tp1>
               :        struct rebind
               :        { typedef __allocator<_Tp1, _Alloc> other; };
               :
               :      __allocator() throw() {}
               :      __allocator(const __allocator& __a) throw()
               :      : __underlying_alloc(__a.__underlying_alloc) {}
               :
               :      template<typename _Tp1>
               :        __allocator(const __allocator<_Tp1, _Alloc>& __a) throw()
               :        : __underlying_alloc(__a.__underlying_alloc) {}
               :
               :      ~__allocator() throw() {}
               :
               :      pointer
               :      address(reference __x) const { return &__x; }
               :
               :      const_pointer
               :      address(const_reference __x) const { return &__x; }
               :
               :      // NB: __n is permitted to be 0.  The C++ standard says nothing
               :      // about what the return value is when __n == 0.
               :      _Tp*
               :      allocate(size_type __n, const void* = 0)
               :      {
               :	_Tp* __ret = 0;
               :	if (__n)
               :	  __ret = static_cast<_Tp*>(_Alloc::allocate(__n * sizeof(_Tp)));
               :	return __ret;
               :      }
               :
               :      // __p is not permitted to be a null pointer.
               :      void
               :      deallocate(pointer __p, size_type __n)
               :      { __underlying_alloc.deallocate(__p, __n * sizeof(_Tp)); }
               :      
               :      size_type
               :      max_size() const throw() { return size_t(-1) / sizeof(_Tp); }
               :      
               :      void
               :      construct(pointer __p, const _Tp& __val) { new(__p) _Tp(__val); }
               :      
               :      void
               :      destroy(pointer __p) { __p->~_Tp(); }
               :    };
               :
               :  template<typename _Alloc>
               :    struct __allocator<void, _Alloc>
               :    {
               :      typedef size_t      size_type;
               :      typedef ptrdiff_t   difference_type;
               :      typedef void*       pointer;
               :      typedef const void* const_pointer;
               :      typedef void        value_type;
               :
               :      template<typename _Tp1>
               :        struct rebind
               :        { typedef __allocator<_Tp1, _Alloc> other; };
               :    };
               :
               :  template<typename _Tp, typename _Alloc>
               :    inline bool
               :    operator==(const __allocator<_Tp,_Alloc>& __a1,
               :               const __allocator<_Tp,_Alloc>& __a2)
               :    { return __a1.__underlying_alloc == __a2.__underlying_alloc; }
               :
               :  template<typename _Tp, typename _Alloc>
               :    inline bool
               :    operator!=(const __allocator<_Tp, _Alloc>& __a1,
               :               const __allocator<_Tp, _Alloc>& __a2)
               :    { return __a1.__underlying_alloc != __a2.__underlying_alloc; }
               :
               :
               :  //@{
               :  /** Comparison operators for all of the predifined SGI-style allocators.
               :   *  This ensures that __allocator<malloc_alloc> (for example) will work
               :   *  correctly.  As required, all allocators compare equal.
               :   */
               :  template<int inst>
               :    inline bool
               :    operator==(const __malloc_alloc_template<inst>&,
               :               const __malloc_alloc_template<inst>&)
               :    { return true; }
               :
               :  template<int __inst>
               :    inline bool
               :    operator!=(const __malloc_alloc_template<__inst>&,
               :               const __malloc_alloc_template<__inst>&)
               :    { return false; }
               :
               :  template<typename _Alloc>
               :    inline bool
               :    operator==(const __debug_alloc<_Alloc>&, const __debug_alloc<_Alloc>&)
               :    { return true; }
               :
               :  template<typename _Alloc>
               :    inline bool
               :    operator!=(const __debug_alloc<_Alloc>&, const __debug_alloc<_Alloc>&)
               :    { return false; }
               :  //@}
               :
               :
               :  /**
               :   *  @if maint
               :   *  Another allocator adaptor:  _Alloc_traits.  This serves two purposes.
               :   *  First, make it possible to write containers that can use either "SGI"
               :   *  style allocators or "standard" allocators.  Second, provide a mechanism
               :   *  so that containers can query whether or not the allocator has distinct
               :   *  instances.  If not, the container can avoid wasting a word of memory to
               :   *  store an empty object.  For examples of use, see stl_vector.h, etc, or
               :   *  any of the other classes derived from this one.
               :   *
               :   *  This adaptor uses partial specialization.  The general case of
               :   *  _Alloc_traits<_Tp, _Alloc> assumes that _Alloc is a
               :   *  standard-conforming allocator, possibly with non-equal instances and
               :   *  non-static members.  (It still behaves correctly even if _Alloc has
               :   *  static member and if all instances are equal.  Refinements affect
               :   *  performance, not correctness.)
               :   *
               :   *  There are always two members:  allocator_type, which is a standard-
               :   *  conforming allocator type for allocating objects of type _Tp, and
               :   *  _S_instanceless, a static const member of type bool.  If
               :   *  _S_instanceless is true, this means that there is no difference
               :   *  between any two instances of type allocator_type.  Furthermore, if
               :   *  _S_instanceless is true, then _Alloc_traits has one additional
               :   *  member:  _Alloc_type.  This type encapsulates allocation and
               :   *  deallocation of objects of type _Tp through a static interface; it
               :   *  has two member functions, whose signatures are
               :   *
               :   *  -  static _Tp* allocate(size_t)
               :   *  -  static void deallocate(_Tp*, size_t)
               :   *
               :   *  The size_t parameters are "standard" style (see top of stl_alloc.h) in
               :   *  that they take counts, not sizes.
               :   *
               :   *  @endif
               :   *  (See @link Allocators allocators info @endlink for more.)
               :   */
               :  //@{
               :  // The fully general version.
               :  template<typename _Tp, typename _Allocator>
               :    struct _Alloc_traits
               :    {
               :      static const bool _S_instanceless = false;
               :      typedef typename _Allocator::template rebind<_Tp>::other allocator_type;
               :    };
               :
               :  template<typename _Tp, typename _Allocator>
               :    const bool _Alloc_traits<_Tp, _Allocator>::_S_instanceless;
               :
               :  /// The version for the default allocator.
               :  template<typename _Tp, typename _Tp1>
               :    struct _Alloc_traits<_Tp, allocator<_Tp1> >
               :    {
               :      static const bool _S_instanceless = true;
               :      typedef __simple_alloc<_Tp, __alloc> _Alloc_type;
               :      typedef allocator<_Tp> allocator_type;
               :    };
               :  //@}
               :
               :  //@{
               :  /// Versions for the predefined "SGI" style allocators.
               :  template<typename _Tp, int __inst>
               :    struct _Alloc_traits<_Tp, __malloc_alloc_template<__inst> >
               :    {
               :      static const bool _S_instanceless = true;
               :      typedef __simple_alloc<_Tp, __malloc_alloc_template<__inst> > _Alloc_type;
               :      typedef __allocator<_Tp, __malloc_alloc_template<__inst> > allocator_type;
               :    };
               :
               :  template<typename _Tp, bool __threads, int __inst>
               :    struct _Alloc_traits<_Tp, __default_alloc_template<__threads, __inst> >
               :    {
               :      static const bool _S_instanceless = true;
               :      typedef __simple_alloc<_Tp, __default_alloc_template<__threads, __inst> >
               :      _Alloc_type;
               :      typedef __allocator<_Tp, __default_alloc_template<__threads, __inst> >
               :      allocator_type;
               :    };
               :
               :  template<typename _Tp, typename _Alloc>
               :    struct _Alloc_traits<_Tp, __debug_alloc<_Alloc> >
               :    {
               :      static const bool _S_instanceless = true;
               :      typedef __simple_alloc<_Tp, __debug_alloc<_Alloc> > _Alloc_type;
               :      typedef __allocator<_Tp, __debug_alloc<_Alloc> > allocator_type;
               :    };
               :  //@}
               :
               :  //@{
               :  /// Versions for the __allocator adaptor used with the predefined
               :  /// "SGI" style allocators.
               :  template<typename _Tp, typename _Tp1, int __inst>
               :    struct _Alloc_traits<_Tp,
               :                         __allocator<_Tp1, __malloc_alloc_template<__inst> > >
               :    {
               :      static const bool _S_instanceless = true;
               :      typedef __simple_alloc<_Tp, __malloc_alloc_template<__inst> > _Alloc_type;
               :      typedef __allocator<_Tp, __malloc_alloc_template<__inst> > allocator_type;
               :    };
               :
               :  template<typename _Tp, typename _Tp1, bool __thr, int __inst>
               :    struct _Alloc_traits<_Tp, __allocator<_Tp1, __default_alloc_template<__thr, __inst> > >
               :    {
               :      static const bool _S_instanceless = true;
               :      typedef __simple_alloc<_Tp, __default_alloc_template<__thr,__inst> >
               :      _Alloc_type;
               :      typedef __allocator<_Tp, __default_alloc_template<__thr,__inst> >
               :      allocator_type;
               :    };
               :
               :  template<typename _Tp, typename _Tp1, typename _Alloc>
               :    struct _Alloc_traits<_Tp, __allocator<_Tp1, __debug_alloc<_Alloc> > >
               :    {
               :      static const bool _S_instanceless = true;
               :      typedef __simple_alloc<_Tp, __debug_alloc<_Alloc> > _Alloc_type;
               :      typedef __allocator<_Tp, __debug_alloc<_Alloc> > allocator_type;
               :    };
               :  //@}
               :
               :  // Inhibit implicit instantiations for required instantiations,
               :  // which are defined via explicit instantiations elsewhere.
               :  // NB: This syntax is a GNU extension.
               :  extern template class allocator<char>;
               :  extern template class allocator<wchar_t>;
               :  extern template class __default_alloc_template<true,0>;
               :} // namespace std
               :
               :#endif
/* 
 * Total samples for file : "/usr/include/c++/3.2/cmath"
 * 
 *   1025  0.2279
 */


               :// -*- C++ -*- C forwarding header.
               :
               :// Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002
               :// Free Software Foundation, Inc.
               ://
               :// This file is part of the GNU ISO C++ Library.  This library is free
               :// software; you can redistribute it and/or modify it under the
               :// terms of the GNU General Public License as published by the
               :// Free Software Foundation; either version 2, or (at your option)
               :// any later version.
               :
               :// This library is distributed in the hope that it will be useful,
               :// but WITHOUT ANY WARRANTY; without even the implied warranty of
               :// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
               :// GNU General Public License for more details.
               :
               :// You should have received a copy of the GNU General Public License along
               :// with this library; see the file COPYING.  If not, write to the Free
               :// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,
               :// USA.
               :
               :// As a special exception, you may use this file as part of a free software
               :// library without restriction.  Specifically, if other files instantiate
               :// templates or use macros or inline functions from this file, or you compile
               :// this file and link it with other files to produce an executable, this
               :// file does not by itself cause the resulting executable to be covered by
               :// the GNU General Public License.  This exception does not however
               :// invalidate any other reasons why the executable file might be covered by
               :// the GNU General Public License.
               :
               ://
               :// ISO C++ 14882: 26.5  C library
               ://
               :
               :/** @file cmath
               : *  This is a Standard C++ Library file.  You should @c #include this file
               : *  in your programs, rather than any of the "*.h" implementation files.
               : *
               : *  This is the C++ version of the Standard C Library header @c math.h,
               : *  and its contents are (mostly) the same as that header, but are all
               : *  contained in the namespace @c std.
               : */
               :
               :#ifndef _CPP_CMATH
               :#define _CPP_CMATH 1
               :
               :#pragma GCC system_header
               :
               :#include <bits/c++config.h>
               :
               :#include <math.h>
               :
               :// Get rid of those macros defined in <math.h> in lieu of real functions.
               :#undef abs
               :#undef div
               :#undef acos
               :#undef asin
               :#undef atan
               :#undef atan2
               :#undef ceil
               :#undef cos
               :#undef cosh
               :#undef exp
               :#undef fabs
               :#undef floor
               :#undef fmod
               :#undef frexp
               :#undef ldexp
               :#undef log
               :#undef log10
               :#undef modf
               :#undef pow
               :#undef sin
               :#undef sinh
               :#undef sqrt
               :#undef tan
               :#undef tanh
               :
               :namespace std 
               :{
               :  // Forward declaration of a helper function.  This really should be
               :  // an `exported' forward declaration.
               :  template<typename _Tp> _Tp __cmath_power(_Tp, unsigned int);
               :
               :  inline double
               :  abs(double __x)
               :  { return __builtin_fabs(__x); }
               :
               :  inline float
               :  abs(float __x)
               :  { return __builtin_fabsf(__x); }
               :
               :  inline long double
               :  abs(long double __x)
               :  { return __builtin_fabsl(__x); }
               :
               :#if _GLIBCPP_HAVE_ACOSF
               :  inline float 
               :  acos(float __x) { return ::acosf(__x); }
               :#else
               :  inline float 
               :  acos(float __x) { return ::acos(static_cast<double>(__x)); }
               :#endif
               :
               :  using ::acos;
               :  
               :#if _GLIBCPP_HAVE_ACOSL
               :  inline long double 
               :  acos(long double __x) { return ::acosl(__x); }
               :#else
               :  inline long double 
               :  acos(long double __x) { return ::acos(static_cast<double>(__x)); }
               :#endif
               :
               :  using ::asin;
               :
               :#if _GLIBCPP_HAVE_ASINF
               :  inline float 
               :  asin(float __x) { return ::asinf(__x); }
               :#else
               :  inline float 
               :  asin(float __x) { return ::asin(static_cast<double>(__x)); }
               :#endif
               :
               :#if _GLIBCPP_HAVE_ASINL
               :  inline long double 
               :  asin(long double __x) { return ::asinl(__x); }
               :#else
               :  inline long double 
               :  asin(long double __x) { return ::asin(static_cast<double>(__x)); }
               :#endif
               :
               :  using ::atan;
               :
               :#if _GLIBCPP_HAVE_ATANF
               :  inline float 
               :  atan(float __x) { return ::atanf(__x); }
               :#else
               :  inline float 
               :  atan(float __x) { return ::atan(static_cast<double>(__x)); }
               :#endif
               :
               :#if _GLIBCPP_HAVE_ATANL
               :  inline long double 
               :  atan(long double __x) { return ::atanl(__x); }
               :#else
               :  inline long double 
               :  atan(long double __x) { return ::atan(static_cast<double>(__x)); }
               :#endif
               :
               :  using ::atan2;
               :
               :#if _GLIBCPP_HAVE_ATAN2F
               :  inline float 
               :  atan2(float __y, float __x) { return ::atan2f(__y, __x); }
               :#else
               :  inline float 
               :  atan2(float __y, float __x)
               :  { return ::atan2(static_cast<double>(__y), static_cast<double>(__x)); }
               :#endif
               :
               :#if _GLIBCPP_HAVE_ATAN2L
               :  inline long double 
               :  atan2(long double __y, long double __x) { return ::atan2l(__y, __x); }
               :#else
               :  inline long double 
               :  atan2(long double __y, long double __x) 
               :  { return ::atan2(static_cast<double>(__y), static_cast<double>(__x)); }
               :#endif
               :
               :  using ::ceil;
               :
               :#if _GLIBCPP_HAVE_CEILF
               :  inline float 
               :  ceil(float __x) { return ::ceilf(__x); }
               :#else
               :  inline float 
               :  ceil(float __x) { return ::ceil(static_cast<double>(__x)); }
               :#endif
               :
               :#if _GLIBCPP_HAVE_CEILL
               :  inline long double 
               :  ceil(long double __x) { return ::ceill(__x); }
               :#else
               :  inline long double 
               :  ceil(long double __x) { return ::ceil(static_cast<double>(__x)); }
               :#endif
               :
               :  using ::cos;
               :
               :  inline float
               :  cos(float __x)
               :  { return __builtin_cosf(__x); }
               :
               :  inline long double
               :  cos(long double __x)
               :  { return __builtin_cosl(__x); }
               :
               :  using ::cosh;
               :
               :#if _GLIBCPP_HAVE_COSHF
               :  inline float 
               :  cosh(float __x) { return ::coshf(__x); }
               :#else
               :  inline float 
               :  cosh(float __x) { return ::cosh(static_cast<double>(__x)); }
               :#endif
               :
               :#if _GLIBCPP_HAVE_COSHL
               :  inline long double 
               :  cosh(long double __x) { return ::coshl(__x); }
               :#else
               :  inline long double 
               :  cosh(long double __x) { return ::cosh(static_cast<double>(__x)); }
               :#endif
               :
               :  using ::exp;
               :
               :#if _GLIBCPP_HAVE_EXPF
               :  inline float 
               :  exp(float __x) { return ::expf(__x); }
               :#else
               :  inline float 
               :  exp(float __x) { return ::exp(static_cast<double>(__x)); }
               :#endif
               :
               :#if _GLIBCPP_HAVE_EXPL
               :  inline long double 
               :  exp(long double __x) { return ::expl(__x); }
               :#else
               :  inline long double 
               :  exp(long double __x) { return ::exp(static_cast<double>(__x)); }
               :#endif
               :
               :  using ::fabs;
               :
               :  inline float
               :  fabs(float __x)
  1025  0.2279 :  { return __builtin_fabsf(__x); } /* std::sqrt(float) total:    196  0.0436 */
               :
               :  inline long double
               :  fabs(long double __x)
               :  { return __builtin_fabsl(__x); }
               :
               :  using ::floor;
               :
               :#if _GLIBCPP_HAVE_FLOORF
               :  inline float 
               :  floor(float __x) { return ::floorf(__x); }
               :#else
               :  inline float 
               :  floor(float __x) { return ::floor(static_cast<double>(__x)); }
               :#endif
               :
               :#if _GLIBCPP_HAVE_FLOORL
               :  inline long double 
               :  floor(long double __x) { return ::floorl(__x); }
               :#else
               :  inline long double 
               :  floor(long double __x) { return ::floor(static_cast<double>(__x)); }
               :#endif
               :
               :  using ::fmod;
               :
               :#if _GLIBCPP_HAVE_FMODF
               :  inline float 
               :  fmod(float __x, float __y) { return ::fmodf(__x, __y); }
               :#else
               :  inline float 
               :  fmod(float __x, float __y)
               :  { return ::fmod(static_cast<double>(__x), static_cast<double>(__y)); }
               :#endif
               :
               :#if _GLIBCPP_HAVE_FMODL
               :  inline long double 
               :  fmod(long double __x, long double __y) { return ::fmodl(__x, __y); }
               :#else
               :  inline long double 
               :  fmod(long double __x, long double __y) 
               :  { return ::fmod(static_cast<double>(__x), static_cast<double>(__y)); }
               :#endif
               :
               :  using ::frexp;
               :
               :#if _GLIBCPP_HAVE_FREXPF
               :  inline float 
               :  frexp(float __x, int* __exp) { return ::frexpf(__x, __exp); }
               :#else
               :  inline float 
               :  frexp(float __x, int* __exp) { return ::frexp(__x, __exp); }
               :#endif
               :
               :#if _GLIBCPP_HAVE_FREXPL
               :  inline long double 
               :  frexp(long double __x, int* __exp) { return ::frexpl(__x, __exp); }
               :#else
               :  inline long double 
               :  frexp(long double __x, int* __exp) 
               :  { return ::frexp(static_cast<double>(__x), __exp); }
               :#endif
               :
               :  using ::ldexp;
               :
               :#if _GLIBCPP_HAVE_LDEXPF
               :  inline float 
               :  ldexp(float __x, int __exp) { return ::ldexpf(__x, __exp); }
               :#else
               :  inline float 
               :  ldexp(float __x, int __exp)
               :  { return ::ldexp(static_cast<double>(__x), __exp); }
               :#endif
               :
               :#if _GLIBCPP_HAVE_LDEXPL
               :  inline long double 
               :  ldexp(long double __x, int __exp) { return ::ldexpl(__x, __exp); }
               :#else
               :  inline long double 
               :  ldexp(long double __x, int __exp) 
               :  { return ::ldexp(static_cast<double>(__x), __exp); }
               :#endif
               :
               :  using ::log;
               :
               :#if _GLIBCPP_HAVE_LOGF
               :  inline float 
               :  log(float __x) { return ::logf(__x); }
               :#else
               :  inline float log(float __x)
               :  { return ::log(static_cast<double>(__x)); }
               :#endif
               :
               :#if _GLIBCPP_HAVE_LOGL
               :  inline long double 
               :  log(long double __x) { return ::logl(__x); }
               :#else
               :  inline long double 
               :  log(long double __x) { return ::log(static_cast<double>(__x)); }
               :#endif
               :
               :  using ::log10;
               :
               :#if _GLIBCPP_HAVE_LOG10F
               :  inline float 
               :  log10(float __x) { return ::log10f(__x); }
               :#else
               :  inline float 
               :  log10(float __x) { return ::log10(static_cast<double>(__x)); }
               :#endif
               :
               :#if _GLIBCPP_HAVE_LOG10L
               :  inline long double 
               :  log10(long double __x) { return ::log10l(__x); }
               :#else
               :  inline long double 
               :  log10(long double __x) { return ::log10(static_cast<double>(__x)); }
               :#endif
               :
               :  using ::modf;
               :
               :#if _GLIBCPP_HAVE_MODFF
               :  inline float 
               :  modf(float __x, float* __iptr) { return ::modff(__x, __iptr); }
               :#else
               :  inline float 
               :  modf(float __x, float* __iptr)
               :  {
               :    double __tmp;
               :    double __res = ::modf(static_cast<double>(__x), &__tmp);
               :    *__iptr = static_cast<float>(__tmp);
               :    return __res;
               :  }
               :#endif
               :
               :#if _GLIBCPP_HAVE_MODFL
               :  inline long double 
               :  modf(long double __x, long double* __iptr) { return ::modfl(__x, __iptr); }
               :#else
               :  inline long double 
               :  modf(long double __x, long double* __iptr) 
               :  { 
               :    double __tmp;
               :    double __res = ::modf(static_cast<double>(__x), &__tmp);
               :    * __iptr = static_cast<long double>(__tmp);
               :    return __res;
               :  }
               :#endif
               :
               :  template<typename _Tp>
               :    inline _Tp
               :    __pow_helper(_Tp __x, int __n)
               :    {
               :      return __n < 0
               :        ? _Tp(1)/__cmath_power(__x, -__n)
               :        : __cmath_power(__x, __n);
               :    }
               :
               :  using ::pow;
               :
               :#if _GLIBCPP_HAVE_POWF
               :  inline float 
               :  pow(float __x, float __y) { return ::powf(__x, __y); }
               :#else
               :  inline float 
               :  pow(float __x, float __y)
               :  { return ::pow(static_cast<double>(__x), static_cast<double>(__y)); }
               :#endif
               :
               :#if _GLIBCPP_HAVE_POWL
               :  inline long double 
               :  pow(long double __x, long double __y) { return ::powl(__x, __y); }
               :#else
               :  inline long double 
               :  pow(long double __x, long double __y) 
               :  { return ::pow(static_cast<double>(__x), static_cast<double>(__y)); }
               :#endif
               :
               :  inline double 
               :  pow(double __x, int __i)
               :  { return __pow_helper(__x, __i); }
               :
               :  inline float 
               :  pow(float __x, int __n)
               :  { return __pow_helper(__x, __n); }
               :
               :  inline long double 
               :  pow(long double __x, int __n)
               :  { return __pow_helper(__x, __n); }
               :
               :  using ::sin;
               :
               :  inline float
               :  sin(float __x)
               :  { return __builtin_sinf(__x); }
               :
               :  inline long double
               :  sin(long double __x)
               :  { return __builtin_sinl(__x); }
               :
               :  using ::sinh;
               :
               :#if _GLIBCPP_HAVE_SINHF
               :  inline float 
               :  sinh(float __x) { return ::sinhf(__x); }
               :#else
               :  inline float 
               :  sinh(float __x) { return ::sinh(static_cast<double>(__x)); }
               :#endif
               :
               :#if _GLIBCPP_HAVE_SINHL
               :  inline long double 
               :  sinh(long double __x) { return ::sinhl(__x); }
               :#else
               :  inline long double 
               :  sinh(long double __x) { return ::sinh(static_cast<double>(__x)); }
               :#endif
               :
               :  using ::sqrt;
               :
               :  inline float
               :  sqrt(float __x)
               :  { return __builtin_sqrtf(__x); }
               :
               :  inline long double
               :  sqrt(long double __x)
               :  { return __builtin_sqrtl(__x); }
               :
               :  using ::tan;
               :
               :#if _GLIBCPP_HAVE_TANF
               :  inline float 
               :  tan(float __x) { return ::tanf(__x); }
               :#else
               :  inline float 
               :  tan(float __x) { return ::tan(static_cast<double>(__x)); }
               :#endif
               :
               :#if _GLIBCPP_HAVE_TANL
               :  inline long double 
               :  tan(long double __x) { return ::tanl(__x); }
               :#else
               :  inline long double 
               :  tan(long double __x) { return ::tan(static_cast<double>(__x)); }
               :#endif
               :
               :  using ::tanh;
               :
               :#if _GLIBCPP_HAVE_TANHF
               :  inline float 
               :  tanh(float __x) { return ::tanhf(__x); }
               :#else
               :  inline float 
               :  tanh(float __x) { return ::tanh(static_cast<double>(__x)); }
               :#endif
               :
               :#if _GLIBCPP_HAVE_TANHL
               :  inline long double 
               :  tanh(long double __x) { return ::tanhl(__x); }
               :#else
               :  inline long double 
               :  tanh(long double __x) { return ::tanh(static_cast<double>(__x)); }
               :#endif
               :} 
               :
               :
               :#if _GLIBCPP_USE_C99
               :// These are possible macros imported from C99-land. For strict
               :// conformance, remove possible C99-injected names from the global
               :// namespace, and sequester them in the __gnu_cxx extension namespace. 
               :namespace __gnu_cxx
               :{
               :  template<typename _Tp>
               :    int 
               :    __capture_fpclassify(_Tp __f) { return fpclassify(__f); }
               :
               :  template<typename _Tp>
               :    int 
               :    __capture_isfinite(_Tp __f) { return isfinite(__f); }
               :
               :  template<typename _Tp>
               :    int 
               :    __capture_isinf(_Tp __f) { return isinf(__f); }
               :
               :  template<typename _Tp>
               :    int 
               :    __capture_isnan(_Tp __f) { return isnan(__f); }
               :
               :  template<typename _Tp>
               :    int 
               :    __capture_isnormal(_Tp __f) { return isnormal(__f); }
               :
               :  template<typename _Tp>
               :    int 
               :    __capture_signbit(_Tp __f) { return signbit(__f); }
               :
               :  template<typename _Tp>
               :    int 
               :    __capture_isgreater(_Tp __f1, _Tp __f2)
               :    { return isgreater(__f1, __f2); }
               :
               :  template<typename _Tp>
               :     int 
               :     __capture_isgreaterequal(_Tp __f1, _Tp __f2) 
               :     { return isgreaterequal(__f1, __f2); }
               :
               :  template<typename _Tp>
               :     int 
               :     __capture_isless(_Tp __f1, _Tp __f2) { return isless(__f1, __f2); }
               :
               :  template<typename _Tp>
               :     int 
               :     __capture_islessequal(_Tp __f1, _Tp __f2) 
               :     { return islessequal(__f1, __f2); }
               :
               :  template<typename _Tp>
               :     int 
               :     __capture_islessgreater(_Tp __f1, _Tp __f2) 
               :     { return islessgreater(__f1, __f2); }
               :
               :  template<typename _Tp>
               :     int 
               :     __capture_isunordered(_Tp __f1, _Tp __f2) 
               :     { return isunordered(__f1, __f2); }
               :} 
               :#endif
               :
               :#undef fpclassify
               :#undef isfinite
               :#undef isinf
               :#undef isnan
               :#undef isnormal
               :#undef signbit
               :#undef isgreater
               :#undef isgreaterequal
               :#undef isless
               :#undef islessequal
               :#undef islessgreater
               :#undef isunordered
               :
               :#if _GLIBCPP_USE_C99
               :namespace __gnu_cxx
               :{
               :  template<typename _Tp>
               :    int
               :    fpclassify(_Tp __f) { return __capture_fpclassify(__f); }
               :
               :  template<typename _Tp>
               :    int
               :    isfinite(_Tp __f) { return __capture_isfinite(__f); }
               :
               :  template<typename _Tp>
               :    int 
               :    isinf(_Tp __f) { return __capture_isinf(__f); }
               :
               :  template<typename _Tp>
               :    int 
               :    isnan(_Tp __f) { return __capture_isnan(__f); }
               :
               :  template<typename _Tp>
               :    int 
               :    isnormal(_Tp __f) { return __capture_isnormal(__f); }
               :
               :  template<typename _Tp>
               :    int 
               :    signbit(_Tp __f) { return __capture_signbit(__f); }
               :
               :  template<typename _Tp>
               :    int 
               :    isgreater(_Tp __f1, _Tp __f2) { return __capture_isgreater(__f1, __f2); }
               :
               :  template<typename _Tp>
               :    int 
               :    isgreaterequal(_Tp __f1, _Tp __f2) 
               :    { return __capture_isgreaterequal(__f1, __f2); }
               :
               :  template<typename _Tp>
               :    int 
               :    isless(_Tp __f1, _Tp __f2) { return __capture_isless(__f1, __f2); }
               :
               :  template<typename _Tp>
               :    int 
               :    islessequal(_Tp __f1, _Tp __f2) 
               :    { return __capture_islessequal(__f1, __f2); }
               :
               :  template<typename _Tp>
               :    int 
               :    islessgreater(_Tp __f1, _Tp __f2) 
               :    { return __capture_islessgreater(__f1, __f2); }
               :
               :  template<typename _Tp>
               :    int 
               :    isunordered(_Tp __f1, _Tp __f2) 
               :    { return __capture_isunordered(__f1, __f2); }
               :}
               :
               :namespace std
               :{
               :  using __gnu_cxx::fpclassify;
               :  using __gnu_cxx::isfinite;
               :  using __gnu_cxx::isinf;
               :  using __gnu_cxx::isnan;
               :  using __gnu_cxx::isnormal;
               :  using __gnu_cxx::signbit;
               :  using __gnu_cxx::isgreater;
               :  using __gnu_cxx::isgreaterequal;
               :  using __gnu_cxx::isless;
               :  using __gnu_cxx::islessequal;
               :  using __gnu_cxx::islessgreater;
               :  using __gnu_cxx::isunordered;
               :}
               :#endif
               :  
               :#ifdef _GLIBCPP_NO_TEMPLATE_EXPORT
               :#  define export
               :#  include <bits/cmath.tcc>
               :#endif
               :
               :#endif
/* 
 * Total samples for file : "/nfs/1/home/rutt/dev/ocvm/ocvm-cvs/src/f-mediator.cpp"
 * 
 *      3 6.7e-04
 */


               :#include "f-headers.h"
               :
               :using namespace std;
               :
               :class CachedImage
               :{
               :public:
               :    CachedImage(unsigned char * data_,
               :                size_t data_length_,
               :                int width_,
               :                int height_,
               :                ImageCoordinate & ic_) : data_length(data_length_),
               :                                         width(width_),
               :                                         height(height_),
               :                                         ic(ic_),
               :                                         hits(0)
               :    {
               :        data = new unsigned char[data_length_];
               :        memcpy(data, data_, data_length_);
               :    }
               :    virtual ~CachedImage()
               :    {
               :        delete[] data;
               :    }
               :    unsigned char * data;
               :    size_t data_length;
               :    int width;
               :    int height;
               :    std::list<CachedImage*>::iterator me;
               :    ImageCoordinate ic;
               :    int hits;
               :};
               :
               :class SubimageCache
               :{
               :    int capacity;
               :    int size;
               :    std::map<ImageCoordinate, CachedImage*> subimage_cache;
               :    std::list<CachedImage*> LRU_list; // front: LRU   rear: MRU
               :
               :    int list_size()
               :    {
               :        return LRU_list.size();
               :    }
               :    
               :    bool purge_item(void)
               :    {
               :        if (LRU_list.empty() == false) {
               :            CachedImage * byebye = *(LRU_list.begin());
               :            LRU_list.pop_front();
               :            size -= byebye->data_length;
               :            subimage_cache.erase(byebye->ic);
               ://             std::cout << "cache:  removing coordinate "
               ://                       << byebye->ic
               ://                       << " with hit count " << byebye->hits
               ://                       << endl;
               :            delete byebye;
               ://             std::cout << "size reduced to " << size << endl;
               :            return true;
               :        }
               :        else {
               :            assert(size == 0);
               :            return false;
               :        }
               :    }
               :
               :public:
               :    SubimageCache(int byte_capacity) : capacity(byte_capacity),
               :                                       size(0)
               :    {
               :        ;
               :    }
               :    ~SubimageCache()
               :    {
               :        clear();
               :    }
               :    void clear()
               :    {
               :        while (purge_item()) {
               :            ;
               :        }
               :    }
               :    void plist(void)
               :    {
               :        std::cout << "LRU list:  ";
               :        std::list<CachedImage*>::iterator it;
               :        for (it = LRU_list.begin();
               :             it != LRU_list.end();
               :             it++) {
               :            std::cout << " <> " << (*it)->ic;
               :        }
               :        std::cout << endl;
               :    }
               :    void add(ImageCoordinate & ic,
               :             unsigned char * data,
               :             int width,
               :             int height)
               :    {
               :        if (subimage_cache.count(ic) == 0)
               :        {
               :            int data_length = width*height*3;
               :            while (size > capacity) {
               :                purge_item();
               :            }
               :            CachedImage * ci = new CachedImage(data, data_length, width, height,ic);
               :            subimage_cache[ic] = ci;
               :            ci->me = LRU_list.insert(LRU_list.end(), ci);
               :            size += data_length;
               :        }
               :    }
               :    CachedImage * try_hit(ImageCoordinate & ic)
               :    {
               :        if (subimage_cache.count(ic) == 0) {
               :            return NULL;
               :        }
               :        CachedImage * ci = subimage_cache[ic];
               :        LRU_list.erase(ci->me);
               :        ci->me = LRU_list.insert(LRU_list.end(), ci);
               :        ci->hits++;
               :        return ci;
               :    }
               :};
               :
               :int ocvm_mediator::process(void)
               :{ /* ocvm_mediator::process() total:      1 2.2e-04 */
               :    std::string myhostname =get_param("myhostname");
               :    int clients_that_need_me = get_param_as_int("clients_that_need_me");
               :    int mediators_that_need_me = get_param_as_int("mediators_that_need_me");
               :    int mediators_orig = mediators_that_need_me;
               :    std::string image_descriptor_string;
               :    std::string image_descriptor_string_last;
               :    std::string reply_port;
               :    std::string reply_host;
               :    ImageDescriptor image_descriptor;
               :    int cache_size = get_param_as_int("cache_size");
               :    SubimageCache cache(cache_size);
               :    int4 x,y,z;
               :    std::vector<std::string> mediators_that_said_bye;
               :
               :    std::vector<std::pair<std::string, std::string> > renames;
               :    while (clients_that_need_me > 0 ||
               :           mediators_that_need_me > 0) {
               :        DCBuffer * in = read("0");
               :        int4 packet_type;
               :        in->unpack("i", &packet_type);
               :        if (packet_type==MEDIATOR_GOODBYE_FROM_CLIENT) {
               :            clients_that_need_me--;
               ://             std::cout << "mediator: client said goodbye, "
               ://                       << "clients_that_need_me now " << clients_that_need_me
               ://                       << endl;
               :            if (clients_that_need_me == 0 && mediators_orig > 0) {
               :                DCBuffer terminator;
               :                terminator.pack("is",
               :                                MEDIATOR_GOODBYE_FROM_ANOTHER_MEDIATOR,
               :                                myhostname.c_str());
               :                write_broadcast(&terminator, "m2m");
               :            }
               :        }
               :        else if (packet_type==MEDIATOR_GOODBYE_FROM_ANOTHER_MEDIATOR) {
               :            mediators_that_need_me--;
               :            std::string other_mediator;
               :            in->unpack("s", &other_mediator);
               :            mediators_that_said_bye.push_back(other_mediator);
               ://             std::cout << "mediator: a mediator said goodbye, "
               ://                       << "mediators_that_need_me now " << mediators_that_need_me
               ://                       << endl;
               :        }
               :        else if (packet_type== MEDIATOR_READ_REQUEST) {
               :            in->unpack("siiiss", &image_descriptor_string, &x, &y, &z,
               :                       &reply_port, &reply_host);
               ://             std::cout << "mediator on " << myhostname
               ://                       << ": got request for "
               ://                       << x << "," << y << "," << z << endl;
               :            in->resetExtract();
               :            if (image_descriptor_string != image_descriptor_string_last) {
               :                image_descriptor.init_from_string(image_descriptor_string);
               :                if (cache_size) {
               :                    cache.clear();
               :                }
               :            }
               :            image_descriptor_string_last = image_descriptor_string;
               :            ImageCoordinate ic(x,y,z);
               :            ImagePart part = image_descriptor.get_part(ic);
               :
               :            // look for cache hit
               :            CachedImage * ci;
               :            if (cache_size && (ci = cache.try_hit(ic))!=NULL) {
               ://                 std::cout << "cache hit on "
               ://                           << myhostname
               ://                           << " for coord " << ic
               ://                           << endl;
               :                DCBuffer * out = new DCBuffer(in->getExtractAvailSize() + 16 +
               :                                              ci->data_length);
               :                out->pack("isiiissll",
               :                    MEDIATOR_READ_RESPONSE, image_descriptor_string.c_str(),
               :                    x, y, z, reply_port.c_str(), reply_host.c_str(),
               :                    (int8)ci->width, (int8)ci->height);
               :                memcpy(out->getPtrFree(), ci->data, ci->data_length);
               :                out->incrementUsedSize(ci->data_length);
               :                if (reply_host == myhostname) {
               :                    write_nocopy(out, reply_port);
               :                }
               :                else {
               :                    write_nocopy(out, "m2m", reply_host);
               :                }
     1 2.2e-04 :                delete in;
               :            }
               :            else {
               :                // cache miss or cache disabled
               :                if (part.hostname == myhostname) {
               :                    write_nocopy(in, "2r"); // ask my readers
               :                }
               :                else {
               :                    write_nocopy(in, "m2m", part.hostname); // ask another host
               :                }
               :            }
               :        }
               :        else if (packet_type == MEDIATOR_READ_RESPONSE) {
               :            int8 w, h;
               :            in->unpack("siiissll", &image_descriptor_string, &x, &y, &z,
               :                       &reply_port, &reply_host, &w, &h);
               :            unsigned char * data = (unsigned char*)in->getPtrExtract();
               :            in->resetExtract();
               ://             std::cout << "mediator on " << myhostname
               ://                       << ": got response for "
               ://                       << x << "," << y << "," << z << endl;
               :            if (image_descriptor_string != image_descriptor_string_last) {
               :                image_descriptor.init_from_string(image_descriptor_string);
               :                if (cache_size) {
               :                    cache.clear();
               :                }
               :            }
               :            image_descriptor_string_last = image_descriptor_string;
               :
               :            ImageCoordinate ic(x,y,z);
               :            ImagePart part = image_descriptor.get_part(ic);
               :            if (reply_host == myhostname) {
               :                if (cache_size) {
               :                    // insert into local cache
               :                    cache.add(ic, data, (int)w, (int)h);
               ://                     std::cout << "cache fill on "
               ://                               << myhostname
               ://                               << " for coordinate " << ic << endl;
               :                }
               :                write_nocopy(in, reply_port);
               :            }
               :            else {
               :                write_nocopy(in, "m2m", reply_host);
               :            }
               :        }
               :        else if (packet_type == MEDIATOR_RENAME_THIS_LATER) {
               :            std::string from, to;
               :            while (in->getExtractAvailSize()) {
               :                in->unpack ("ss", & from, & to);
               :                renames.push_back(make_pair(from, to));
               :            }
               :        }
               :        else {
               :            std::cerr << "ERROR:  protocol error"
               :                      << " at " << __FILE__ << ":" << __LINE__
               :                      << std::endl << std::flush;
               :            exit(1);
               :        }
               :    }
               :
               :    for (uint u = 0; u < renames.size(); u++) {
               :        std::string from = renames[u].first;
               :        std::string to = renames[u].second;
               :        int rc = rename(from.c_str(),
               :                        to.c_str());
               :        if (rc) {
               :            std::cerr << "ERROR: renaming "
               :                      << from
               :                      << " to "
               :                      << to
               :                      << " at " << __FILE__ << ":" << __LINE__
               :                      << std::endl << std::flush;
               :            exit(1);
               :        }
               :    }
               :
               :    return 0;
               :}
               :
               :int ocvm_mediator_reader::process(void)
               :{ /* ocvm_mediator_reader::process() total:      2 4.4e-04 */
               :    DCBuffer * in;
               :    FILE * f;
               :    int packet_type;
               :    ImageDescriptor image_descriptor;
               :    std::string image_descriptor_string;
               :    std::string image_descriptor_string_last;
               :    std::string reply_port;
               :    std::string reply_host;
               :    int4 x, y, z;
               :    while ((in = read_until_upstream_exit("0"))) {
     1 2.2e-04 :        in->unpack("isiiiss", &packet_type,
               :                   &image_descriptor_string, &x, &y, &z,
               :                   &reply_port, &reply_host);
               :
               ://         std::cout << "mediator_reader on " << get_bind_host()
               ://                   << ": got request for "
               ://                   << x << "," << y << "," << z << endl;
               :        int metadata_size = in->getExtractedSize();
               :        in->resetExtract();
               :        ImageCoordinate ic(x,y,z);
               :        if (image_descriptor_string != image_descriptor_string_last) {
               :            image_descriptor.init_from_string(image_descriptor_string);
               :        }
               :        ImagePart part = image_descriptor.get_part(ic);
               :        if ((f = fopen(part.filename.c_str(), "r")) == NULL) {
               :            std::cerr << "ERROR: opening file " << part.filename
               :                      << " at " << __FILE__ << ":" << __LINE__
               :                      << std::endl << std::flush;
               :            exit(1);
               :        }
               :        if (fseeko(f, part.byte_offset, SEEK_SET) != 0) {
               :            std::cerr << "ERROR: fseeko(), errno=" << errno
               :                      << " at " << __FILE__ << ":" << __LINE__
               :                      << std::endl << std::flush;
               :            exit(1);
               :        }
               :        int nchannels;
               :        off_t width, height;
               :        DCBuffer * output;
               :        image_descriptor.get_pixel_count_in_chunk(ic, width, height);
               :        if (image_descriptor.type == "BGRplanar") {
               :            nchannels = 3;
               :        }
               :        else {
               :            std::cerr << "ERROR:  unsupported image type"
               :                      << " at " << __FILE__ << ":" << __LINE__
               :                      << std::endl << std::flush;
               :            exit(1);
               :        }
               :        int sz = width*height*nchannels;
               :        output = new DCBuffer(metadata_size + 16 + sz);
     1 2.2e-04 :        output->pack("isiiissll",
               :                     MEDIATOR_READ_RESPONSE,
               :                     image_descriptor_string.c_str(),
               :                     x,y,z, reply_port.c_str(), reply_host.c_str(),
               :                     width, height);
               :        if (fread(output->getPtrFree(), sz, 1, f) < 1) {
               :            std::cerr << "ERROR: calling fread()"
               :                      << " at " << __FILE__ << ":" << __LINE__
               :                      << std::endl << std::flush;
               :            exit(1);
               :        }
               :        output->incrementUsedSize(sz);
               :        this->write_nocopy(output, "2m");
               :        if (fclose(f) != 0) {
               :            std::cerr << "ERROR: calling fclose()"
               :                      << " at " << __FILE__ << ":" << __LINE__
               :                      << std::endl << std::flush;
               :            exit(1);
               :        }
               :        in->consume();
               :        image_descriptor_string_last = image_descriptor_string;
               :    }
               :    return 0;
               :}
               :
               :int ocvm_mediator_tester::process(void)
               :{
               :    DCBuffer * out;
               :    FILE * f;
               :    int packet_type;
               :    ImageDescriptor image_descriptor;
               :    std::string image_descriptor_string = get_param("image_descriptor_string");
               :    std::string myhostname = get_param("myhostname");
               :    std::string reply_port;
               :    std::string reply_host;
               :    int4 x, y, z;
               :    int4 xmax, ymax, zmax;
               :
               :    image_descriptor.init_from_string(image_descriptor_string);
               :    xmax = image_descriptor.chunks_x;
               :    ymax = image_descriptor.chunks_y;
               :    zmax = image_descriptor.chunks_z;
               :    // fetch all chunks twice
               :    for (int reps = 0; reps < 2; reps++) {
               :        for (z = 0; z < zmax; z++) {
               :            for (y = 0; y < ymax; y++) {
               :                for (x = 0; x < xmax; x++) {
               :                    MediatorImageResult * result =
               :                        mediator_read(image_descriptor_string.c_str(),
               :                                      x, y, z);
               :                    std::cout << "ocvm_mediator_tester on "
               :                              << myhostname
               :                              << " got "
               :                              << result->width << "x" << result->height
               :                              << " image coordinate "
               :                              << x << "," << y << "," << z
               :                              << " back, with " << result->data_size
               :                              << " bytes in the buffer\n";
               ://                     if (getenv("DISPLAY")) {
               ://                         ocvm_view_bgrp(result->data,
               ://                                        result->width,
               ://                                        result->height);
               ://                     }
               :                    delete result;
               :                }
               :            }
               :        }
               :    }
               :    mediator_say_goodbye();
               :    return 0;
               :}
/* 
 * Total samples for file : "/nfs/1/home/rutt/dev/ocvm/ocvm-cvs/src/ocvmcommon.cpp"
 * 
 *      1 2.2e-04
 */


               :#include "ocvm.h"
               :
               :using namespace std;
               :
               :std::ostream& operator<<(std::ostream &o, const ImageCoordinate & i)
               :{
               :    return o
               :        << i.x << " "
               :        << i.y << " "
               :        << i.z;
               :}
               :
               :std::ostream& operator<<(std::ostream &o, const ImagePart & i)
               :{
               :    o << "part " << i.coordinate << " "
               :      << i.hostname << " "
               :      << i.filename;
               :    if (i.byte_offset) {
               :        o << " " << i.byte_offset;
               :    }
               :    return o;
               :}
               :
               :std::ostream& operator<<(std::ostream &o, const ImageDescriptor& i)
               :{
               :    o << "type " << i.type << endl;
               :    o << "pixels_x " << i.pixels_x << endl
               :      << "pixels_y " << i.pixels_y << endl
               :      << "pixels_z " << i.pixels_z << endl
               :      << "chunks_x " << i.chunks_x << endl
               :      << "chunks_y " << i.chunks_y << endl
               :      << "chunks_z " << i.chunks_z << endl;
               :    int i2;
               :    o << "chunk_dimensions_x";
               :    for (i2 = 0; i2 < i.chunks_x; i2++) {
               :        o << " " << i.chunk_dimensions_x[i2];
               :    }
               :    o << "\n";
               :    o << "chunk_dimensions_y";
               :    for (i2 = 0; i2 < i.chunks_y; i2++) {
               :        o << " " << i.chunk_dimensions_y[i2];
               :    }
               :    o << "\n";
               :    unsigned int u;
               :    for (u = 0; u < i.parts.size(); u++) {
               :        o << i.parts[u] << endl;
               :    }
               :    if (i.extra.empty()==false) {
               :        o << "extra " << i.extra << endl;
               :    }
               :    if (i.timestamp.empty()==false) {
               :        o << "timestamp " << i.timestamp << endl;
               :    }
               :    return o;
               :}
               :
               :void ImageDescriptor::init_from_file(std::string filename)
               :{
               :    if (!fileExists(filename)) {
               :        std::cerr << "ERROR: in ImageDescriptor::init_from_file(): "
               :                  << filename << " does not exist"
               :                  << std::endl << std::flush;
               :        exit(1);
               :    }
               :    std::string s = file_to_string(filename);
               :    this->init_from_string(s);
               :}
               :void ImageDescriptor::init_from_string(std::string s)
               :{ /* ImageDescriptor::init_from_string(std::string) total:      1 2.2e-04 */
               :    this->chunk_dimensions_x.clear();
               :    this->chunk_dimensions_y.clear();
               :    this->chunk_offsets_x.clear();
               :    this->chunk_offsets_y.clear();
               :    this->timestamp = "";
               :    this->extra = "";
               :    this->parts.clear();
               :    this->coordinate_parts_inited = false;
               :    uint u, u2;
               :    std::vector< std::string> lines = str_tokenize(s, "\n");
     1 2.2e-04 :    for (u = 0; u < lines.size(); u++) {
               :        std::vector< std::string> tokens = str_tokenize(lines[u]);
               :        const std::string & term = tokens[0];
               :        if (term[0] == '#') {
               :            ;
               :        }
               :        else if (term == "type") {
               :            this->type = tokens[1];
               :        }
               :        else if (term == "pixels_x") {
               :            this->pixels_x = Atoi(tokens[1]);
               :        }
               :        else if (term == "pixels_y") {
               :            this->pixels_y = Atoi(tokens[1]);
               :        }
               :        else if (term == "pixels_z") {
               :            this->pixels_z = Atoi(tokens[1]);
               :        }
               :        else if (term == "chunks_x") {
               :            this->chunks_x = Atoi(tokens[1]);
               :        }
               :        else if (term == "chunks_y") {
               :            this->chunks_y = Atoi(tokens[1]);
               :        }
               :        else if (term == "chunks_z") {
               :            this->chunks_z = Atoi(tokens[1]);
               :        }
               :        else if (term == "chunk_dimensions_x") {
               :            max_dimension_x = -1;
               :            int8 offset = 0;
               :            for (u2 = 1; u2 < tokens.size(); u2++) {
               :                this->chunk_dimensions_x.push_back(Atoi8(tokens[u2]));
               :                this->chunk_offsets_x.push_back(offset);
               :                offset += this->chunk_dimensions_x[u2-1];
               :                max_dimension_x = max(max_dimension_x,
               :                                      this->chunk_dimensions_x[u2-1]);
               :            }
               :        }
               :        else if (term == "chunk_dimensions_y") {
               :            max_dimension_y = -1;
               :            int8 offset = 0;
               :            for (u2 = 1; u2 < tokens.size(); u2++) {
               :                this->chunk_dimensions_y.push_back(Atoi8(tokens[u2]));
               :                this->chunk_offsets_y.push_back(offset);
               :                offset += this->chunk_dimensions_y[u2-1];
               :                max_dimension_y = max(max_dimension_y,
               :                                      this->chunk_dimensions_y[u2-1]);
               :            }
               :        }
               :        else if (term == "part") {
               :            ImageCoordinate ic(Atoi(tokens[1]),
               :                               Atoi(tokens[2]),
               :                               Atoi(tokens[3]));
               :            off_t offset = 0;
               :            if (tokens.size()==7) {
               :                offset = Atoi(tokens[6]);
               :            }
               :            ImagePart p(ic, tokens[4], tokens[5], offset);
               :            this->parts.push_back(p);
               :        }
               :        else if (term == "extra") {
               :            this->extra = "";
               :            uint u2;
               :            for (u2 = 1; u2 < tokens.size(); u2++) {
               :                if (u2 > 1) {
               :                    this->extra += " ";
               :                }
               :                this->extra += tokens[u2];
               :            }
               :        }
               :        else if (term == "timestamp") {
               :            uint u2;
               :            for (u2 = 1; u2 < tokens.size(); u2++) {
               :                if (u2 > 1) {
               :                    this->timestamp += " ";
               :                }
               :                this->timestamp += tokens[u2];
               :            }
               :        }
               :        else {
               :            std::cerr << "ERROR: parsing image descriptor:\n"
               :                      << "----------------------------------\n"
               :                      << s
               :                      << "----------------------------------\n"
               :                      << "at line " << lines[u]
               :                      << std::endl << std::flush;
               :            exit(1);
               :        }
               :    }
               :    assert(this->chunk_dimensions_x.size() == this->chunks_x);
               :    assert(this->chunk_dimensions_y.size() == this->chunks_y);
               :}
               :
               :static int ocvmSetSocketReuse(int socket)
               :{
               :    int opt = 1;
               :    if (setsockopt(socket, SOL_SOCKET, SO_REUSEADDR,
               :                   &opt, sizeof(opt)) != 0) {
               :        return -1;
               :    }
               :    return 0;
               :}
               :
               :int ocvmOpenClientSocket(const char * serverHost, uint2 port)
               :{
               :    int serverSocket = -1;
               :    struct sockaddr_in remoteAddr;
               :    struct hostent * hostEnt;
               :
               :    if ((serverSocket = socket(AF_INET, SOCK_STREAM, 0)) < 0) {
               :        serverSocket = -1;
               :        goto Exit;
               :    }
               :    memset(&remoteAddr, 0, sizeof(remoteAddr));
               :    remoteAddr.sin_family = AF_INET;
               :    remoteAddr.sin_port = htons(port);
               :    hostEnt = gethostbyname(serverHost);
               :    if (hostEnt == NULL) {
               :        close(serverSocket);
               :        serverSocket = -1;
               :        goto Exit;
               :    }
               :    memcpy(&remoteAddr.sin_addr.s_addr, hostEnt->h_addr_list[0],
               :           hostEnt->h_length);
               :
               :    if (connect(serverSocket, (struct sockaddr*)&remoteAddr,
               :                sizeof(remoteAddr)) != 0) {
               :        close(serverSocket);
               :        serverSocket = -1;
               :        goto Exit;
               :    }
               :
               :Exit:
               :    return serverSocket;
               :}
               :
               :int ocvmOpenListenSocket(uint2 port)
               :{
               :    struct sockaddr_in serverAddr;
               :    int serverSd;
               :    
               :    if ((serverSd = socket(AF_INET, SOCK_STREAM, 0)) < 0) {
               :        return -1;
               :    }
               :    if (ocvmSetSocketReuse(serverSd)) {
               :        return -1;
               :    }
               :    memset(&serverAddr, 0, sizeof(serverAddr));
               :    serverAddr.sin_family = AF_INET;
               :    serverAddr.sin_port = htons(port);
               :    serverAddr.sin_addr.s_addr = htonl(INADDR_ANY);
               :    if ((bind(serverSd, (struct sockaddr*)&serverAddr,
               :              sizeof(serverAddr)) != 0)) {
               :        return -1;
               :    }
               :    if (listen(serverSd, 5) != 0) {
               :        return -1;
               :    }
               :    return serverSd;
               :}
               :
               :int ocvmOpenListenSocket(uint2 * port)
               :{
               :    struct sockaddr_in serverAddr;
               :    struct sockaddr_in actualAddr;
               :    socklen_t actualAddrLen = sizeof(actualAddrLen);
               :    int serverSd;
               :    
               :    if ((serverSd = socket(AF_INET, SOCK_STREAM, 0)) < 0) {
               :        return -1;
               :    }
               :    if (ocvmSetSocketReuse(serverSd)) {
               :        return -1;
               :    }
               :    memset(&serverAddr, 0, sizeof(serverAddr));
               :    serverAddr.sin_family = AF_INET;
               :    serverAddr.sin_port = htons(0);
               :    serverAddr.sin_addr.s_addr = htonl(INADDR_ANY);
               :    if (bind(serverSd, (struct sockaddr*)&serverAddr,sizeof(serverAddr)) != 0) {
               :        return -1;
               :    }
               :    if (listen(serverSd, 5) != 0) {
               :        return -1;
               :    }
               :
               :    if (getsockname(serverSd, (struct sockaddr*)&actualAddr, &actualAddrLen)
               :        != 0) {
               :        return -1;
               :    }
               :    *port = (uint2)ntohs(actualAddr.sin_port);
               :
               :    return serverSd;
               :}
               :
               :int ocvm_read_all(int fd, void *buf, size_t count, int * hitEOF)
               :{
               :    ssize_t retcode;
               :    size_t  offset = 0;
               :    size_t  bytes_read;
               :    int     rc = 0;
               :
               :    if (count == 0) {
               :        return 0;
               :    }
               :
               :    if (hitEOF) {
               :        *hitEOF = 0;
               :    }
               :
               :    while (1) {
               :        retcode = read(fd, (unsigned char*)buf + offset, count);
               :        if (retcode < 0) {
               :            rc = errno;
               :            if (rc == 0) /* handle another thread set errno */
               :                rc = EIO;
               :            goto Exit;
               :        }
               :        else if (retcode == 0) {
               :            if (hitEOF)
               :                *hitEOF = 1;
               :            rc = (errno != 0)?errno:-1;
               :            break;
               :        }
               :        bytes_read = (size_t)retcode;
               :        if (count == bytes_read) /* write complete */
               :            break;
               :        count -= bytes_read;
               :        offset += bytes_read;
               :    }
               :
               :Exit: 
               :    return rc;
               :}
               :
               :int ocvm_write_all(int fd, const void * buf, size_t count)
               :{
               :    ssize_t retcode;
               :    size_t  offset = 0;
               :    size_t  bytes_written;
               :    int     rc = 0;
               :
               :    if (count == 0) {
               :        return 0;
               :    }
               :
               :    while (1)
               :    {
               :        retcode = write(fd, (unsigned char*)buf + offset, count);
               :        if (retcode < 0)
               :        {
               :            rc = errno;
               :            if (rc == 0) /* handle another thread set errno */
               :                rc = EIO;
               :            goto Exit;
               :        }
               :        bytes_written = (size_t)retcode;
               :        if (count == bytes_written) /* write complete */
               :            break;
               :        count -= bytes_written;
               :        offset += bytes_written;
               :    }
               :Exit: 
               :    return rc;
               :}
               :
               :int ocvm_write_message(int fd, std::string & message)
               :{
               :    return ocvm_write_all(fd, message.c_str(), message.size());
               :}
               :
               :void ocvm_view_bgrp(unsigned char * buffer,
               :                    int width,
               :                    int height)
               :{
               :    FILE * f;
               :    std::string temporary_file = dcmpi_get_temp_filename();
               :    if ((f = fopen(temporary_file.c_str(), "w")) == NULL) {
               :        std::cerr << "ERROR: errno=" << errno << " opening file"
               :                  << " at " << __FILE__ << ":" << __LINE__
               :                  << std::endl << std::flush;
               :        exit(1);
               :    }
               :    if (fwrite(buffer, width*height*3, 1, f) < 1) {
               :        std::cerr << "ERROR: errno=" << errno << " calling fwrite()"
               :                  << " at " << __FILE__ << ":" << __LINE__
               :                  << std::endl << std::flush;
               :        exit(1);
               :    }
               :    if (fclose(f) != 0) {
               :        std::cerr << "ERROR: errno=" << errno << " calling fclose()"
               :                  << " at " << __FILE__ << ":" << __LINE__
               :                  << std::endl << std::flush;
               :        exit(1);
               :    }
               :    std::string command = "bgrpview ";
               :    command += temporary_file;
               :    command += " ";
               :    command += tostr(width);
               :    command += " ";
               :    command += tostr(height);
               :    system (command.c_str());
               :    remove (temporary_file.c_str());
               :}
               :
               :ImageDescriptor conjure_tessellation_descriptor(
               :    ImageDescriptor & original_image_descriptor,
               :    int new_parts_per_chunk,
               :    int8 memory_per_host,
               :    int user_tessellation_x,
               :    int user_tessellation_y,
               :    std::vector<int8> & divided_original_chunk_dims_x,
               :    std::vector<int8> & divided_original_chunk_dims_y,
               :    std::vector<int8> & sourcepixels_x,
               :    std::vector<int8> & sourcepixels_y,
               :    std::vector<int8> & leading_skips_x,
               :    std::vector<int8> & leading_skips_y)
               :{
               :    ImageDescriptor out;
               :    sourcepixels_x.clear();
               :    sourcepixels_y.clear();
               :    sourcepixels_x = original_image_descriptor.chunk_dimensions_x;
               :    if (new_parts_per_chunk == 1) {
               :        sourcepixels_y = original_image_descriptor.chunk_dimensions_y;
               :    }
               :    else {
               :        int y;
               :        for (y = 0; y < original_image_descriptor.chunk_dimensions_y.size(); y++) {
               :            int8 original_dimension = original_image_descriptor.chunk_dimensions_y[y];
               :            int8 standard_cover = original_dimension / new_parts_per_chunk;
               :            for (int i = 0; i < new_parts_per_chunk-1; i++) {
               :                sourcepixels_y.push_back(standard_cover);
               :            }
               :            sourcepixels_y.push_back(
               :                original_dimension - standard_cover*(new_parts_per_chunk-1));
               :        }
               :    }
               :    
               :    std::copy(sourcepixels_x.begin(), sourcepixels_x.end(),
               :              std::inserter(divided_original_chunk_dims_x, divided_original_chunk_dims_x.begin()));
               :    std::copy(sourcepixels_y.begin(), sourcepixels_y.end(),
               :              std::inserter(divided_original_chunk_dims_y, divided_original_chunk_dims_y.begin()));
               :    
               :    std::vector<int8> new_image_dimensions_x;
               :    std::vector<int8> new_image_dimensions_y;
               :    int8 carry;
               :
               :    carry = 0;
               :    for (uint x = 0; x < sourcepixels_x.size(); x++) {
               :        leading_skips_x.push_back(carry);
               :        int8 cur = sourcepixels_x[x] - carry;
               :        int8 full = (cur / user_tessellation_x);
               :        if (x != sourcepixels_x.size()-1 && full * user_tessellation_x < cur) {
               :            carry = (full+1) * user_tessellation_x - cur;
               :            cur = (full+1) * user_tessellation_x;
               :        }
               :        else {
               :            carry = 0;
               :        }
               :        sourcepixels_x[x] = cur;
               :    }
               :    carry = 0;
               :    for (uint y = 0; y < sourcepixels_y.size(); y++) {
               :        leading_skips_y.push_back(carry);
               :        int8 cur = sourcepixels_y[y] - carry;
               :        int8 full = (cur / user_tessellation_y);
               :        if (y != sourcepixels_y.size()-1 && full * user_tessellation_y < cur) {
               :            carry = (full+1) * user_tessellation_y - cur;
               :            cur = (full+1) * user_tessellation_y;
               :        }
               :        else {
               :            carry = 0;
               :        }
               :        sourcepixels_y[y] = cur;
               :    }
               :
               :    int8 new_pixels_x = 0;
               :    for (uint x = 0; x < sourcepixels_x.size(); x++) {
               :        new_image_dimensions_x.push_back(
               :            sourcepixels_x[x] / user_tessellation_x);
               :        if (x == sourcepixels_x.size()-1) {
               :            if (sourcepixels_x[x] % user_tessellation_x) {
               :                new_image_dimensions_x[x] += 1;
               :            }
               :        }
               :        new_pixels_x += new_image_dimensions_x[x];
               :    }
               :
               :    int8 new_pixels_y = 0;
               :    for (uint y = 0; y < sourcepixels_y.size(); y++) {
               :        new_image_dimensions_y.push_back(
               :            sourcepixels_y[y] / user_tessellation_y);
               :        if (y == sourcepixels_y.size()-1) {
               :            if (sourcepixels_y[y] % user_tessellation_y) {
               :                new_image_dimensions_y[y] += 1;
               :            }
               :        }
               :        new_pixels_y += new_image_dimensions_y[y];
               :    }
               :
               :    out.type = "tessellation";
               :    out.pixels_x = new_pixels_x;
               :    out.pixels_y = new_pixels_y;
               :    out.pixels_z = original_image_descriptor.pixels_z;
               :    out.chunks_x = original_image_descriptor.chunks_x;
               :    out.chunks_y = original_image_descriptor.chunks_y * new_parts_per_chunk;
               :    out.chunks_z = original_image_descriptor.chunks_z;
               :    out.chunk_dimensions_x = new_image_dimensions_x;
               :    out.chunk_dimensions_y = new_image_dimensions_y;
               :    for (uint z = 0; z < original_image_descriptor.chunks_z; z++) {
               :        for (uint y = 0; y < original_image_descriptor.chunks_y; y++) {
               :            for (uint x = 0; x < original_image_descriptor.chunks_x; x++) {
               :                ImageCoordinate c(x,y,z);
               :                ImagePart part = original_image_descriptor.get_part(c);
               :                int idx;
               :                for (idx = 0; idx < new_parts_per_chunk; idx++) {
               :                    ImagePart newpart = part;
               :                    newpart.coordinate.y *= new_parts_per_chunk;
               :                    newpart.coordinate.y += idx;
               :                    newpart.filename += "_p" + tostr(idx);
               :                    out.parts.push_back(newpart);
               :                }       
               :            }
               :        }
               :    }
               :    return out;
               :}
               :
               :MediatorInfo mediator_setup(
               :    DCLayout & layout,
               :    int nreaders_per_host,
               :    std::vector<std::string> hosts,
               :    int cache_size)
               :{
               :    MediatorInfo out;
               :    uint u, u2;
               :    
               :    layout.use_filter_library("libocvmfilters.so");
               :    for (u = 0; u < hosts.size(); u++) {
               :        std::string host = hosts[u];
               :        DCFilterInstance * mediator = new DCFilterInstance("ocvm_mediator",
               :                                                           tostr("mediator_") +
               :                                                           tostr(host));
               :        out.mediators.push_back(mediator);
               :        layout.add(mediator);
               :        mediator->add_label(host);
               :        mediator->set_param("myhostname", host);
               :        mediator->set_param("mediators_that_need_me", tostr(hosts.size() - 1));
               :        mediator->set_param("cache_size", tostr(cache_size));
               :        mediator->bind_to_host(host);
               :        std::vector<DCFilterInstance *> readers2;
               :        for (int i = 0; i < nreaders_per_host; i++) {
               :            readers2.push_back(new DCFilterInstance("ocvm_mediator_reader",
               :                                                   tostr("r_") +
               :                                                   tostr(host) +
               :                                                   "_" + tostr(i)));
               :            readers2[i]->set_param("myhostname", host);
               :            layout.add(readers2[i]);
               :            readers2[i]->bind_to_host(host);
               :            layout.add_port(mediator, "2r", readers2[i], "0");
               :            layout.add_port(readers2[i], "2m", mediator, "0");
               :        }
               :        out.readers.push_back(readers2);
               :    }
               :    for (u = 0; u < hosts.size(); u++) {
               :        for (u2 = 0; u2 < hosts.size(); u2++) {
               :            if (u == u2) {
               :                continue;
               :            }
               :            layout.add_port(out.mediators[u], "m2m",
               :                            out.mediators[u2], "0");
               :        }
               :    }
               :    return out;
               :}
               :
               :void mediator_add_client(
               :    DCLayout & layout,
               :    MediatorInfo & mediator_info,
               :    std::vector<DCFilterInstance *> clients)
               :{
               :    std::vector<DCFilterInstance*> & mediators = mediator_info.mediators;
               :    uint u;
               :    assert(mediators.size() == clients.size());
               :    int nclients = 0;
               :    if (mediators[0]->has_param("clients_that_need_me")) {
               :        nclients = Atoi(mediators[0]->get_param("clients_that_need_me"));
               :    }
               :    nclients++;
               :    for (u = 0; u < mediators.size(); u++) {
               :        mediators[u]->set_param("clients_that_need_me", nclients);
               :        layout.add_port(
               :            mediators[u], tostr("to_") + clients[u]->get_instance_name(),
               :            clients[u], "from_mediator");
               :        layout.add_port(clients[u], "to_mediator", mediators[u], "0");
               :    }
               :}
               :
               :void JibberXMLDescriptor::init_from_file(std::string filename)
               :{
               :    if (!fileExists(filename)) {
               :        std::cerr << "ERROR: in JibberXMLDescriptor::init_from_file(): "
               :                  << filename << " does not exist"
               :                  << std::endl << std::flush;
               :        exit(1);
               :    }
               :    std::string s = file_to_string(filename);
               :    this->init_from_string(s);
               :}
               :
               :void JibberXMLDescriptor::init_from_string(std::string s)
               :{
               :    std::vector< std::string> lines = str_tokenize(s, "\n");
               :    uint line_count = 0;
               :    num_control_points = 0;
               :    ControlPtCorrespondence *corr;
               :    bool isOrigin = true;
               :
               :    while (line_count < lines.size()) {
               :        std::vector< std::string> tokens = str_tokenize(lines[line_count]);
               :        const std::string & term = tokens[0];
               :        if (dcmpi_string_starts_with(term, "<locality>")) {
               :            std::string reply = extract_value_from_tag(term, "locality>");
               :            delta = atoi(reply.c_str());
               :            line_count++;
               :        }
               :        else if (dcmpi_string_starts_with(term, "<x>")) {
               :            std::string reply = extract_value_from_tag(term, "x>"); 
               :            if (isOrigin) {
               :                corr = new ControlPtCorrespondence();
               :                corr->origin_x = atof(reply.c_str());
               :            }
               :            else {
               :                corr->endpoint_x = atof(reply.c_str());
               :            }
               :            line_count++;
               :        }
               :        else if (dcmpi_string_starts_with(term, "<y>")) {
               :            std::string reply = extract_value_from_tag(term, "y>"); 
               :            if (isOrigin) {
               :                corr->origin_y = atof(reply.c_str());
               :                isOrigin = false;
               :            }
               :            else {
               :                corr->endpoint_y = atof(reply.c_str());
               :            }
               :            line_count++;
               :        }
               :        else if (dcmpi_string_starts_with(term, "<weight>")) {
               :            std::string reply = extract_value_from_tag(term, "weight>"); 
               :            corr->weight = atoi(reply.c_str());
               :            correspondences.push_back(corr);
               :            num_control_points++;
               :            isOrigin = true;
               :            line_count++;
               :        }
               :        else {
               :            line_count++;
               :        }
               :/*
               :        else {
               :            std::cerr << "ERROR: parsing image descriptor:\n"
               :                      << "----------------------------------\n"
               :                      << s
               :                      << "----------------------------------\n"
               :                      << "at line " << lines[u]
               :                      << std::endl << std::flush;
               :            exit(1);
               :        }
               :*/
               :    }
               :
               :    
               :}
               :
               :std::string JibberXMLDescriptor::extract_value_from_tag(std::string term, std::string tag)
               :{
               :    char *value = NULL;
               :    int value_length = 0;
               :    char *p1, *p2;
               :
               :    p1 = strstr(term.c_str(), tag.c_str());
               :
               :    if (p1 != NULL) {
               :        value = p1 + strlen(tag.c_str());
               :    }
               :
               :    p1 = p1 + strlen(tag.c_str());
               :    tag = "</" + tag;
               :    p2 = strstr(value, tag.c_str());
               :
               :    if (p2 != NULL) {
               :        while (*(p1++) != *p2) {
               :           value_length++;
               :        } 
               :    }
               :
               :    char * final_value = (char *)malloc((value_length+1) * sizeof(char));
               :    for (int i = 0; i < value_length; i++) {
               :        final_value[i] = *(value + i);
               :    }
               :    final_value[value_length] = '\0';
               :
               :    return tostr(final_value);
               :}
